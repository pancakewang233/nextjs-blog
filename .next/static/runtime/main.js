(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["static/runtime/main.js"],{

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/extends.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/extends.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _extends() {
  module.exports = _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

module.exports = _extends;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/client.js":
/*!************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/client.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var Bus = __importStar(__webpack_require__(/*! ./internal/bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js"));
var parseStack_1 = __webpack_require__(/*! ./internal/helpers/parseStack */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js");
var isRegistered = false;
var stackTraceLimit = undefined;
function onUnhandledError(ev) {
    var error = ev === null || ev === void 0 ? void 0 : ev.error;
    if (!error || !(error instanceof Error) || typeof error.stack !== 'string') {
        // A non-error was thrown, we don't have anything to show. :-(
        return;
    }
    var e = error;
    Bus.emit({
        type: Bus.TYPE_UNHANDLED_ERROR,
        reason: error,
        frames: parseStack_1.parseStack(e.stack)
    });
}
function onUnhandledRejection(ev) {
    var reason = ev === null || ev === void 0 ? void 0 : ev.reason;
    if (!reason ||
        !(reason instanceof Error) ||
        typeof reason.stack !== 'string') {
        // A non-error was thrown, we don't have anything to show. :-(
        return;
    }
    var e = reason;
    Bus.emit({
        type: Bus.TYPE_UNHANDLED_REJECTION,
        reason: reason,
        frames: parseStack_1.parseStack(e.stack)
    });
}
function register() {
    if (isRegistered) {
        return;
    }
    isRegistered = true;
    try {
        var limit = Error.stackTraceLimit;
        Error.stackTraceLimit = 50;
        stackTraceLimit = limit;
    }
    catch (_a) { }
    window.addEventListener('error', onUnhandledError);
    window.addEventListener('unhandledrejection', onUnhandledRejection);
}
exports.register = register;
function unregister() {
    if (!isRegistered) {
        return;
    }
    isRegistered = false;
    if (stackTraceLimit !== undefined) {
        try {
            Error.stackTraceLimit = stackTraceLimit;
        }
        catch (_a) { }
        stackTraceLimit = undefined;
    }
    window.removeEventListener('error', onUnhandledError);
    window.removeEventListener('unhandledrejection', onUnhandledRejection);
}
exports.unregister = unregister;
function onBuildOk() {
    Bus.emit({ type: Bus.TYPE_BUILD_OK });
}
exports.onBuildOk = onBuildOk;
function onBuildError(message) {
    Bus.emit({ type: Bus.TYPE_BUILD_ERROR, message: message });
}
exports.onBuildError = onBuildError;
function onRefresh() {
    Bus.emit({ type: Bus.TYPE_REFFRESH });
}
exports.onRefresh = onRefresh;
var nodeStackFrames_1 = __webpack_require__(/*! ./internal/helpers/nodeStackFrames */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js");
exports.getNodeError = nodeStackFrames_1.getNodeError;
var ReactDevOverlay_1 = __webpack_require__(/*! ./internal/ReactDevOverlay */ "./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js");
exports.ReactDevOverlay = ReactDevOverlay_1["default"];


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var ErrorBoundary = /** @class */ (function (_super) {
    __extends(ErrorBoundary, _super);
    function ErrorBoundary() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = { error: null };
        return _this;
    }
    ErrorBoundary.prototype.componentDidCatch = function (error, 
    // Loosely typed because it depends on the React version and was
    // accidentally excluded in some versions.
    errorInfo) {
        this.props.onError(error, (errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.componentStack) || null);
        this.setState({ error: error });
    };
    ErrorBoundary.prototype.render = function () {
        return this.state.error
            ? // The component has to be unmounted or else it would continue to error
                null
            : this.props.children;
    };
    return ErrorBoundary;
}(react_1["default"].PureComponent));
exports.ErrorBoundary = ErrorBoundary;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/ReactDevOverlay.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var Bus = __importStar(__webpack_require__(/*! ./bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js"));
var ShadowPortal_1 = __webpack_require__(/*! ./components/ShadowPortal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js");
var Errors_1 = __webpack_require__(/*! ./container/Errors */ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js");
var BuildError_1 = __webpack_require__(/*! ./container/BuildError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js");
var ErrorBoundary_1 = __webpack_require__(/*! ./ErrorBoundary */ "./node_modules/@next/react-dev-overlay/lib/internal/ErrorBoundary.js");
var Base_1 = __webpack_require__(/*! ./styles/Base */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js");
var ComponentStyles_1 = __webpack_require__(/*! ./styles/ComponentStyles */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js");
var CssReset_1 = __webpack_require__(/*! ./styles/CssReset */ "./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js");
function reducer(state, ev) {
    switch (ev.type) {
        case Bus.TYPE_BUILD_OK: {
            return __assign(__assign({}, state), { buildError: null });
        }
        case Bus.TYPE_BUILD_ERROR: {
            return __assign(__assign({}, state), { buildError: ev.message });
        }
        case Bus.TYPE_REFFRESH: {
            return __assign(__assign({}, state), { buildError: null, errors: [] });
        }
        case Bus.TYPE_UNHANDLED_ERROR:
        case Bus.TYPE_UNHANDLED_REJECTION: {
            return __assign(__assign({}, state), { nextId: state.nextId + 1, errors: __spread(state.errors, [{ id: state.nextId, event: ev }]) });
        }
        default: {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            var _1 = ev;
            return state;
        }
    }
}
function ReactDevOverlay(_a) {
    var children = _a.children;
    var _b = __read(React.useReducer(reducer, { nextId: 1, buildError: null, errors: [] }), 2), state = _b[0], dispatch = _b[1];
    React.useEffect(function () {
        Bus.on(dispatch);
        return function () {
            Bus.off(dispatch);
        };
    }, [dispatch]);
    var onComponentError = React.useCallback(function (error, componentStack) {
        // TODO: special handling
    }, []);
    var hasBuildError = state.buildError != null;
    var hasRuntimeErrors = Boolean(state.errors.length);
    var isMounted = hasBuildError || hasRuntimeErrors;
    return (React.createElement(React.Fragment, null,
        React.createElement(ErrorBoundary_1.ErrorBoundary, { onError: onComponentError }, children !== null && children !== void 0 ? children : null),
        isMounted ? (React.createElement(ShadowPortal_1.ShadowPortal, null,
            React.createElement(CssReset_1.CssReset, null),
            React.createElement(Base_1.Base, null),
            React.createElement(ComponentStyles_1.ComponentStyles, null),
            hasBuildError ? (React.createElement(BuildError_1.BuildError, { message: state.buildError })) : hasRuntimeErrors ? (React.createElement(Errors_1.Errors, { errors: state.errors })) : (undefined))) : (undefined)));
}
exports["default"] = ReactDevOverlay;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js":
/*!******************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/bus.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.TYPE_BUILD_OK = 'build-ok';
exports.TYPE_BUILD_ERROR = 'build-error';
exports.TYPE_REFFRESH = 'fast-refresh';
exports.TYPE_UNHANDLED_ERROR = 'unhandled-error';
exports.TYPE_UNHANDLED_REJECTION = 'unhandled-rejection';
var handlers = new Set();
var queue = [];
function drain() {
    // Draining should never happen synchronously in case multiple handlers are
    // registered.
    setTimeout(function () {
        var _loop_1 = function () {
            var ev = queue.shift();
            handlers.forEach(function (handler) { return handler(ev); });
        };
        while (
        // Until we are out of events:
        Boolean(queue.length) &&
            // Or, if all handlers removed themselves as a result of handling the
            // event(s)
            Boolean(handlers.size)) {
            _loop_1();
        }
    }, 1);
}
function emit(ev) {
    queue.push(Object.freeze(__assign({}, ev)));
    drain();
}
exports.emit = emit;
function on(fn) {
    if (handlers.has(fn)) {
        return false;
    }
    handlers.add(fn);
    drain();
    return true;
}
exports.on = on;
function off(fn) {
    if (handlers.has(fn)) {
        handlers["delete"](fn);
        return true;
    }
    return false;
}
exports.off = off;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var anser_1 = __importDefault(__webpack_require__(/*! anser */ "./node_modules/anser/lib/index.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var strip_ansi_1 = __importDefault(__webpack_require__(/*! strip-ansi */ "./node_modules/@next/react-dev-overlay/node_modules/strip-ansi/index.js"));
var stack_frame_1 = __webpack_require__(/*! ../../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
exports.CodeFrame = function CodeFrame(_a) {
    var stackFrame = _a.stackFrame, codeFrame = _a.codeFrame;
    // Strip leading spaces out of the code frame:
    var formattedFrame = React.useMemo(function () {
        var lines = codeFrame.split(/\r?\n/g);
        var prefixLength = lines
            .map(function (line) { return /^>? +\d+ +\| ( *)/.exec(strip_ansi_1["default"](line)); })
            .filter(Boolean)
            .map(function (v) { return v.pop(); })
            .reduce(function (c, n) { return (isNaN(c) ? n.length : Math.min(c, n.length)); }, NaN);
        if (prefixLength > 1) {
            var p_1 = ' '.repeat(prefixLength);
            return lines
                .map(function (line, a) {
                return ~(a = line.indexOf('|'))
                    ? line.substring(0, a) + line.substring(a).replace(p_1, '')
                    : line;
            })
                .join('\n');
        }
        return lines.join('\n');
    }, [codeFrame]);
    var decoded = React.useMemo(function () {
        return anser_1["default"].ansiToJson(formattedFrame, {
            json: true,
            use_classes: true,
            remove_empty: true
        });
    }, [formattedFrame]);
    var open = React.useCallback(function () {
        var _a;
        var params = new URLSearchParams();
        for (var key in stackFrame) {
            params.append(key, ((_a = stackFrame[key]) !== null && _a !== void 0 ? _a : '').toString());
        }
        self.fetch("/__nextjs_launch-editor?" + params.toString()).then(function () { }, function () {
            // TODO: report error
        });
    }, [stackFrame]);
    // TODO: make the caret absolute
    return (React.createElement("div", { "data-nextjs-codeframe": true },
        React.createElement("p", { role: "link", onClick: open, tabIndex: 1, title: "Click to open in your editor" },
            React.createElement("span", null,
                stack_frame_1.getFrameSource(stackFrame),
                " @ ",
                stackFrame.methodName),
            React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                React.createElement("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
                React.createElement("polyline", { points: "15 3 21 3 21 9" }),
                React.createElement("line", { x1: "10", y1: "14", x2: "21", y2: "3" }))),
        React.createElement("hr", null),
        React.createElement("pre", null, decoded.map(function (entry, index) { return (React.createElement("span", { key: "frame-" + index, style: __assign({ color: entry.fg ? "var(--color-" + entry.fg + ")" : undefined }, (entry.decoration === 'bold'
                ? { fontWeight: 800 }
                : entry.decoration === 'italic'
                    ? { fontStyle: 'italic' }
                    : undefined)) }, entry.content)); }))));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var CodeFrame_1 = __webpack_require__(/*! ./CodeFrame */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/CodeFrame.js");
exports.CodeFrame = CodeFrame_1.CodeFrame;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-codeframe] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-codeframe]::selection,\n  [data-nextjs-codeframe] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-codeframe] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-codeframe] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  [data-nextjs-codeframe] > hr {\n    margin: 0;\n    padding: 0;\n\n    border: none;\n    border-style: solid;\n    border-width: 0;\n    border-bottom-width: 1px;\n    border-color: var(--color-ansi-bright-black);\n  }\n\n  [data-nextjs-codeframe] > p {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    cursor: pointer;\n  }\n  [data-nextjs-codeframe] > p:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-codeframe] > p > svg {\n    width: auto;\n    height: 1em;\n    margin-left: 0.5rem;\n  }\n"], ["\n  [data-nextjs-codeframe] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-codeframe]::selection,\n  [data-nextjs-codeframe] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-codeframe] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n\n  [data-nextjs-codeframe] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  [data-nextjs-codeframe] > hr {\n    margin: 0;\n    padding: 0;\n\n    border: none;\n    border-style: solid;\n    border-width: 0;\n    border-bottom-width: 1px;\n    border-color: var(--color-ansi-bright-black);\n  }\n\n  [data-nextjs-codeframe] > p {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    cursor: pointer;\n  }\n  [data-nextjs-codeframe] > p:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-codeframe] > p > svg {\n    width: auto;\n    height: 1em;\n    margin-left: 0.5rem;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var use_on_click_outside_1 = __webpack_require__(/*! ../../hooks/use-on-click-outside */ "./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js");
var Dialog = function Dialog(_a) {
    var children = _a.children, type = _a.type, onClose = _a.onClose, props = __rest(_a, ["children", "type", "onClose"]);
    var _b = __read(React.useState(null), 2), dialog = _b[0], setDialog = _b[1];
    var onDialog = React.useCallback(function (node) {
        setDialog(node);
    }, []);
    use_on_click_outside_1.useOnClickOutside(dialog, onClose);
    // Make HTMLElements with `role=link` accessible to be triggered by the
    // keyboard, i.e. [Enter].
    React.useEffect(function () {
        if (dialog == null) {
            return;
        }
        var root = dialog.getRootNode();
        // Always true, but we do this for TypeScript:
        if (!(root instanceof ShadowRoot)) {
            return;
        }
        var shadowRoot = root;
        function handler(e) {
            var el = shadowRoot.activeElement;
            if (e.key === 'Enter' &&
                el instanceof HTMLElement &&
                el.getAttribute('role') === 'link') {
                e.preventDefault();
                e.stopPropagation();
                el.click();
            }
        }
        shadowRoot.addEventListener('keydown', handler);
        return function () { return shadowRoot.removeEventListener('keydown', handler); };
    }, [dialog]);
    return (React.createElement("div", { ref: onDialog, "data-nextjs-dialog": true, tabIndex: -1, role: "dialog", "aria-labelledby": props['aria-labelledby'], "aria-describedby": props['aria-describedby'], "aria-modal": "true" },
        React.createElement("div", { "data-nextjs-dialog-banner": true, className: "banner-" + type }),
        children));
};
exports.Dialog = Dialog;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var DialogBody = function DialogBody(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-body": true, className: className }, children));
};
exports.DialogBody = DialogBody;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var DialogContent = function DialogContent(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-content": true, className: className }, children));
};
exports.DialogContent = DialogContent;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var DialogHeader = function DialogHeader(_a) {
    var children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-dialog-header": true, className: className }, children));
};
exports.DialogHeader = DialogHeader;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Dialog_1 = __webpack_require__(/*! ./Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/Dialog.js");
exports.Dialog = Dialog_1.Dialog;
var DialogBody_1 = __webpack_require__(/*! ./DialogBody */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogBody.js");
exports.DialogBody = DialogBody_1.DialogBody;
var DialogContent_1 = __webpack_require__(/*! ./DialogContent */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogContent.js");
exports.DialogContent = DialogContent_1.DialogContent;
var DialogHeader_1 = __webpack_require__(/*! ./DialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/DialogHeader.js");
exports.DialogHeader = DialogHeader_1.DialogHeader;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js");
exports.styles = styles_1.styles;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/styles.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog] {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    margin-right: auto;\n    margin-left: auto;\n    outline: none;\n    background: white;\n    border-radius: var(--size-gap);\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\n      rgba(0, 0, 0, 0.25);\n    max-height: calc(100% - 3.5rem);\n    overflow-y: hidden;\n  }\n\n  @media (min-width: 576px) {\n    [data-nextjs-dialog] {\n      max-width: 540px;\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\n    }\n  }\n\n  @media (min-width: 768px) {\n    [data-nextjs-dialog] {\n      max-width: 720px;\n    }\n  }\n\n  @media (min-width: 992px) {\n    [data-nextjs-dialog] {\n      max-width: 960px;\n    }\n  }\n\n  [data-nextjs-dialog-banner] {\n    position: relative;\n  }\n  [data-nextjs-dialog-banner].banner-warning {\n    border-color: var(--color-ansi-yellow);\n  }\n  [data-nextjs-dialog-banner].banner-error {\n    border-color: var(--color-ansi-red);\n  }\n\n  [data-nextjs-dialog-banner]::after {\n    z-index: 2;\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100%;\n    /* banner width: */\n    border-top-width: var(--size-gap-half);\n    border-bottom-width: 0;\n    border-top-style: solid;\n    border-bottom-style: solid;\n    border-top-color: inherit;\n    border-bottom-color: transparent;\n  }\n\n  [data-nextjs-dialog-content] {\n    overflow-y: auto;\n    border: none;\n    margin: 0;\n    /* calc(padding + banner width offset) */\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\n      var(--size-gap-double);\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\n    flex-shrink: 0;\n    margin-bottom: var(--size-gap-double);\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\n    position: relative;\n    flex: 1 1 auto;\n  }\n"], ["\n  [data-nextjs-dialog] {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    margin-right: auto;\n    margin-left: auto;\n    outline: none;\n    background: white;\n    border-radius: var(--size-gap);\n    box-shadow: 0 var(--size-gap-half) var(--size-gap-double)\n      rgba(0, 0, 0, 0.25);\n    max-height: calc(100% - 3.5rem);\n    overflow-y: hidden;\n  }\n\n  @media (min-width: 576px) {\n    [data-nextjs-dialog] {\n      max-width: 540px;\n      box-shadow: 0 var(--size-gap) var(--size-gap-quad) rgba(0, 0, 0, 0.25);\n    }\n  }\n\n  @media (min-width: 768px) {\n    [data-nextjs-dialog] {\n      max-width: 720px;\n    }\n  }\n\n  @media (min-width: 992px) {\n    [data-nextjs-dialog] {\n      max-width: 960px;\n    }\n  }\n\n  [data-nextjs-dialog-banner] {\n    position: relative;\n  }\n  [data-nextjs-dialog-banner].banner-warning {\n    border-color: var(--color-ansi-yellow);\n  }\n  [data-nextjs-dialog-banner].banner-error {\n    border-color: var(--color-ansi-red);\n  }\n\n  [data-nextjs-dialog-banner]::after {\n    z-index: 2;\n    content: '';\n    position: absolute;\n    top: 0;\n    right: 0;\n    width: 100%;\n    /* banner width: */\n    border-top-width: var(--size-gap-half);\n    border-bottom-width: 0;\n    border-top-style: solid;\n    border-bottom-style: solid;\n    border-top-color: inherit;\n    border-bottom-color: transparent;\n  }\n\n  [data-nextjs-dialog-content] {\n    overflow-y: auto;\n    border: none;\n    margin: 0;\n    /* calc(padding + banner width offset) */\n    padding: calc(var(--size-gap-double) + var(--size-gap-half))\n      var(--size-gap-double);\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-header] {\n    flex-shrink: 0;\n    margin-bottom: var(--size-gap-double);\n  }\n  [data-nextjs-dialog-content] > [data-nextjs-dialog-body] {\n    position: relative;\n    flex: 1 1 auto;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var LeftRightDialogHeader = function LeftRightDialogHeader(_a) {
    var children = _a.children, className = _a.className, previous = _a.previous, next = _a.next, close = _a.close;
    var buttonLeft = React.useRef();
    var buttonRight = React.useRef();
    var buttonClose = React.useRef();
    var _b = __read(React.useState(null), 2), nav = _b[0], setNav = _b[1];
    var onNav = React.useCallback(function (el) {
        setNav(el);
    }, []);
    React.useEffect(function () {
        if (nav == null) {
            return;
        }
        var root = nav.getRootNode();
        var d = self.document;
        function handler(e) {
            if (e.key === 'ArrowLeft') {
                e.stopPropagation();
                if (buttonLeft.current) {
                    buttonLeft.current.focus();
                }
                previous && previous();
            }
            else if (e.key === 'ArrowRight') {
                e.stopPropagation();
                if (buttonRight.current) {
                    buttonRight.current.focus();
                }
                next && next();
            }
            else if (e.key === 'Escape') {
                e.stopPropagation();
                if (root instanceof ShadowRoot) {
                    var a = root.activeElement;
                    if (a && a !== buttonClose.current && a instanceof HTMLElement) {
                        a.blur();
                        return;
                    }
                }
                close();
            }
        }
        root.addEventListener('keydown', handler);
        if (root !== d) {
            d.addEventListener('keydown', handler);
        }
        return function () {
            root.removeEventListener('keydown', handler);
            if (root !== d) {
                d.removeEventListener('keydown', handler);
            }
        };
    }, [close, nav, next, previous]);
    // Unlock focus for browsers like Firefox, that break all user focus if the
    // currently focused item becomes disabled.
    React.useEffect(function () {
        if (nav == null) {
            return;
        }
        var root = nav.getRootNode();
        // Always true, but we do this for TypeScript:
        if (root instanceof ShadowRoot) {
            var a = root.activeElement;
            if (previous == null) {
                if (a === buttonLeft.current) {
                    buttonLeft.current.blur();
                }
            }
            else if (next == null) {
                if (a === buttonRight.current) {
                    buttonRight.current.blur();
                }
            }
        }
    }, [nav, next, previous]);
    return (React.createElement("div", { "data-nextjs-dialog-left-right": true, className: className },
        React.createElement("nav", { ref: onNav },
            React.createElement("button", { ref: buttonLeft, type: "button", disabled: previous == null ? true : undefined, "aria-disabled": previous == null ? true : undefined, onClick: previous !== null && previous !== void 0 ? previous : undefined },
                React.createElement("svg", { viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M6.99996 1.16666L1.16663 6.99999L6.99996 12.8333M12.8333 6.99999H1.99996H12.8333Z", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))),
            React.createElement("button", { ref: buttonRight, type: "button", disabled: next == null ? true : undefined, "aria-disabled": next == null ? true : undefined, onClick: next !== null && next !== void 0 ? next : undefined },
                React.createElement("svg", { viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M6.99996 1.16666L12.8333 6.99999L6.99996 12.8333M1.16663 6.99999H12H1.16663Z", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))),
            "\u00A0",
            children),
        React.createElement("button", { ref: buttonClose, type: "button", onClick: close, "aria-label": "Close" },
            React.createElement("span", { "aria-hidden": "true" },
                React.createElement("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                    React.createElement("path", { d: "M18 6L6 18", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }),
                    React.createElement("path", { d: "M6 6L18 18", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }))))));
};
exports.LeftRightDialogHeader = LeftRightDialogHeader;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var LeftRightDialogHeader_1 = __webpack_require__(/*! ./LeftRightDialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/LeftRightDialogHeader.js");
exports.LeftRightDialogHeader = LeftRightDialogHeader_1.LeftRightDialogHeader;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js");
exports.styles = styles_1.styles;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog-left-right] {\n    display: flex;\n    flex-direction: row;\n    align-content: center;\n    align-items: center;\n    justify-content: space-between;\n  }\n  [data-nextjs-dialog-left-right] > nav > button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n\n    width: calc(var(--size-gap-double) + var(--size-gap));\n    height: calc(var(--size-gap-double) + var(--size-gap));\n    font-size: 0;\n    border: none;\n    background-color: rgba(255, 85, 85, 0.1);\n    color: var(--color-ansi-red);\n    cursor: pointer;\n    transition: background-color 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > nav > button > svg {\n    width: auto;\n    height: calc(var(--size-gap) + var(--size-gap-half));\n  }\n  [data-nextjs-dialog-left-right] > nav > button:hover {\n    background-color: rgba(255, 85, 85, 0.2);\n  }\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\n    background-color: rgba(255, 85, 85, 0.1);\n    color: rgba(255, 85, 85, 0.4);\n    cursor: not-allowed;\n  }\n\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\n    margin-right: 1px;\n  }\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\n  }\n\n  [data-nextjs-dialog-left-right] > button:last-of-type {\n    border: 0;\n    padding: 0;\n\n    background-color: transparent;\n    appearance: none;\n\n    opacity: 0.4;\n    transition: opacity 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\n    opacity: 0.7;\n  }\n"], ["\n  [data-nextjs-dialog-left-right] {\n    display: flex;\n    flex-direction: row;\n    align-content: center;\n    align-items: center;\n    justify-content: space-between;\n  }\n  [data-nextjs-dialog-left-right] > nav > button {\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n\n    width: calc(var(--size-gap-double) + var(--size-gap));\n    height: calc(var(--size-gap-double) + var(--size-gap));\n    font-size: 0;\n    border: none;\n    background-color: rgba(255, 85, 85, 0.1);\n    color: var(--color-ansi-red);\n    cursor: pointer;\n    transition: background-color 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > nav > button > svg {\n    width: auto;\n    height: calc(var(--size-gap) + var(--size-gap-half));\n  }\n  [data-nextjs-dialog-left-right] > nav > button:hover {\n    background-color: rgba(255, 85, 85, 0.2);\n  }\n  [data-nextjs-dialog-left-right] > nav > button:disabled {\n    background-color: rgba(255, 85, 85, 0.1);\n    color: rgba(255, 85, 85, 0.4);\n    cursor: not-allowed;\n  }\n\n  [data-nextjs-dialog-left-right] > nav > button:first-of-type {\n    border-radius: var(--size-gap-half) 0 0 var(--size-gap-half);\n    margin-right: 1px;\n  }\n  [data-nextjs-dialog-left-right] > nav > button:last-of-type {\n    border-radius: 0 var(--size-gap-half) var(--size-gap-half) 0;\n  }\n\n  [data-nextjs-dialog-left-right] > button:last-of-type {\n    border: 0;\n    padding: 0;\n\n    background-color: transparent;\n    appearance: none;\n\n    opacity: 0.4;\n    transition: opacity 0.25s ease;\n  }\n  [data-nextjs-dialog-left-right] > button:last-of-type:hover {\n    opacity: 0.7;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var disabled_1 = __importDefault(__webpack_require__(/*! ally.js/maintain/disabled */ "./node_modules/ally.js/maintain/disabled.js"));
var tab_focus_1 = __importDefault(__webpack_require__(/*! ally.js/maintain/tab-focus */ "./node_modules/ally.js/maintain/tab-focus.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var body_locker_1 = __webpack_require__(/*! ./body-locker */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js");
var Overlay = function Overlay(_a) {
    var className = _a.className, children = _a.children, fixed = _a.fixed;
    React.useEffect(function () {
        body_locker_1.lock();
        return function () {
            body_locker_1.unlock();
        };
    }, []);
    var _b = __read(React.useState(null), 2), overlay = _b[0], setOverlay = _b[1];
    var onOverlay = React.useCallback(function (el) {
        setOverlay(el);
    }, []);
    React.useEffect(function () {
        if (overlay == null) {
            return;
        }
        var handle1 = disabled_1["default"]({ filter: overlay });
        var handle2 = tab_focus_1["default"]({ context: overlay });
        return function () {
            handle1.disengage();
            handle2.disengage();
        };
    }, [overlay]);
    return (React.createElement("div", { "data-nextjs-dialog-overlay": true, className: className, ref: onOverlay },
        React.createElement("div", { "data-nextjs-dialog-backdrop": true, "data-nextjs-dialog-backdrop-fixed": fixed ? true : undefined }),
        children));
};
exports.Overlay = Overlay;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/body-locker.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var previousBodyPaddingRight;
var previousBodyOverflowSetting;
var activeLocks = 0;
function lock() {
    setTimeout(function () {
        if (activeLocks++ > 0) {
            return;
        }
        var scrollBarGap = window.innerWidth - document.documentElement.clientWidth;
        if (scrollBarGap > 0) {
            previousBodyPaddingRight = document.body.style.paddingRight;
            document.body.style.paddingRight = scrollBarGap + "px";
        }
        previousBodyOverflowSetting = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
    });
}
exports.lock = lock;
function unlock() {
    setTimeout(function () {
        if (activeLocks === 0 || --activeLocks !== 0) {
            return;
        }
        if (previousBodyPaddingRight !== undefined) {
            document.body.style.paddingRight = previousBodyPaddingRight;
            previousBodyPaddingRight = undefined;
        }
        if (previousBodyOverflowSetting !== undefined) {
            document.body.style.overflow = previousBodyOverflowSetting;
            previousBodyOverflowSetting = undefined;
        }
    });
}
exports.unlock = unlock;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Overlay_1 = __webpack_require__(/*! ./Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/Overlay.js");
exports.Overlay = Overlay_1.Overlay;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-dialog-overlay] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    overflow: auto;\n    z-index: 9000;\n\n    display: flex;\n    align-content: center;\n    align-items: center;\n    flex-direction: column;\n    padding: 10vh 15px 0;\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: rgba(17, 17, 17, 0.2);\n    pointer-events: all;\n    z-index: -1;\n  }\n\n  [data-nextjs-dialog-backdrop-fixed] {\n    cursor: not-allowed;\n    -webkit-backdrop-filter: blur(8px);\n    backdrop-filter: blur(8px);\n  }\n"], ["\n  [data-nextjs-dialog-overlay] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    overflow: auto;\n    z-index: 9000;\n\n    display: flex;\n    align-content: center;\n    align-items: center;\n    flex-direction: column;\n    padding: 10vh 15px 0;\n  }\n\n  [data-nextjs-dialog-backdrop] {\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    background-color: rgba(17, 17, 17, 0.2);\n    pointer-events: all;\n    z-index: -1;\n  }\n\n  [data-nextjs-dialog-backdrop-fixed] {\n    cursor: not-allowed;\n    -webkit-backdrop-filter: blur(8px);\n    backdrop-filter: blur(8px);\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/ShadowPortal.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var react_dom_1 = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
exports.ShadowPortal = function Portal(_a) {
    var children = _a.children;
    var mountNode = React.useRef(null);
    var portalNode = React.useRef(null);
    var shadowNode = React.useRef(null);
    var _b = __read(React.useState(), 2), forceUpdate = _b[1];
    React.useLayoutEffect(function () {
        var ownerDocument = mountNode.current.ownerDocument;
        portalNode.current = ownerDocument.createElement('nextjs-portal');
        shadowNode.current = portalNode.current.attachShadow({ mode: 'open' });
        ownerDocument.body.appendChild(portalNode.current);
        forceUpdate({});
        return function () {
            if (portalNode.current && portalNode.current.ownerDocument) {
                portalNode.current.ownerDocument.body.removeChild(portalNode.current);
            }
        };
    }, []);
    return shadowNode.current ? (react_dom_1.createPortal(children, shadowNode.current)) : (React.createElement("span", { ref: mountNode }));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var anser_1 = __importDefault(__webpack_require__(/*! anser */ "./node_modules/anser/lib/index.js"));
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
exports.Terminal = function Terminal(_a) {
    var content = _a.content;
    var decoded = React.useMemo(function () {
        return anser_1["default"].ansiToJson(content, {
            json: true,
            use_classes: true,
            remove_empty: true
        });
    }, [content]);
    return (React.createElement("div", { "data-nextjs-terminal": true },
        React.createElement("pre", null, decoded.map(function (entry, index) { return (React.createElement("span", { key: "terminal-entry-" + index, style: __assign({ color: entry.fg ? "var(--color-" + entry.fg + ")" : undefined }, (entry.decoration === 'bold'
                ? { fontWeight: 800 }
                : entry.decoration === 'italic'
                    ? { fontStyle: 'italic' }
                    : undefined)) }, entry.content)); }))));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var Terminal_1 = __webpack_require__(/*! ./Terminal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/Terminal.js");
exports.Terminal = Terminal_1.Terminal;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-terminal] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-terminal]::selection,\n  [data-nextjs-terminal] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-terminal] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n  [data-nextjs-terminal] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n\n  [data-nextjs-terminal] pre {\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n"], ["\n  [data-nextjs-terminal] {\n    border-radius: var(--size-gap-half);\n    background-color: var(--color-ansi-bg);\n    color: var(--color-ansi-fg);\n  }\n  [data-nextjs-terminal]::selection,\n  [data-nextjs-terminal] *::selection {\n    background-color: var(--color-ansi-selection);\n  }\n  [data-nextjs-terminal] * {\n    color: inherit;\n    background-color: transparent;\n    font-family: var(--font-stack-monospace);\n  }\n  [data-nextjs-terminal] > * {\n    margin: 0;\n    padding: calc(var(--size-gap) + var(--size-gap-half))\n      calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n\n  [data-nextjs-terminal] pre {\n    white-space: pre-wrap;\n    word-break: break-word;\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
exports.Toast = function Toast(_a) {
    var onClick = _a.onClick, children = _a.children, className = _a.className;
    return (React.createElement("div", { "data-nextjs-toast": true, onClick: onClick, className: className },
        React.createElement("div", { "data-nextjs-toast-wrapper": true }, children)));
};


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var styles_1 = __webpack_require__(/*! ./styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js");
exports.styles = styles_1.styles;
var Toast_1 = __webpack_require__(/*! ./Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/Toast.js");
exports.Toast = Toast_1.Toast;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/styles.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
exports.__esModule = true;
var noop_template_1 = __webpack_require__(/*! ../../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  [data-nextjs-toast] {\n    position: fixed;\n    bottom: var(--size-gap-double);\n    left: var(--size-gap-double);\n    max-width: 420px;\n    z-index: 9000;\n  }\n\n  @media (max-width: 440px) {\n    [data-nextjs-toast] {\n      max-width: 90vw;\n      left: 5vw;\n    }\n  }\n\n  [data-nextjs-toast-wrapper] {\n    padding: 1rem;\n    border-radius: var(--size-gap-half);\n    font-weight: 500;\n    color: var(--color-ansi-bright-white);\n    background-color: var(--color-ansi-red);\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\n      rgba(0, 0, 0, 0.25);\n  }\n"], ["\n  [data-nextjs-toast] {\n    position: fixed;\n    bottom: var(--size-gap-double);\n    left: var(--size-gap-double);\n    max-width: 420px;\n    z-index: 9000;\n  }\n\n  @media (max-width: 440px) {\n    [data-nextjs-toast] {\n      max-width: 90vw;\n      left: 5vw;\n    }\n  }\n\n  [data-nextjs-toast-wrapper] {\n    padding: 1rem;\n    border-radius: var(--size-gap-half);\n    font-weight: 500;\n    color: var(--color-ansi-bright-white);\n    background-color: var(--color-ansi-red);\n    box-shadow: 0px var(--size-gap-double) var(--size-gap-quad)\n      rgba(0, 0, 0, 0.25);\n  }\n"])));
exports.styles = styles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var Overlay_1 = __webpack_require__(/*! ../components/Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js");
var Terminal_1 = __webpack_require__(/*! ../components/Terminal */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/index.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
exports.BuildError = function BuildError(_a) {
    var message = _a.message;
    var noop = React.useCallback(function () { }, []);
    return (React.createElement(Overlay_1.Overlay, { fixed: true },
        React.createElement(Dialog_1.Dialog, { type: "error", "aria-labelledby": "nextjs__container_build_error_label", "aria-describedby": "nextjs__container_build_error_desc", onClose: noop },
            React.createElement(Dialog_1.DialogContent, null,
                React.createElement(Dialog_1.DialogHeader, { className: "nextjs-container-build-error-header" },
                    React.createElement("h4", { id: "nextjs__container_build_error_label" }, "Failed to compile")),
                React.createElement(Dialog_1.DialogBody, { className: "nextjs-container-build-error-body" },
                    React.createElement(Terminal_1.Terminal, { content: message }),
                    React.createElement("footer", null,
                        React.createElement("p", { id: "nextjs__container_build_error_desc" },
                            React.createElement("small", null, "This error occured during the build process and can only be dismissed by fixing the error."))))))));
};
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  .nextjs-container-build-error-header > h4 {\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n  }\n\n  .nextjs-container-build-error-body footer {\n    margin-top: var(--size-gap);\n  }\n  .nextjs-container-build-error-body footer p {\n    margin: 0;\n  }\n\n  .nextjs-container-build-error-body small {\n    color: #757575;\n  }\n"], ["\n  .nextjs-container-build-error-header > h4 {\n    line-height: 1.5;\n    margin: 0;\n    padding: 0;\n  }\n\n  .nextjs-container-build-error-body footer {\n    margin-top: var(--size-gap);\n  }\n  .nextjs-container-build-error-body footer p {\n    margin: 0;\n  }\n\n  .nextjs-container-build-error-body small {\n    color: #757575;\n  }\n"])));
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var bus_1 = __webpack_require__(/*! ../bus */ "./node_modules/@next/react-dev-overlay/lib/internal/bus.js");
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var LeftRightDialogHeader_1 = __webpack_require__(/*! ../components/LeftRightDialogHeader */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/index.js");
var Overlay_1 = __webpack_require__(/*! ../components/Overlay */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/index.js");
var Toast_1 = __webpack_require__(/*! ../components/Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js");
var nodeStackFrames_1 = __webpack_require__(/*! ../helpers/nodeStackFrames */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var stack_frame_1 = __webpack_require__(/*! ../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
var RuntimeError_1 = __webpack_require__(/*! ./RuntimeError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js");
function getErrorSignature(ev) {
    var event = ev.event;
    switch (event.type) {
        case bus_1.TYPE_UNHANDLED_ERROR:
        case bus_1.TYPE_UNHANDLED_REJECTION: {
            return event.reason.name + "::" + event.reason.message + "::" + event.reason.stack;
        }
        default: {
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var _ = event;
    return '';
}
function getErrorByType(ev) {
    return __awaiter(this, void 0, void 0, function () {
        var id, event, _a, _b, _;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    id = ev.id, event = ev.event;
                    _a = event.type;
                    switch (_a) {
                        case bus_1.TYPE_UNHANDLED_ERROR: return [3 /*break*/, 1];
                        case bus_1.TYPE_UNHANDLED_REJECTION: return [3 /*break*/, 1];
                    }
                    return [3 /*break*/, 3];
                case 1:
                    _b = {
                        id: id,
                        runtime: true,
                        error: event.reason
                    };
                    return [4 /*yield*/, stack_frame_1.getOriginalStackFrames(event.frames)];
                case 2: return [2 /*return*/, (_b.frames = _c.sent(),
                        _b)];
                case 3:
                    {
                        return [3 /*break*/, 4];
                    }
                    _c.label = 4;
                case 4:
                    _ = event;
                    throw new Error('type system invariant violation');
            }
        });
    });
}
exports.Errors = function Errors(_a) {
    var errors = _a.errors;
    var _b = __read(React.useState({}), 2), lookups = _b[0], setLookups = _b[1];
    var _c = __read(React.useMemo(function () {
        var ready = [];
        var next = null;
        // Ensure errors are displayed in the order they occurred in:
        for (var idx = 0; idx < errors.length; ++idx) {
            var e = errors[idx];
            var id = e.id;
            if (id in lookups) {
                ready.push(lookups[id]);
                continue;
            }
            // Check for duplicate errors
            if (idx > 0) {
                var prev = errors[idx - 1];
                if (getErrorSignature(prev) === getErrorSignature(e)) {
                    continue;
                }
            }
            next = e;
            break;
        }
        return [ready, next];
    }, [errors, lookups]), 2), readyErrors = _c[0], nextError = _c[1];
    var isLoading = React.useMemo(function () {
        return readyErrors.length < 1 && Boolean(errors.length);
    }, [errors.length, readyErrors.length]);
    React.useEffect(function () {
        if (nextError == null) {
            return;
        }
        getErrorByType(nextError).then(function (resolved) {
            // We don't care if the desired error changed while we were resolving,
            // thus we're not tracking it using a ref. Once the work has been done,
            // we'll store it.
            setLookups(function (m) {
                var _a;
                return (__assign(__assign({}, m), (_a = {}, _a[resolved.id] = resolved, _a)));
            });
        }, function () {
            // TODO: handle this, though an edge case
        });
    }, [nextError]);
    var _d = __read(React.useState(false), 2), isMinimized = _d[0], setMinimized = _d[1];
    var _e = __read(React.useState(0), 2), activeIdx = _e[0], setActiveIndex = _e[1];
    var previous = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setActiveIndex(function (v) { return Math.max(0, v - 1); });
    }, []);
    var next = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setActiveIndex(function (v) { return Math.max(0, Math.min(readyErrors.length - 1, v + 1)); });
    }, [readyErrors.length]);
    var activeError = React.useMemo(function () { var _a; return (_a = readyErrors[activeIdx]) !== null && _a !== void 0 ? _a : null; }, [activeIdx, readyErrors]);
    // Reset component state when there are no errors to be displayed.
    // This should never happen, but lets handle it.
    React.useEffect(function () {
        if (errors.length < 1) {
            setLookups({});
            setMinimized(false);
            setActiveIndex(0);
        }
    }, [errors.length]);
    var minimize = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setMinimized(true);
    }, []);
    var reopen = React.useCallback(function (e) {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        setMinimized(false);
    }, []);
    // This component shouldn't be rendered with no errors, but if it is, let's
    // handle it gracefully by rendering nothing.
    if (errors.length < 1) {
        return null;
    }
    if (isLoading) {
        // TODO: better loading state
        return React.createElement(Overlay_1.Overlay, null);
    }
    if (isMinimized) {
        return (React.createElement(Toast_1.Toast, { className: "nextjs-toast-errors-parent", onClick: reopen },
            React.createElement("div", { className: "nextjs-toast-errors" },
                React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                    React.createElement("circle", { cx: "12", cy: "12", r: "10" }),
                    React.createElement("line", { x1: "12", y1: "8", x2: "12", y2: "12" }),
                    React.createElement("line", { x1: "12", y1: "16", x2: "12.01", y2: "16" })),
                React.createElement("span", null,
                    readyErrors.length,
                    " error",
                    readyErrors.length > 1 ? 's' : ''))));
    }
    var isServerError = nodeStackFrames_1.isNodeError(activeError.error);
    return (React.createElement(Overlay_1.Overlay, null,
        React.createElement(Dialog_1.Dialog, { type: "error", "aria-labelledby": "nextjs__container_errors_label", "aria-describedby": "nextjs__container_errors_desc", onClose: minimize },
            React.createElement(Dialog_1.DialogContent, null,
                React.createElement(Dialog_1.DialogHeader, { className: "nextjs-container-errors-header" },
                    React.createElement(LeftRightDialogHeader_1.LeftRightDialogHeader, { previous: activeIdx > 0 ? previous : null, next: activeIdx < readyErrors.length - 1 ? next : null, close: minimize },
                        React.createElement("small", null,
                            React.createElement("span", null, activeIdx + 1),
                            " of",
                            ' ',
                            React.createElement("span", null, readyErrors.length),
                            " unhandled error",
                            readyErrors.length < 2 ? '' : 's')),
                    React.createElement("h1", { id: "nextjs__container_errors_label" }, isServerError ? 'Server Error' : 'Unhandled Runtime Error'),
                    React.createElement("p", { id: "nextjs__container_errors_desc" },
                        activeError.error.name,
                        ": ",
                        activeError.error.message),
                    isServerError ? (React.createElement("div", null,
                        React.createElement("small", null, "This error happened while generating the page. Any console logs will be displayed in the terminal window."))) : (undefined)),
                React.createElement(Dialog_1.DialogBody, { className: "nextjs-container-errors-body" },
                    React.createElement(RuntimeError_1.RuntimeError, { key: activeError.id.toString(), error: activeError }))))));
};
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  .nextjs-container-errors-header > h1 {\n    font-size: var(--size-font-big);\n    line-height: var(--size-font-bigger);\n    font-weight: bold;\n    margin: 0;\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  .nextjs-container-errors-header small {\n    font-size: var(--size-font-small);\n    color: var(--color-accents-1);\n    margin-left: var(--size-gap-double);\n  }\n  .nextjs-container-errors-header small > span {\n    font-family: var(--font-stack-monospace);\n  }\n  .nextjs-container-errors-header > p {\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-big);\n    font-weight: bold;\n    margin: 0;\n    margin-top: var(--size-gap-half);\n    color: var(--color-ansi-red);\n    white-space: pre-wrap;\n  }\n  .nextjs-container-errors-header > div > small {\n    margin: 0;\n    margin-top: var(--size-gap-half);\n  }\n\n  .nextjs-container-errors-body > h5:not(:first-child) {\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\n  }\n  .nextjs-container-errors-body > h5 {\n    margin-bottom: var(--size-gap);\n  }\n\n  .nextjs-toast-errors-parent {\n    cursor: pointer;\n    transition: transform 0.2s ease;\n  }\n  .nextjs-toast-errors-parent:hover {\n    transform: scale(1.1);\n  }\n  .nextjs-toast-errors {\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n  .nextjs-toast-errors > svg {\n    margin-right: var(--size-gap);\n  }\n"], ["\n  .nextjs-container-errors-header > h1 {\n    font-size: var(--size-font-big);\n    line-height: var(--size-font-bigger);\n    font-weight: bold;\n    margin: 0;\n    margin-top: calc(var(--size-gap-double) + var(--size-gap-half));\n  }\n  .nextjs-container-errors-header small {\n    font-size: var(--size-font-small);\n    color: var(--color-accents-1);\n    margin-left: var(--size-gap-double);\n  }\n  .nextjs-container-errors-header small > span {\n    font-family: var(--font-stack-monospace);\n  }\n  .nextjs-container-errors-header > p {\n    font-family: var(--font-stack-monospace);\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-big);\n    font-weight: bold;\n    margin: 0;\n    margin-top: var(--size-gap-half);\n    color: var(--color-ansi-red);\n    white-space: pre-wrap;\n  }\n  .nextjs-container-errors-header > div > small {\n    margin: 0;\n    margin-top: var(--size-gap-half);\n  }\n\n  .nextjs-container-errors-body > h5:not(:first-child) {\n    margin-top: calc(var(--size-gap-double) + var(--size-gap));\n  }\n  .nextjs-container-errors-body > h5 {\n    margin-bottom: var(--size-gap);\n  }\n\n  .nextjs-toast-errors-parent {\n    cursor: pointer;\n    transition: transform 0.2s ease;\n  }\n  .nextjs-toast-errors-parent:hover {\n    transform: scale(1.1);\n  }\n  .nextjs-toast-errors {\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n  .nextjs-toast-errors > svg {\n    margin-right: var(--size-gap);\n  }\n"])));
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var CodeFrame_1 = __webpack_require__(/*! ../components/CodeFrame */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/index.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
var stack_frame_1 = __webpack_require__(/*! ../helpers/stack-frame */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js");
var CallStackFrame = function CallStackFrame(_a) {
    // TODO: ability to expand resolved frames
    // TODO: render error or external indicator
    var frame = _a.frame;
    var _b;
    var f = (_b = frame.originalStackFrame) !== null && _b !== void 0 ? _b : frame.sourceStackFrame;
    var hasSource = Boolean(frame.originalCodeFrame);
    var open = React.useCallback(function () {
        var _a;
        if (!hasSource)
            return;
        var params = new URLSearchParams();
        for (var key in f) {
            params.append(key, ((_a = f[key]) !== null && _a !== void 0 ? _a : '').toString());
        }
        self.fetch("/__nextjs_launch-editor?" + params.toString()).then(function () { }, function () {
            // TODO: report error
        });
    }, [hasSource, f]);
    return (React.createElement("div", { "data-nextjs-call-stack-frame": true },
        React.createElement("h6", { "data-nextjs-frame-expanded": Boolean(frame.expanded) }, f.methodName),
        React.createElement("div", { "data-has-source": hasSource ? 'true' : undefined, tabIndex: hasSource ? 10 : undefined, role: hasSource ? 'link' : undefined, onClick: open, title: hasSource ? 'Click to open in your editor' : undefined },
            React.createElement("span", null, stack_frame_1.getFrameSource(f)),
            React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" },
                React.createElement("path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" }),
                React.createElement("polyline", { points: "15 3 21 3 21 9" }),
                React.createElement("line", { x1: "10", y1: "14", x2: "21", y2: "3" })))));
};
var RuntimeError = function RuntimeError(_a) {
    var error = _a.error;
    var firstFirstPartyFrameIndex = React.useMemo(function () {
        return error.frames.findIndex(function (entry) {
            return entry.expanded &&
                Boolean(entry.originalCodeFrame) &&
                Boolean(entry.originalStackFrame);
        });
    }, [error.frames]);
    var firstFrame = React.useMemo(function () {
        var _a;
        return (_a = error.frames[firstFirstPartyFrameIndex]) !== null && _a !== void 0 ? _a : null;
    }, [error.frames, firstFirstPartyFrameIndex]);
    var allLeadingFrames = React.useMemo(function () {
        return firstFirstPartyFrameIndex < 0
            ? []
            : error.frames.slice(0, firstFirstPartyFrameIndex);
    }, [error.frames, firstFirstPartyFrameIndex]);
    var _b = __read(React.useState(firstFrame == null), 2), all = _b[0], setAll = _b[1];
    var toggleAll = React.useCallback(function () {
        setAll(function (v) { return !v; });
    }, []);
    var leadingFrames = React.useMemo(function () { return allLeadingFrames.filter(function (f) { return f.expanded || all; }); }, [all, allLeadingFrames]);
    var allCallStackFrames = React.useMemo(function () { return error.frames.slice(firstFirstPartyFrameIndex + 1); }, [error.frames, firstFirstPartyFrameIndex]);
    var visibleCallStackFrames = React.useMemo(function () { return allCallStackFrames.filter(function (f) { return f.expanded || all; }); }, [all, allCallStackFrames]);
    var canShowMore = React.useMemo(function () {
        return (allCallStackFrames.length !== visibleCallStackFrames.length ||
            (all && firstFrame != null));
    }, [
        all,
        allCallStackFrames.length,
        firstFrame,
        visibleCallStackFrames.length,
    ]);
    return (React.createElement(React.Fragment, null,
        firstFrame ? (React.createElement(React.Fragment, null,
            React.createElement("h5", null, "Source"),
            leadingFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: "leading-frame-" + index + "-" + all, frame: frame })); }),
            React.createElement(CodeFrame_1.CodeFrame, { stackFrame: firstFrame.originalStackFrame, codeFrame: firstFrame.originalCodeFrame }))) : (undefined),
        visibleCallStackFrames.length ? (React.createElement(React.Fragment, null,
            React.createElement("h5", null, "Call Stack"),
            visibleCallStackFrames.map(function (frame, index) { return (React.createElement(CallStackFrame, { key: "call-stack-" + index + "-" + all, frame: frame })); }))) : (undefined),
        canShowMore ? (React.createElement(React.Fragment, null,
            React.createElement("button", { tabIndex: 10, "data-nextjs-data-runtime-error-collapsed-action": true, type: "button", onClick: toggleAll },
                all ? 'Hide' : 'Show',
                " collapsed frames"))) : (undefined)));
};
exports.RuntimeError = RuntimeError;
exports.styles = noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n  button[data-nextjs-data-runtime-error-collapsed-action] {\n    background: none;\n    border: none;\n    padding: 0;\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-bigger);\n    color: var(--color-accents-3);\n  }\n\n  [data-nextjs-call-stack-frame]:not(:last-child) {\n    margin-bottom: var(--size-gap-double);\n  }\n\n  [data-nextjs-call-stack-frame] > h6 {\n    margin-top: 0;\n    margin-bottom: var(--size-gap);\n    font-family: var(--font-stack-monospace);\n    color: #222;\n  }\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\n    color: #666;\n  }\n  [data-nextjs-call-stack-frame] > div {\n    display: flex;\n    align-items: center;\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\n    font-size: var(--size-font-small);\n    color: #999;\n  }\n  [data-nextjs-call-stack-frame] > div > svg {\n    width: auto;\n    height: var(--size-font-small);\n    margin-left: var(--size-gap);\n\n    display: none;\n  }\n\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\n    cursor: pointer;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\n    display: unset;\n  }\n"], ["\n  button[data-nextjs-data-runtime-error-collapsed-action] {\n    background: none;\n    border: none;\n    padding: 0;\n    font-size: var(--size-font-small);\n    line-height: var(--size-font-bigger);\n    color: var(--color-accents-3);\n  }\n\n  [data-nextjs-call-stack-frame]:not(:last-child) {\n    margin-bottom: var(--size-gap-double);\n  }\n\n  [data-nextjs-call-stack-frame] > h6 {\n    margin-top: 0;\n    margin-bottom: var(--size-gap);\n    font-family: var(--font-stack-monospace);\n    color: #222;\n  }\n  [data-nextjs-call-stack-frame] > h6[data-nextjs-frame-expanded='false'] {\n    color: #666;\n  }\n  [data-nextjs-call-stack-frame] > div {\n    display: flex;\n    align-items: center;\n    padding-left: calc(var(--size-gap) + var(--size-gap-half));\n    font-size: var(--size-font-small);\n    color: #999;\n  }\n  [data-nextjs-call-stack-frame] > div > svg {\n    width: auto;\n    height: var(--size-font-small);\n    margin-left: var(--size-gap);\n\n    display: none;\n  }\n\n  [data-nextjs-call-stack-frame] > div[data-has-source] {\n    cursor: pointer;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source]:hover {\n    text-decoration: underline dotted;\n  }\n  [data-nextjs-call-stack-frame] > div[data-has-source] > svg {\n    display: unset;\n  }\n"])));
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/nodeStackFrames.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var stacktrace_parser_1 = __webpack_require__(/*! stacktrace-parser */ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js");
function getFilesystemFrame(frame) {
    var f = __assign({}, frame);
    if (typeof f.file === 'string') {
        if (
        // Posix:
        f.file.startsWith('/') ||
            // Win32:
            /^[a-z]:\\/i.test(f.file) ||
            // Win32 UNC:
            f.file.startsWith('\\\\')) {
            f.file = "file://" + f.file;
        }
    }
    return f;
}
exports.getFilesystemFrame = getFilesystemFrame;
var symbolNodeError = Symbol('NextjsNodeError');
function isNodeError(error) {
    return symbolNodeError in error;
}
exports.isNodeError = isNodeError;
function getNodeError(error) {
    var n;
    try {
        throw new Error(error.message);
    }
    catch (e) {
        n = e;
    }
    n.name = error.name;
    try {
        n.stack = stacktrace_parser_1.parse(error.stack)
            .map(getFilesystemFrame)
            .map(function (f) {
            var str = "    at " + f.methodName;
            if (f.file) {
                var loc = f.file;
                if (f.lineNumber) {
                    loc += ":" + f.lineNumber;
                    if (f.column) {
                        loc += ":" + f.column;
                    }
                }
                str += " (" + loc + ")";
            }
            return str;
        })
            .join('\n');
    }
    catch (_a) {
        n.stack = error.stack;
    }
    Object.defineProperty(n, symbolNodeError, {
        writable: false,
        enumerable: false,
        configurable: false
    });
    return n;
}
exports.getNodeError = getNodeError;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
function noop(strings) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    var lastIndex = strings.length - 1;
    return (strings.slice(0, lastIndex).reduce(function (p, s, i) { return p + s + keys[i]; }, '') +
        strings[lastIndex]);
}
exports.noop = noop;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/parseStack.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var stacktrace_parser_1 = __webpack_require__(/*! stacktrace-parser */ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js");
var regexNextStatic = /\/_next(\/static\/.+)/g;
function parseStack(stack) {
    var frames = stacktrace_parser_1.parse(stack);
    return frames.map(function (frame) {
        var _a, _b;
        try {
            var url = new URL(frame.file);
            var res = regexNextStatic.exec(url.pathname);
            if (res) {
                var distDir = (_b = (_a = "D:\\Pank\\code\\Pack\\nextjs-blog\\.next") === null || _a === void 0 ? void 0 : _a.replace(/\\/g, '/')) === null || _b === void 0 ? void 0 : _b.replace(/\/$/, '');
                if (distDir) {
                    frame.file = 'file://' + distDir.concat(res.pop());
                }
            }
        }
        catch (_c) { }
        return frame;
    });
}
exports.parseStack = parseStack;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/helpers/stack-frame.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
exports.__esModule = true;
function getOriginalStackFrames(frames) {
    return Promise.all(frames.map(function (frame) { return getOriginalStackFrame(frame); }));
}
exports.getOriginalStackFrames = getOriginalStackFrames;
function getOriginalStackFrame(source) {
    var _a, _b;
    function _getOriginalStackFrame() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var params, key, controller, tm, res, _c, _d, _e, body;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        params = new URLSearchParams();
                        for (key in source) {
                            params.append(key, ((_a = source[key]) !== null && _a !== void 0 ? _a : '').toString());
                        }
                        controller = new AbortController();
                        tm = setTimeout(function () { return controller.abort(); }, 3000);
                        return [4 /*yield*/, self
                                .fetch("/__nextjs_original-stack-frame?" + params.toString(), {
                                signal: controller.signal
                            })["finally"](function () {
                                clearTimeout(tm);
                            })];
                    case 1:
                        res = _f.sent();
                        if (!(!res.ok || res.status === 204)) return [3 /*break*/, 3];
                        _d = (_c = Promise).reject;
                        _e = Error.bind;
                        return [4 /*yield*/, res.text()];
                    case 2: return [2 /*return*/, _d.apply(_c, [new (_e.apply(Error, [void 0, _f.sent()]))()])];
                    case 3: return [4 /*yield*/, res.json()];
                    case 4:
                        body = _f.sent();
                        return [2 /*return*/, {
                                error: false,
                                reason: null,
                                external: false,
                                expanded: ((_b = body.originalStackFrame) === null || _b === void 0 ? void 0 : _b.file) &&
                                    !body.originalStackFrame.file.includes('node_modules'),
                                sourceStackFrame: source,
                                originalStackFrame: body.originalStackFrame,
                                originalCodeFrame: body.originalCodeFrame || null
                            }];
                }
            });
        });
    }
    if (!(((_a = source.file) === null || _a === void 0 ? void 0 : _a.startsWith('webpack-internal:')) || ((_b = source.file) === null || _b === void 0 ? void 0 : _b.startsWith('file:')))) {
        return Promise.resolve({
            error: false,
            reason: null,
            external: true,
            expanded: false,
            sourceStackFrame: source,
            originalStackFrame: null,
            originalCodeFrame: null
        });
    }
    return _getOriginalStackFrame()["catch"](function (err) {
        var _a, _b;
        return ({
            error: true,
            reason: (_b = (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : err === null || err === void 0 ? void 0 : err.toString()) !== null && _b !== void 0 ? _b : 'Unknown Error',
            external: false,
            expanded: false,
            sourceStackFrame: source,
            originalStackFrame: null,
            originalCodeFrame: null
        });
    });
}
exports.getOriginalStackFrame = getOriginalStackFrame;
function getFrameSource(frame) {
    var _a;
    var str = '';
    try {
        var u = new URL(frame.file);
        // Strip the origin for same-origin scripts.
        if (typeof globalThis !== 'undefined' &&
            ((_a = globalThis.location) === null || _a === void 0 ? void 0 : _a.origin) !== u.origin) {
            // URLs can be valid without an `origin`, so long as they have a
            // `protocol`. However, `origin` is preferred.
            if (u.origin === 'null') {
                str += u.protocol;
            }
            else {
                str += u.origin;
            }
        }
        // Strip query string information as it's typically too verbose to be
        // meaningful.
        str += u.pathname;
        str += ' ';
    }
    catch (_b) {
        str += (frame.file || '(unknown)') + ' ';
    }
    if (frame.lineNumber != null) {
        if (frame.column != null) {
            str += "(" + frame.lineNumber + ":" + frame.column + ") ";
        }
        else {
            str += "(" + frame.lineNumber + ") ";
        }
    }
    return str.slice(0, -1);
}
exports.getFrameSource = getFrameSource;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/hooks/use-on-click-outside.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
function useOnClickOutside(el, handler) {
    React.useEffect(function () {
        if (el == null) {
            return;
        }
        var listener = function (e) {
            // Do nothing if clicking ref's element or descendent elements
            if (!el || el.contains(e.target)) {
                return;
            }
            handler(e);
        };
        var root = el.getRootNode();
        root.addEventListener('mousedown', listener);
        root.addEventListener('touchstart', listener);
        return function () {
            root.removeEventListener('mousedown', listener);
            root.removeEventListener('touchstart', listener);
        };
    }, [handler, el]);
}
exports.useOnClickOutside = useOnClickOutside;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/Base.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function Base() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          :host {\n            --size-gap-half: 0.25rem; /* 4px */\n            --size-gap: 0.5rem; /* 8px */\n            --size-gap-double: 1rem; /* 16px */\n            --size-gap-quad: 2rem; /* 32px */\n\n            --size-font-small: 0.875rem; /* 14px */\n            --size-font: 1rem; /* 16px */\n            --size-font-big: 1.25rem; /* 20px */\n            --size-font-bigger: 1.5rem; /* 24px */\n\n            --color-accents-1: #808080;\n            --color-accents-2: #222222;\n            --color-accents-3: #404040;\n\n            --font-stack-monospace: 'SFMono-Regular', Consolas,\n              'Liberation Mono', Menlo, Courier, monospace;\n\n            --color-ansi-selection: rgba(95, 126, 151, 0.48);\n            --color-ansi-bg: #111111;\n            --color-ansi-fg: #cccccc;\n\n            --color-ansi-white: #777777;\n            --color-ansi-black: #141414;\n            --color-ansi-blue: #00aaff;\n            --color-ansi-cyan: #88ddff;\n            --color-ansi-green: #98ec65;\n            --color-ansi-magenta: #aa88ff;\n            --color-ansi-red: #ff5555;\n            --color-ansi-yellow: #ffcc33;\n            --color-ansi-bright-white: #ffffff;\n            --color-ansi-bright-black: #777777;\n            --color-ansi-bright-blue: #33bbff;\n            --color-ansi-bright-cyan: #bbecff;\n            --color-ansi-bright-green: #b6f292;\n            --color-ansi-bright-magenta: #cebbff;\n            --color-ansi-bright-red: #ff8888;\n            --color-ansi-bright-yellow: #ffd966;\n          }\n\n          .mono {\n            font-family: var(--font-stack-monospace);\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-bottom: var(--size-gap);\n            font-weight: 500;\n            line-height: 1.5;\n          }\n\n          h1 {\n            font-size: 2.5rem;\n          }\n          h2 {\n            font-size: 2rem;\n          }\n          h3 {\n            font-size: 1.75rem;\n          }\n          h4 {\n            font-size: 1.5rem;\n          }\n          h5 {\n            font-size: 1.25rem;\n          }\n          h6 {\n            font-size: 1rem;\n          }\n        "], ["\n          :host {\n            --size-gap-half: 0.25rem; /* 4px */\n            --size-gap: 0.5rem; /* 8px */\n            --size-gap-double: 1rem; /* 16px */\n            --size-gap-quad: 2rem; /* 32px */\n\n            --size-font-small: 0.875rem; /* 14px */\n            --size-font: 1rem; /* 16px */\n            --size-font-big: 1.25rem; /* 20px */\n            --size-font-bigger: 1.5rem; /* 24px */\n\n            --color-accents-1: #808080;\n            --color-accents-2: #222222;\n            --color-accents-3: #404040;\n\n            --font-stack-monospace: 'SFMono-Regular', Consolas,\n              'Liberation Mono', Menlo, Courier, monospace;\n\n            --color-ansi-selection: rgba(95, 126, 151, 0.48);\n            --color-ansi-bg: #111111;\n            --color-ansi-fg: #cccccc;\n\n            --color-ansi-white: #777777;\n            --color-ansi-black: #141414;\n            --color-ansi-blue: #00aaff;\n            --color-ansi-cyan: #88ddff;\n            --color-ansi-green: #98ec65;\n            --color-ansi-magenta: #aa88ff;\n            --color-ansi-red: #ff5555;\n            --color-ansi-yellow: #ffcc33;\n            --color-ansi-bright-white: #ffffff;\n            --color-ansi-bright-black: #777777;\n            --color-ansi-bright-blue: #33bbff;\n            --color-ansi-bright-cyan: #bbecff;\n            --color-ansi-bright-green: #b6f292;\n            --color-ansi-bright-magenta: #cebbff;\n            --color-ansi-bright-red: #ff8888;\n            --color-ansi-bright-yellow: #ffd966;\n          }\n\n          .mono {\n            font-family: var(--font-stack-monospace);\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-bottom: var(--size-gap);\n            font-weight: 500;\n            line-height: 1.5;\n          }\n\n          h1 {\n            font-size: 2.5rem;\n          }\n          h2 {\n            font-size: 2rem;\n          }\n          h3 {\n            font-size: 1.75rem;\n          }\n          h4 {\n            font-size: 1.5rem;\n          }\n          h5 {\n            font-size: 1.25rem;\n          }\n          h6 {\n            font-size: 1rem;\n          }\n        "])))
        } }));
}
exports.Base = Base;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/ComponentStyles.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var styles_1 = __webpack_require__(/*! ../components/CodeFrame/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/CodeFrame/styles.js");
var Dialog_1 = __webpack_require__(/*! ../components/Dialog */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Dialog/index.js");
var styles_2 = __webpack_require__(/*! ../components/LeftRightDialogHeader/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/LeftRightDialogHeader/styles.js");
var styles_3 = __webpack_require__(/*! ../components/Overlay/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Overlay/styles.js");
var styles_4 = __webpack_require__(/*! ../components/Terminal/styles */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Terminal/styles.js");
var Toast_1 = __webpack_require__(/*! ../components/Toast */ "./node_modules/@next/react-dev-overlay/lib/internal/components/Toast/index.js");
var BuildError_1 = __webpack_require__(/*! ../container/BuildError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/BuildError.js");
var Errors_1 = __webpack_require__(/*! ../container/Errors */ "./node_modules/@next/react-dev-overlay/lib/internal/container/Errors.js");
var RuntimeError_1 = __webpack_require__(/*! ../container/RuntimeError */ "./node_modules/@next/react-dev-overlay/lib/internal/container/RuntimeError.js");
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function ComponentStyles() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n\n          ", "\n          ", "\n          ", "\n        "], ["\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n          ", "\n\n          ", "\n          ", "\n          ", "\n        "])), styles_3.styles, Toast_1.styles, Dialog_1.styles, styles_2.styles, styles_1.styles, styles_4.styles, BuildError_1.styles, Errors_1.styles, RuntimeError_1.styles)
        } }));
}
exports.ComponentStyles = ComponentStyles;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/lib/internal/styles/CssReset.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
var noop_template_1 = __webpack_require__(/*! ../helpers/noop-template */ "./node_modules/@next/react-dev-overlay/lib/internal/helpers/noop-template.js");
function CssReset() {
    return (React.createElement("style", { dangerouslySetInnerHTML: {
            __html: noop_template_1.noop(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n          :host {\n            all: initial;\n          }\n\n          /*!\n           * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n           * Copyright 2011-2019 The Bootstrap Authors\n           * Copyright 2011-2019 Twitter, Inc.\n           * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n           * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n           */\n          *,\n          *::before,\n          *::after {\n            box-sizing: border-box;\n          }\n\n          :host {\n            font-family: sans-serif;\n            line-height: 1.15;\n            -webkit-text-size-adjust: 100%;\n            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n          }\n\n          article,\n          aside,\n          figcaption,\n          figure,\n          footer,\n          header,\n          hgroup,\n          main,\n          nav,\n          section {\n            display: block;\n          }\n\n          :host {\n            margin: 0;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n              'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n              'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n              'Noto Color Emoji';\n            font-size: 1rem;\n            font-weight: 400;\n            line-height: 1.5;\n            color: #212529;\n            text-align: left;\n            background-color: #fff;\n          }\n\n          [tabindex='-1']:focus:not(:focus-visible) {\n            outline: 0 !important;\n          }\n\n          hr {\n            box-sizing: content-box;\n            height: 0;\n            overflow: visible;\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-top: 0;\n            margin-bottom: 0.5rem;\n          }\n\n          p {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          abbr[title],\n          abbr[data-original-title] {\n            text-decoration: underline;\n            -webkit-text-decoration: underline dotted;\n            text-decoration: underline dotted;\n            cursor: help;\n            border-bottom: 0;\n            -webkit-text-decoration-skip-ink: none;\n            text-decoration-skip-ink: none;\n          }\n\n          address {\n            margin-bottom: 1rem;\n            font-style: normal;\n            line-height: inherit;\n          }\n\n          ol,\n          ul,\n          dl {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          ol ol,\n          ul ul,\n          ol ul,\n          ul ol {\n            margin-bottom: 0;\n          }\n\n          dt {\n            font-weight: 700;\n          }\n\n          dd {\n            margin-bottom: 0.5rem;\n            margin-left: 0;\n          }\n\n          blockquote {\n            margin: 0 0 1rem;\n          }\n\n          b,\n          strong {\n            font-weight: bolder;\n          }\n\n          small {\n            font-size: 80%;\n          }\n\n          sub,\n          sup {\n            position: relative;\n            font-size: 75%;\n            line-height: 0;\n            vertical-align: baseline;\n          }\n\n          sub {\n            bottom: -0.25em;\n          }\n\n          sup {\n            top: -0.5em;\n          }\n\n          a {\n            color: #007bff;\n            text-decoration: none;\n            background-color: transparent;\n          }\n\n          a:hover {\n            color: #0056b3;\n            text-decoration: underline;\n          }\n\n          a:not([href]) {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          a:not([href]):hover {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          pre,\n          code,\n          kbd,\n          samp {\n            font-family: SFMono-Regular, Menlo, Monaco, Consolas,\n              'Liberation Mono', 'Courier New', monospace;\n            font-size: 1em;\n          }\n\n          pre {\n            margin-top: 0;\n            margin-bottom: 1rem;\n            overflow: auto;\n          }\n\n          figure {\n            margin: 0 0 1rem;\n          }\n\n          img {\n            vertical-align: middle;\n            border-style: none;\n          }\n\n          svg {\n            overflow: hidden;\n            vertical-align: middle;\n          }\n\n          table {\n            border-collapse: collapse;\n          }\n\n          caption {\n            padding-top: 0.75rem;\n            padding-bottom: 0.75rem;\n            color: #6c757d;\n            text-align: left;\n            caption-side: bottom;\n          }\n\n          th {\n            text-align: inherit;\n          }\n\n          label {\n            display: inline-block;\n            margin-bottom: 0.5rem;\n          }\n\n          button {\n            border-radius: 0;\n          }\n\n          button:focus {\n            outline: 1px dotted;\n            outline: 5px auto -webkit-focus-ring-color;\n          }\n\n          input,\n          button,\n          select,\n          optgroup,\n          textarea {\n            margin: 0;\n            font-family: inherit;\n            font-size: inherit;\n            line-height: inherit;\n          }\n\n          button,\n          input {\n            overflow: visible;\n          }\n\n          button,\n          select {\n            text-transform: none;\n          }\n\n          select {\n            word-wrap: normal;\n          }\n\n          button,\n          [type='button'],\n          [type='reset'],\n          [type='submit'] {\n            -webkit-appearance: button;\n          }\n\n          button:not(:disabled),\n          [type='button']:not(:disabled),\n          [type='reset']:not(:disabled),\n          [type='submit']:not(:disabled) {\n            cursor: pointer;\n          }\n\n          button::-moz-focus-inner,\n          [type='button']::-moz-focus-inner,\n          [type='reset']::-moz-focus-inner,\n          [type='submit']::-moz-focus-inner {\n            padding: 0;\n            border-style: none;\n          }\n\n          input[type='radio'],\n          input[type='checkbox'] {\n            box-sizing: border-box;\n            padding: 0;\n          }\n\n          input[type='date'],\n          input[type='time'],\n          input[type='datetime-local'],\n          input[type='month'] {\n            -webkit-appearance: listbox;\n          }\n\n          textarea {\n            overflow: auto;\n            resize: vertical;\n          }\n\n          fieldset {\n            min-width: 0;\n            padding: 0;\n            margin: 0;\n            border: 0;\n          }\n\n          legend {\n            display: block;\n            width: 100%;\n            max-width: 100%;\n            padding: 0;\n            margin-bottom: 0.5rem;\n            font-size: 1.5rem;\n            line-height: inherit;\n            color: inherit;\n            white-space: normal;\n          }\n\n          progress {\n            vertical-align: baseline;\n          }\n\n          [type='number']::-webkit-inner-spin-button,\n          [type='number']::-webkit-outer-spin-button {\n            height: auto;\n          }\n\n          [type='search'] {\n            outline-offset: -2px;\n            -webkit-appearance: none;\n          }\n\n          [type='search']::-webkit-search-decoration {\n            -webkit-appearance: none;\n          }\n\n          ::-webkit-file-upload-button {\n            font: inherit;\n            -webkit-appearance: button;\n          }\n\n          output {\n            display: inline-block;\n          }\n\n          summary {\n            display: list-item;\n            cursor: pointer;\n          }\n\n          template {\n            display: none;\n          }\n\n          [hidden] {\n            display: none !important;\n          }\n        "], ["\n          :host {\n            all: initial;\n          }\n\n          /*!\n           * Bootstrap Reboot v4.4.1 (https://getbootstrap.com/)\n           * Copyright 2011-2019 The Bootstrap Authors\n           * Copyright 2011-2019 Twitter, Inc.\n           * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n           * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md)\n           */\n          *,\n          *::before,\n          *::after {\n            box-sizing: border-box;\n          }\n\n          :host {\n            font-family: sans-serif;\n            line-height: 1.15;\n            -webkit-text-size-adjust: 100%;\n            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n          }\n\n          article,\n          aside,\n          figcaption,\n          figure,\n          footer,\n          header,\n          hgroup,\n          main,\n          nav,\n          section {\n            display: block;\n          }\n\n          :host {\n            margin: 0;\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,\n              'Helvetica Neue', Arial, 'Noto Sans', sans-serif,\n              'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n              'Noto Color Emoji';\n            font-size: 1rem;\n            font-weight: 400;\n            line-height: 1.5;\n            color: #212529;\n            text-align: left;\n            background-color: #fff;\n          }\n\n          [tabindex='-1']:focus:not(:focus-visible) {\n            outline: 0 !important;\n          }\n\n          hr {\n            box-sizing: content-box;\n            height: 0;\n            overflow: visible;\n          }\n\n          h1,\n          h2,\n          h3,\n          h4,\n          h5,\n          h6 {\n            margin-top: 0;\n            margin-bottom: 0.5rem;\n          }\n\n          p {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          abbr[title],\n          abbr[data-original-title] {\n            text-decoration: underline;\n            -webkit-text-decoration: underline dotted;\n            text-decoration: underline dotted;\n            cursor: help;\n            border-bottom: 0;\n            -webkit-text-decoration-skip-ink: none;\n            text-decoration-skip-ink: none;\n          }\n\n          address {\n            margin-bottom: 1rem;\n            font-style: normal;\n            line-height: inherit;\n          }\n\n          ol,\n          ul,\n          dl {\n            margin-top: 0;\n            margin-bottom: 1rem;\n          }\n\n          ol ol,\n          ul ul,\n          ol ul,\n          ul ol {\n            margin-bottom: 0;\n          }\n\n          dt {\n            font-weight: 700;\n          }\n\n          dd {\n            margin-bottom: 0.5rem;\n            margin-left: 0;\n          }\n\n          blockquote {\n            margin: 0 0 1rem;\n          }\n\n          b,\n          strong {\n            font-weight: bolder;\n          }\n\n          small {\n            font-size: 80%;\n          }\n\n          sub,\n          sup {\n            position: relative;\n            font-size: 75%;\n            line-height: 0;\n            vertical-align: baseline;\n          }\n\n          sub {\n            bottom: -0.25em;\n          }\n\n          sup {\n            top: -0.5em;\n          }\n\n          a {\n            color: #007bff;\n            text-decoration: none;\n            background-color: transparent;\n          }\n\n          a:hover {\n            color: #0056b3;\n            text-decoration: underline;\n          }\n\n          a:not([href]) {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          a:not([href]):hover {\n            color: inherit;\n            text-decoration: none;\n          }\n\n          pre,\n          code,\n          kbd,\n          samp {\n            font-family: SFMono-Regular, Menlo, Monaco, Consolas,\n              'Liberation Mono', 'Courier New', monospace;\n            font-size: 1em;\n          }\n\n          pre {\n            margin-top: 0;\n            margin-bottom: 1rem;\n            overflow: auto;\n          }\n\n          figure {\n            margin: 0 0 1rem;\n          }\n\n          img {\n            vertical-align: middle;\n            border-style: none;\n          }\n\n          svg {\n            overflow: hidden;\n            vertical-align: middle;\n          }\n\n          table {\n            border-collapse: collapse;\n          }\n\n          caption {\n            padding-top: 0.75rem;\n            padding-bottom: 0.75rem;\n            color: #6c757d;\n            text-align: left;\n            caption-side: bottom;\n          }\n\n          th {\n            text-align: inherit;\n          }\n\n          label {\n            display: inline-block;\n            margin-bottom: 0.5rem;\n          }\n\n          button {\n            border-radius: 0;\n          }\n\n          button:focus {\n            outline: 1px dotted;\n            outline: 5px auto -webkit-focus-ring-color;\n          }\n\n          input,\n          button,\n          select,\n          optgroup,\n          textarea {\n            margin: 0;\n            font-family: inherit;\n            font-size: inherit;\n            line-height: inherit;\n          }\n\n          button,\n          input {\n            overflow: visible;\n          }\n\n          button,\n          select {\n            text-transform: none;\n          }\n\n          select {\n            word-wrap: normal;\n          }\n\n          button,\n          [type='button'],\n          [type='reset'],\n          [type='submit'] {\n            -webkit-appearance: button;\n          }\n\n          button:not(:disabled),\n          [type='button']:not(:disabled),\n          [type='reset']:not(:disabled),\n          [type='submit']:not(:disabled) {\n            cursor: pointer;\n          }\n\n          button::-moz-focus-inner,\n          [type='button']::-moz-focus-inner,\n          [type='reset']::-moz-focus-inner,\n          [type='submit']::-moz-focus-inner {\n            padding: 0;\n            border-style: none;\n          }\n\n          input[type='radio'],\n          input[type='checkbox'] {\n            box-sizing: border-box;\n            padding: 0;\n          }\n\n          input[type='date'],\n          input[type='time'],\n          input[type='datetime-local'],\n          input[type='month'] {\n            -webkit-appearance: listbox;\n          }\n\n          textarea {\n            overflow: auto;\n            resize: vertical;\n          }\n\n          fieldset {\n            min-width: 0;\n            padding: 0;\n            margin: 0;\n            border: 0;\n          }\n\n          legend {\n            display: block;\n            width: 100%;\n            max-width: 100%;\n            padding: 0;\n            margin-bottom: 0.5rem;\n            font-size: 1.5rem;\n            line-height: inherit;\n            color: inherit;\n            white-space: normal;\n          }\n\n          progress {\n            vertical-align: baseline;\n          }\n\n          [type='number']::-webkit-inner-spin-button,\n          [type='number']::-webkit-outer-spin-button {\n            height: auto;\n          }\n\n          [type='search'] {\n            outline-offset: -2px;\n            -webkit-appearance: none;\n          }\n\n          [type='search']::-webkit-search-decoration {\n            -webkit-appearance: none;\n          }\n\n          ::-webkit-file-upload-button {\n            font: inherit;\n            -webkit-appearance: button;\n          }\n\n          output {\n            display: inline-block;\n          }\n\n          summary {\n            display: list-item;\n            cursor: pointer;\n          }\n\n          template {\n            display: none;\n          }\n\n          [hidden] {\n            display: none !important;\n          }\n        "])))
        } }));
}
exports.CssReset = CssReset;
var templateObject_1;


/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/node_modules/ansi-regex/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/node_modules/ansi-regex/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$onlyFirst = _ref.onlyFirst,
      onlyFirst = _ref$onlyFirst === void 0 ? false : _ref$onlyFirst;

  var pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
  return new RegExp(pattern, onlyFirst ? undefined : 'g');
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/@next/react-dev-overlay/node_modules/strip-ansi/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@next/react-dev-overlay/node_modules/strip-ansi/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var ansiRegex = __webpack_require__(/*! ansi-regex */ "./node_modules/@next/react-dev-overlay/node_modules/ansi-regex/index.js");

module.exports = function (string) {
  return typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
};

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/ally.js/element/disabled.js":
/*!**************************************************!*\
  !*** ./node_modules/ally.js/element/disabled.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context, disabledState) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'element/disabled',
    context: context
  });

  // accept truthy/falsy values
  disabledState = Boolean(disabledState);
  var currentState = element.hasAttribute('data-ally-disabled');
  // if there's no value to set, we're running as a getter
  var runningAsGetter = arguments.length === 1;

  if ((0, _nativeDisabledSupported2.default)(element)) {
    if (runningAsGetter) {
      return element.disabled;
    }

    // form elements know the disabled attribute, which we shall use instead of our poor man's copy of it
    element.disabled = disabledState;
    return element;
  }

  if (runningAsGetter) {
    return currentState;
  }

  if (currentState === disabledState) {
    // no update necessary
    return element;
  }

  setElementDisabled(element, disabledState);
  return element;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _nativeDisabledSupported = __webpack_require__(/*! ../is/native-disabled-supported */ "./node_modules/ally.js/is/native-disabled-supported.js");

var _nativeDisabledSupported2 = _interopRequireDefault(_nativeDisabledSupported);

var _toggleAttribute = __webpack_require__(/*! ../util/toggle-attribute */ "./node_modules/ally.js/util/toggle-attribute.js");

var _toggleAttribute2 = _interopRequireDefault(_toggleAttribute);

var _toggleAttributeValue = __webpack_require__(/*! ../util/toggle-attribute-value */ "./node_modules/ally.js/util/toggle-attribute-value.js");

var _toggleAttributeValue2 = _interopRequireDefault(_toggleAttributeValue);

var _logger = __webpack_require__(/*! ../util/logger */ "./node_modules/ally.js/util/logger.js");

var _logger2 = _interopRequireDefault(_logger);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
/*
  Utility to make any element inert (disabled). Inert means the elements cannot be interacted
  with and they cannot be focused via script, pointer or keyboard - and thus not receive focus.

  Elements made inert (disabled) by this utility are given the attribute [data-ally-disabled="true"].

  ---------------

  inert attribute was [removed](https://html5.org/r/8536) [tweet by steve](https://twitter.com/stevefaulkner/status/443075900201259008)
  but definition of [inert subtrees](https://www.w3.org/html/wg/drafts/html/master/editing.html#inert-subtrees) remains.

  [implementation idea by Vasilis](https://codepen.io/vasilisvg/pen/scowI)
  [inert attribute polyfill by GoogleChrome](https://github.com/GoogleChrome/inert-polyfill)

  [Gecko Bug: Inert Attribute](https://bugzilla.mozilla.org/show_bug.cgi?id=921504)
  [Chromium Bug: Inert Attribute](https://code.google.com/p/chromium/issues/detail?id=269846)
  [Chromium Bug: Inert Subtree](https://code.google.com/p/chromium/issues/detail?id=241699)
  [WebKit Bug: Inert Subtree](https://bugs.webkit.org/show_bug.cgi?id=110952)
*/

function disabledFocus() {
  _logger2.default.warn('trying to focus inert element', this);
}

function disableTabindex(element, disabledState) {
  if (disabledState) {
    var tabIndex = (0, _tabindexValue2.default)(element);
    (0, _toggleAttributeValue2.default)({
      element: element,
      attribute: 'tabindex',
      temporaryValue: '-1',
      saveValue: tabIndex !== null ? tabIndex : ''
    });
  } else {
    (0, _toggleAttributeValue2.default)({
      element: element,
      attribute: 'tabindex'
    });
  }
}

function disableVideoControls(element, disabledState) {
  (0, _toggleAttribute2.default)({
    element: element,
    attribute: 'controls',
    remove: disabledState
  });
}

function disableSvgFocusable(element, disabledState) {
  (0, _toggleAttributeValue2.default)({
    element: element,
    attribute: 'focusable',
    temporaryValue: disabledState ? 'false' : undefined
  });
}

function disableSvgLink(element, disabledState) {
  (0, _toggleAttribute2.default)({
    element: element,
    attribute: 'xlink:href',
    remove: disabledState
  });
}

function setAriaDisabled(element, disabledState) {
  (0, _toggleAttributeValue2.default)({
    element: element,
    attribute: 'aria-disabled',
    temporaryValue: disabledState ? 'true' : undefined
  });
}

function disableScriptFocus(element, disabledState) {
  if (disabledState) {
    // make sure no script can focus the element
    element.focus = disabledFocus;
  } else {
    // restore original focus function from prototype
    delete element.focus;
  }
}

function disablePointerEvents(element, disabledState) {
  if (disabledState) {
    // remember previous pointer events status so we can restore it
    var pointerEvents = element.style.pointerEvents || '';
    element.setAttribute('data-inert-pointer-events', pointerEvents);
    // make sure no pointer interaction can access the element
    element.style.pointerEvents = 'none';
  } else {
    // restore to previous pointer interaction status
    var _pointerEvents = element.getAttribute('data-inert-pointer-events');
    element.removeAttribute('data-inert-pointer-events');
    element.style.pointerEvents = _pointerEvents;
  }
}

function setElementDisabled(element, disabledState) {
  setAriaDisabled(element, disabledState);
  disableTabindex(element, disabledState);
  disableScriptFocus(element, disabledState);
  disablePointerEvents(element, disabledState);

  var nodeName = element.nodeName.toLowerCase();
  if (nodeName === 'video' || nodeName === 'audio') {
    // Blink and Gecko leave <video controls tabindex="-1"> in document focus navigation sequence
    // Blink leaves <audio controls tabindex="-1"> in document focus navigation sequence
    disableVideoControls(element, disabledState);
  }

  if (nodeName === 'svg' || element.ownerSVGElement) {
    if (supports.focusSvgFocusableAttribute) {
      // Internet Explorer knows focusable="false" instead of tabindex="-1"
      disableSvgFocusable(element, disabledState);
    } else if (!supports.focusSvgTabindexAttribute && nodeName === 'a') {
      // Firefox neither knows focusable="false" nor tabindex="-1"
      disableSvgLink(element, disabledState);
    }
  }

  if (disabledState) {
    element.setAttribute('data-ally-disabled', 'true');
  } else {
    element.removeAttribute('data-ally-disabled');
  }
}

module.exports = exports['default'];
//# sourceMappingURL=disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/element/focus.svg-foreign-object-hack.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/element/focus.svg-foreign-object-hack.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (element) {
  // Edge13, Edge14: foreignObject focus hack
  // https://jsbin.com/kunehinugi/edit?html,js,output
  // https://jsbin.com/fajagi/3/edit?html,js,output
  var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === 'svg';
  if (!isSvgElement) {
    return false;
  }

  // inject and focus an <input> element into the SVG element to receive focus
  var foreignObject = makeFocusableForeignObject();
  element.appendChild(foreignObject);
  var input = foreignObject.querySelector('input');
  input.focus();

  // upon disabling the activeElement, IE and Edge
  // will not shift focus to <body> like all the other
  // browsers, but instead find the first focusable
  // ancestor and shift focus to that
  input.disabled = true;

  // clean up
  element.removeChild(foreignObject);
  return true;
};

function makeFocusableForeignObject() {
  var fragment = document.createElement('div');
  fragment.innerHTML = '<svg><foreignObject width="30" height="30">\n      <input type="text"/>\n  </foreignObject></svg>';

  return fragment.firstChild.firstChild;
}

module.exports = exports['default'];
//# sourceMappingURL=focus.svg-foreign-object-hack.js.map

/***/ }),

/***/ "./node_modules/ally.js/get/parents.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/get/parents.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  var list = [];
  var element = (0, _contextToElement2.default)({
    label: 'get/parents',
    context: context
  });

  while (element) {
    list.push(element);
    // IE does know support parentElement on SVGElement
    element = element.parentNode;
    if (element && element.nodeType !== Node.ELEMENT_NODE) {
      element = null;
    }
  }

  return list;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];

// [elem, elem.parent, elem.parent.parent, …, html]
// will not contain the shadowRoot (DOCUMENT_FRAGMENT_NODE) and shadowHost
//# sourceMappingURL=parents.js.map

/***/ }),

/***/ "./node_modules/ally.js/get/shadow-host.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/get/shadow-host.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  var element = (0, _contextToElement2.default)({
    label: 'get/shadow-host',
    context: context
  });

  // walk up to the root
  var container = null;

  while (element) {
    container = element;
    element = element.parentNode;
  }

  // https://developer.mozilla.org/en-US/docs/Web/API/Node.nodeType
  // NOTE: Firefox 34 does not expose ShadowRoot.host (but 37 does)
  if (container.nodeType === container.DOCUMENT_FRAGMENT_NODE && container.host) {
    // the root is attached to a fragment node that has a host
    return container.host;
  }

  return null;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=shadow-host.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/active-element.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/is/active-element.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  var element = (0, _contextToElement2.default)({
    label: 'is/active-element',
    resolveDocument: true,
    context: context
  });

  var _document = (0, _getDocument2.default)(element);
  if (_document.activeElement === element) {
    return true;
  }

  var shadowHost = (0, _shadowHost2.default)({ context: element });
  if (shadowHost && shadowHost.shadowRoot.activeElement === element) {
    return true;
  }

  return false;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _shadowHost = __webpack_require__(/*! ../get/shadow-host */ "./node_modules/ally.js/get/shadow-host.js");

var _shadowHost2 = _interopRequireDefault(_shadowHost);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Determines if an element is the activeElement within its context, i.e. its document iFrame or ShadowHost

module.exports = exports['default'];
//# sourceMappingURL=active-element.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/disabled.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/is/disabled.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/disabled',
    context: context
  });

  if (element.hasAttribute('data-ally-disabled')) {
    // treat ally's element/disabled like the DOM native element.disabled
    return true;
  }

  if (!(0, _nativeDisabledSupported2.default)(element)) {
    // non-form elements do not support the disabled attribute
    return false;
  }

  if (element.disabled) {
    // the element itself is disabled
    return true;
  }

  var parents = (0, _parents2.default)({ context: element });
  if (parents.some(isDisabledFieldset)) {
    // a parental <fieldset> is disabld and inherits the state onto this element
    return true;
  }

  if (!supports.focusFormDisabled && parents.some(isDisabledForm)) {
    // a parental <form> is disabld and inherits the state onto this element
    return true;
  }

  return false;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _nativeDisabledSupported = __webpack_require__(/*! ./native-disabled-supported */ "./node_modules/ally.js/is/native-disabled-supported.js");

var _nativeDisabledSupported2 = _interopRequireDefault(_nativeDisabledSupported);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Determine if an element is disabled (i.e. not editable)

var supports = void 0;

function isDisabledFieldset(element) {
  var nodeName = element.nodeName.toLowerCase();
  return nodeName === 'fieldset' && element.disabled;
}

function isDisabledForm(element) {
  var nodeName = element.nodeName.toLowerCase();
  return nodeName === 'form' && element.disabled;
}

module.exports = exports['default'];
//# sourceMappingURL=disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/focus-relevant.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/is/focus-relevant.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _elementMatches = __webpack_require__(/*! ../util/element-matches */ "./node_modules/ally.js/util/element-matches.js");

var _elementMatches2 = _interopRequireDefault(_elementMatches);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _validTabindex = __webpack_require__(/*! ./valid-tabindex */ "./node_modules/ally.js/is/valid-tabindex.js");

var _validTabindex2 = _interopRequireDefault(_validTabindex);

var _is = __webpack_require__(/*! ./is.util */ "./node_modules/ally.js/is/is.util.js");

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
// determine if an element supports.can be focused by script regardless
// of the element actually being focusable at the time of execution
// i.e. <input disabled> is conisdered focus-relevant, but not focusable

function isFocusRelevantRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    flexbox: false,
    scrollable: false,
    shadow: false
  } : _ref$except;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/focus-relevant',
    resolveDocument: true,
    context: context
  });

  if (!except.shadow && element.shadowRoot) {
    // a ShadowDOM host receives focus when the focus moves to its content
    return true;
  }

  var nodeName = element.nodeName.toLowerCase();

  if (nodeName === 'input' && element.type === 'hidden') {
    // input[type="hidden"] supports.cannot be focused
    return false;
  }

  if (nodeName === 'input' || nodeName === 'select' || nodeName === 'button' || nodeName === 'textarea') {
    return true;
  }

  if (nodeName === 'legend' && supports.focusRedirectLegend) {
    // specifics filtered in is/focusable
    return true;
  }

  if (nodeName === 'label') {
    // specifics filtered in is/focusable
    return true;
  }

  if (nodeName === 'area') {
    // specifics filtered in is/focusable
    return true;
  }

  if (nodeName === 'a' && element.hasAttribute('href')) {
    return true;
  }

  if (nodeName === 'object' && element.hasAttribute('usemap')) {
    // object[usemap] is not focusable in any browser
    return false;
  }

  if (nodeName === 'object') {
    var svgType = element.getAttribute('type');
    if (!supports.focusObjectSvg && svgType === 'image/svg+xml') {
      // object[type="image/svg+xml"] is not focusable in Internet Explorer
      return false;
    } else if (!supports.focusObjectSwf && svgType === 'application/x-shockwave-flash') {
      // object[type="application/x-shockwave-flash"] is not focusable in Internet Explorer 9
      return false;
    }
  }

  if (nodeName === 'iframe' || nodeName === 'object') {
    // browsing context containers
    return true;
  }

  if (nodeName === 'embed' || nodeName === 'keygen') {
    // embed is considered focus-relevant but not focusable
    // see https://github.com/medialize/ally.js/issues/82
    return true;
  }

  if (element.hasAttribute('contenteditable')) {
    // also see CSS property user-modify below
    return true;
  }

  if (nodeName === 'audio' && (supports.focusAudioWithoutControls || element.hasAttribute('controls'))) {
    return true;
  }

  if (nodeName === 'video' && (supports.focusVideoWithoutControls || element.hasAttribute('controls'))) {
    return true;
  }

  if (supports.focusSummary && nodeName === 'summary') {
    return true;
  }

  var validTabindex = (0, _validTabindex2.default)(element);

  if (nodeName === 'img' && element.hasAttribute('usemap')) {
    // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,
    // it appears the tabindex is overruled so focus is still forwarded to the <map>
    return validTabindex && supports.focusImgUsemapTabindex || supports.focusRedirectImgUsemap;
  }

  if (supports.focusTable && (nodeName === 'table' || nodeName === 'td')) {
    // IE10-11 supports.can focus <table> and <td>
    return true;
  }

  if (supports.focusFieldset && nodeName === 'fieldset') {
    // IE10-11 supports.can focus <fieldset>
    return true;
  }

  var isSvgElement = nodeName === 'svg';
  var isSvgContent = element.ownerSVGElement;
  var focusableAttribute = element.getAttribute('focusable');
  var tabindex = (0, _tabindexValue2.default)(element);

  if (nodeName === 'use' && tabindex !== null && !supports.focusSvgUseTabindex) {
    // <use> cannot be made focusable by adding a tabindex attribute anywhere but Blink and WebKit
    return false;
  }

  if (nodeName === 'foreignobject') {
    // <use> can only be made focusable in Blink and WebKit
    return tabindex !== null && supports.focusSvgForeignobjectTabindex;
  }

  if ((0, _elementMatches2.default)(element, 'svg a') && element.hasAttribute('xlink:href')) {
    return true;
  }

  if ((isSvgElement || isSvgContent) && element.focus && !supports.focusSvgNegativeTabindexAttribute && tabindex < 0) {
    // Firefox 51 and 52 treat any natively tabbable SVG element with
    // tabindex="-1" as tabbable and everything else as inert
    // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340
    return false;
  }

  if (isSvgElement) {
    return validTabindex || supports.focusSvg || supports.focusSvgInIframe
    // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
    || Boolean(supports.focusSvgFocusableAttribute && focusableAttribute && focusableAttribute === 'true');
  }

  if (isSvgContent) {
    if (supports.focusSvgTabindexAttribute && validTabindex) {
      return true;
    }

    if (supports.focusSvgFocusableAttribute) {
      // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
      return focusableAttribute === 'true';
    }
  }

  // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
  if (validTabindex) {
    return true;
  }

  var style = window.getComputedStyle(element, null);
  if ((0, _is.isUserModifyWritable)(style)) {
    return true;
  }

  if (supports.focusImgIsmap && nodeName === 'img' && element.hasAttribute('ismap')) {
    // IE10-11 considers the <img> in <a href><img ismap> focusable
    // https://github.com/medialize/ally.js/issues/20
    var hasLinkParent = (0, _parents2.default)({ context: element }).some(function (parent) {
      return parent.nodeName.toLowerCase() === 'a' && parent.hasAttribute('href');
    });

    if (hasLinkParent) {
      return true;
    }
  }

  // https://github.com/medialize/ally.js/issues/21
  if (!except.scrollable && supports.focusScrollContainer) {
    if (supports.focusScrollContainerWithoutOverflow) {
      // Internet Explorer does will consider the scrollable area focusable
      // if the element is a <div> or a <span> and it is in fact scrollable,
      // regardless of the CSS overflow property
      if ((0, _is.isScrollableContainer)(element, nodeName)) {
        return true;
      }
    } else if ((0, _is.hasCssOverflowScroll)(style)) {
      // Firefox requires proper overflow setting, IE does not necessarily
      // https://developer.mozilla.org/en-US/docs/Web/CSS/overflow
      return true;
    }
  }

  if (!except.flexbox && supports.focusFlexboxContainer && (0, _is.hasCssDisplayFlex)(style)) {
    // elements with display:flex are focusable in IE10-11
    return true;
  }

  var parent = element.parentElement;
  if (!except.scrollable && parent) {
    var parentNodeName = parent.nodeName.toLowerCase();
    var parentStyle = window.getComputedStyle(parent, null);
    if (supports.focusScrollBody && (0, _is.isScrollableContainer)(parent, nodeName, parentNodeName, parentStyle)) {
      // scrollable bodies are focusable Internet Explorer
      // https://github.com/medialize/ally.js/issues/21
      return true;
    }

    // Children of focusable elements with display:flex are focusable in IE10-11
    if (supports.focusChildrenOfFocusableFlexbox) {
      if ((0, _is.hasCssDisplayFlex)(parentStyle)) {
        return true;
      }
    }
  }

  // NOTE: elements marked as inert are not focusable,
  // but that property is not exposed to the DOM
  // https://www.w3.org/TR/html5/editing.html#inert

  return false;
}

// bind exceptions to an iterator callback
isFocusRelevantRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isFocusRelevant = function isFocusRelevant(context) {
    return isFocusRelevantRules({
      context: context,
      except: except
    });
  };

  isFocusRelevant.rules = isFocusRelevantRules;
  return isFocusRelevant;
};

// provide isFocusRelevant(context) as default iterator callback
var isFocusRelevant = isFocusRelevantRules.except({});
exports.default = isFocusRelevant;
module.exports = exports['default'];
//# sourceMappingURL=focus-relevant.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/focusable.js":
/*!**********************************************!*\
  !*** ./node_modules/ally.js/is/focusable.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _focusRelevant = __webpack_require__(/*! ./focus-relevant */ "./node_modules/ally.js/is/focus-relevant.js");

var _focusRelevant2 = _interopRequireDefault(_focusRelevant);

var _validArea = __webpack_require__(/*! ./valid-area */ "./node_modules/ally.js/is/valid-area.js");

var _validArea2 = _interopRequireDefault(_validArea);

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _disabled = __webpack_require__(/*! ./disabled */ "./node_modules/ally.js/is/disabled.js");

var _disabled2 = _interopRequireDefault(_disabled);

var _onlyTabbable = __webpack_require__(/*! ./only-tabbable */ "./node_modules/ally.js/is/only-tabbable.js");

var _onlyTabbable2 = _interopRequireDefault(_onlyTabbable);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
// determine if an element can be focused

// https://www.w3.org/TR/html5/editing.html#focus-management

// NOTE: The following known issues exist:
//   Gecko: `svg a[xlink|href]` is not identified as focusable (because SVGElement.prototype.focus is missing)
//   Blink, WebKit: SVGElements that have been made focusable by adding a focus event listener are not identified as focusable

function isOnlyFocusRelevant(element) {
  var nodeName = element.nodeName.toLowerCase();
  if (nodeName === 'embed' || nodeName === 'keygen') {
    // embed is considered focus-relevant but not focusable
    // see https://github.com/medialize/ally.js/issues/82
    return true;
  }

  var _tabindex = (0, _tabindexValue2.default)(element);
  if (element.shadowRoot && _tabindex === null) {
    // ShadowDOM host elements *may* receive focus
    // even though they are not considered focuable
    return true;
  }

  if (nodeName === 'label') {
    // <label tabindex="0"> is only tabbable in Firefox, not script-focusable
    // there's no way to make an element focusable other than by adding a tabindex,
    // and focus behavior of the label element seems hard-wired to ignore tabindex
    // in some browsers (like Gecko, Blink and WebKit)
    return !supports.focusLabelTabindex || _tabindex === null;
  }

  if (nodeName === 'legend') {
    return _tabindex === null;
  }

  if (supports.focusSvgFocusableAttribute && (element.ownerSVGElement || nodeName === 'svg')) {
    // Internet Explorer understands the focusable attribute introduced in SVG Tiny 1.2
    var focusableAttribute = element.getAttribute('focusable');
    return focusableAttribute && focusableAttribute === 'false';
  }

  if (nodeName === 'img' && element.hasAttribute('usemap')) {
    // Gecko, Trident and Edge do not allow an image with an image map and tabindex to be focused,
    // it appears the tabindex is overruled so focus is still forwarded to the <map>
    return _tabindex === null || !supports.focusImgUsemapTabindex;
  }

  if (nodeName === 'area') {
    // all <area>s are considered relevant,
    // but only the valid <area>s are focusable
    return !(0, _validArea2.default)(element);
  }

  return false;
}

function isFocusableRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    disabled: false,
    visible: false,
    onlyTabbable: false
  } : _ref$except;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var _isOnlyTabbable = _onlyTabbable2.default.rules.except({
    onlyFocusableBrowsingContext: true,
    visible: except.visible
  });

  var element = (0, _contextToElement2.default)({
    label: 'is/focusable',
    resolveDocument: true,
    context: context
  });

  var focusRelevant = _focusRelevant2.default.rules({
    context: element,
    except: except
  });

  if (!focusRelevant || isOnlyFocusRelevant(element)) {
    return false;
  }

  if (!except.disabled && (0, _disabled2.default)(element)) {
    return false;
  }

  if (!except.onlyTabbable && _isOnlyTabbable(element)) {
    // some elements may be keyboard focusable, but not script focusable
    return false;
  }

  // elements that are not rendered, cannot be focused
  if (!except.visible) {
    var visibilityOptions = {
      context: element,
      except: {}
    };

    if (supports.focusInHiddenIframe) {
      // WebKit and Blink can focus content in hidden <iframe> and <object>
      visibilityOptions.except.browsingContext = true;
    }

    if (supports.focusObjectSvgHidden) {
      // Blink allows focusing the object element, even if it has visibility: hidden;
      // @browser-issue Blink https://code.google.com/p/chromium/issues/detail?id=586191
      var _nodeName2 = element.nodeName.toLowerCase();
      if (_nodeName2 === 'object') {
        visibilityOptions.except.cssVisibility = true;
      }
    }

    if (!_visible2.default.rules(visibilityOptions)) {
      return false;
    }
  }

  var frameElement = (0, _getFrameElement2.default)(element);
  if (frameElement) {
    var _nodeName = frameElement.nodeName.toLowerCase();
    if (_nodeName === 'object' && !supports.focusInZeroDimensionObject) {
      if (!frameElement.offsetWidth || !frameElement.offsetHeight) {
        // WebKit can not focus content in <object> if it doesn't have dimensions
        return false;
      }
    }
  }

  var nodeName = element.nodeName.toLowerCase();
  if (nodeName === 'svg' && supports.focusSvgInIframe && !frameElement && element.getAttribute('tabindex') === null) {
    return false;
  }

  return true;
}

// bind exceptions to an iterator callback
isFocusableRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isFocusable = function isFocusable(context) {
    return isFocusableRules({
      context: context,
      except: except
    });
  };

  isFocusable.rules = isFocusableRules;
  return isFocusable;
};

// provide isFocusRelevant(context) as default iterator callback
var isFocusable = isFocusableRules.except({});
exports.default = isFocusable;
module.exports = exports['default'];
//# sourceMappingURL=focusable.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/is.util.js":
/*!********************************************!*\
  !*** ./node_modules/ally.js/is/is.util.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isUserModifyWritable = isUserModifyWritable;
exports.hasCssOverflowScroll = hasCssOverflowScroll;
exports.hasCssDisplayFlex = hasCssDisplayFlex;
exports.isScrollableContainer = isScrollableContainer;

// this is a shared utility file for focus-relevant.js and tabbable.js
// separate testing of this file's functions is not necessary,
// as they're implicitly tested by way of the consumers

function isUserModifyWritable(style) {
  // https://www.w3.org/TR/1999/WD-css3-userint-19990916#user-modify
  // https://github.com/medialize/ally.js/issues/17
  var userModify = style.webkitUserModify || '';
  return Boolean(userModify && userModify.indexOf('write') !== -1);
}

function hasCssOverflowScroll(style) {
  return [style.getPropertyValue('overflow'), style.getPropertyValue('overflow-x'), style.getPropertyValue('overflow-y')].some(function (overflow) {
    return overflow === 'auto' || overflow === 'scroll';
  });
}

function hasCssDisplayFlex(style) {
  return style.display.indexOf('flex') > -1;
}

function isScrollableContainer(element, nodeName, parentNodeName, parentStyle) {
  if (nodeName !== 'div' && nodeName !== 'span') {
    // Internet Explorer advances scrollable containers and bodies to focusable
    // only if the scrollable container is <div> or <span> - this does *not*
    // happen for <section>, <article>, …
    return false;
  }

  if (parentNodeName && parentNodeName !== 'div' && parentNodeName !== 'span' && !hasCssOverflowScroll(parentStyle)) {
    return false;
  }

  return element.offsetHeight < element.scrollHeight || element.offsetWidth < element.scrollWidth;
}
//# sourceMappingURL=is.util.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/native-disabled-supported.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/is/native-disabled-supported.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();

    if (supports.focusFieldsetDisabled) {
      delete disabledElements.fieldset;
    }

    if (supports.focusFormDisabled) {
      delete disabledElements.form;
    }

    disabledElementsPattern = new RegExp('^(' + Object.keys(disabledElements).join('|') + ')$');
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/native-disabled-supported',
    context: context
  });

  var nodeName = element.nodeName.toLowerCase();
  return Boolean(disabledElementsPattern.test(nodeName));
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Determine if an element supports the disabled attribute

var supports = void 0;

// https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled
var disabledElementsPattern = void 0;
var disabledElements = {
  input: true,
  select: true,
  textarea: true,
  button: true,
  fieldset: true,
  form: true
};

module.exports = exports['default'];
//# sourceMappingURL=native-disabled-supported.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/only-tabbable.js":
/*!**************************************************!*\
  !*** ./node_modules/ally.js/is/only-tabbable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isOnlyTabbableRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    onlyFocusableBrowsingContext: false,
    visible: false
  } : _ref$except;

  var element = (0, _contextToElement2.default)({
    label: 'is/only-tabbable',
    resolveDocument: true,
    context: context
  });

  if (!except.visible && !(0, _visible2.default)(element)) {
    return false;
  }

  if (!except.onlyFocusableBrowsingContext && (_platform2.default.is.GECKO || _platform2.default.is.TRIDENT || _platform2.default.is.EDGE)) {
    var frameElement = (0, _getFrameElement2.default)(element);
    if (frameElement) {
      if ((0, _tabindexValue2.default)(frameElement) < 0) {
        // iframe[tabindex="-1"] and object[tabindex="-1"] inherit the
        // tabbable demotion onto elements of their browsing contexts
        return false;
      }
    }
  }

  var nodeName = element.nodeName.toLowerCase();
  var tabindex = (0, _tabindexValue2.default)(element);

  if (nodeName === 'label' && _platform2.default.is.GECKO) {
    // Firefox cannot focus, but tab to: label[tabindex=0]
    return tabindex !== null && tabindex >= 0;
  }

  // SVG Elements were keyboard focusable but not script focusable before Firefox 51.
  // Firefox 51 added the focus management DOM API (.focus and .blur) to SVGElement,
  // see https://bugzilla.mozilla.org/show_bug.cgi?id=778654
  if (_platform2.default.is.GECKO && element.ownerSVGElement && !element.focus) {
    if (nodeName === 'a' && element.hasAttribute('xlink:href')) {
      // any focusable child of <svg> cannot be focused, but tabbed to
      if (_platform2.default.is.GECKO) {
        return true;
      }
    }
  }

  return false;
}

// bind exceptions to an iterator callback
isOnlyTabbableRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isOnlyTabbable = function isOnlyTabbable(context) {
    return isOnlyTabbableRules({
      context: context,
      except: except
    });
  };

  isOnlyTabbable.rules = isOnlyTabbableRules;
  return isOnlyTabbable;
};

// provide isOnlyTabbable(context) as default iterator callback
var isOnlyTabbable = isOnlyTabbableRules.except({});
exports.default = isOnlyTabbable;
module.exports = exports['default'];
//# sourceMappingURL=only-tabbable.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/tabbable.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/is/tabbable.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _elementMatches = __webpack_require__(/*! ../util/element-matches */ "./node_modules/ally.js/util/element-matches.js");

var _elementMatches2 = _interopRequireDefault(_elementMatches);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

var _focusRelevant = __webpack_require__(/*! ./focus-relevant */ "./node_modules/ally.js/is/focus-relevant.js");

var _focusRelevant2 = _interopRequireDefault(_focusRelevant);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

var _imageMap = __webpack_require__(/*! ../util/image-map */ "./node_modules/ally.js/util/image-map.js");

var _is = __webpack_require__(/*! ./is.util */ "./node_modules/ally.js/is/is.util.js");

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// determine if an element can be focused by keyboard (i.e. is part of the document's sequential focus navigation order)

var supports = void 0;

// Internet Explorer 11 considers fieldset, table, td focusable, but not tabbable
// Internet Explorer 11 considers body to have [tabindex=0], but does not allow tabbing to it
var focusableElementsPattern = /^(fieldset|table|td|body)$/;

function isTabbableRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    flexbox: false,
    scrollable: false,
    shadow: false,
    visible: false,
    onlyTabbable: false
  } : _ref$except;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/tabbable',
    resolveDocument: true,
    context: context
  });

  if (_platform2.default.is.BLINK && _platform2.default.is.ANDROID && _platform2.default.majorVersion > 42) {
    // External keyboard support worked fine in CHrome 42, but stopped working in Chrome 45.
    // The on-screen keyboard does not provide a way to focus the next input element (like iOS does).
    // That leaves us with no option to advance focus by keyboard, ergo nothing is tabbable (keyboard focusable).
    return false;
  }

  var frameElement = (0, _getFrameElement2.default)(element);
  if (frameElement) {
    if (_platform2.default.is.WEBKIT && _platform2.default.is.IOS) {
      // iOS only does not consider anything from another browsing context keyboard focusable
      return false;
    }

    // iframe[tabindex="-1"] and object[tabindex="-1"] inherit the
    // tabbable demotion onto elements of their browsing contexts
    if ((0, _tabindexValue2.default)(frameElement) < 0) {
      return false;
    }

    if (!except.visible && (_platform2.default.is.BLINK || _platform2.default.is.WEBKIT) && !(0, _visible2.default)(frameElement)) {
      // Blink and WebKit consider elements in hidden browsing contexts focusable, but not tabbable
      return false;
    }

    // Webkit and Blink don't consider anything in <object> tabbable
    // Blink fixed that fixed in Chrome 54, Opera 41
    var frameNodeName = frameElement.nodeName.toLowerCase();
    if (frameNodeName === 'object') {
      var isFixedBlink = _platform2.default.name === 'Chrome' && _platform2.default.majorVersion >= 54 || _platform2.default.name === 'Opera' && _platform2.default.majorVersion >= 41;

      if (_platform2.default.is.WEBKIT || _platform2.default.is.BLINK && !isFixedBlink) {
        return false;
      }
    }
  }

  var nodeName = element.nodeName.toLowerCase();
  var _tabindex = (0, _tabindexValue2.default)(element);
  var tabindex = _tabindex === null ? null : _tabindex >= 0;

  if (_platform2.default.is.EDGE && _platform2.default.majorVersion >= 14 && frameElement && element.ownerSVGElement && _tabindex < 0) {
    // Edge 14+ considers <a xlink:href="…" tabindex="-1"> keyboard focusable
    // if the element is in a nested browsing context
    return true;
  }

  var hasTabbableTabindexOrNone = tabindex !== false;
  var hasTabbableTabindex = _tabindex !== null && _tabindex >= 0;

  // NOTE: Firefox 31 considers [contenteditable] to have [tabindex=-1], but allows tabbing to it
  // fixed in Firefox 40 the latest - https://bugzilla.mozilla.org/show_bug.cgi?id=1185657
  if (element.hasAttribute('contenteditable')) {
    // tabbing can still be disabled by explicitly providing [tabindex="-1"]
    return hasTabbableTabindexOrNone;
  }

  if (focusableElementsPattern.test(nodeName) && tabindex !== true) {
    return false;
  }

  if (_platform2.default.is.WEBKIT && _platform2.default.is.IOS) {
    // iOS only considers a hand full of elements tabbable (keyboard focusable)
    // this holds true even with external keyboards
    var potentiallyTabbable = nodeName === 'input' && element.type === 'text' || element.type === 'password' || nodeName === 'select' || nodeName === 'textarea' || element.hasAttribute('contenteditable');

    if (!potentiallyTabbable) {
      var style = window.getComputedStyle(element, null);
      potentiallyTabbable = (0, _is.isUserModifyWritable)(style);
    }

    if (!potentiallyTabbable) {
      return false;
    }
  }

  if (nodeName === 'use' && _tabindex !== null) {
    if (_platform2.default.is.BLINK || _platform2.default.is.WEBKIT && _platform2.default.majorVersion === 9) {
      // In Chrome and Safari 9 the <use> element is keyboard focusable even for tabindex="-1"
      return true;
    }
  }

  if ((0, _elementMatches2.default)(element, 'svg a') && element.hasAttribute('xlink:href')) {
    if (hasTabbableTabindexOrNone) {
      // in Trident and Gecko SVGElement does not handle the tabIndex property properly
      return true;
    }

    if (element.focus && !supports.focusSvgNegativeTabindexAttribute) {
      // Firefox 51 and 52 treat any natively tabbable SVG element with
      // tabindex="-1" as tabbable and everything else as inert
      // see https://bugzilla.mozilla.org/show_bug.cgi?id=1302340
      return true;
    }
  }

  if (nodeName === 'svg' && supports.focusSvgInIframe && hasTabbableTabindexOrNone) {
    return true;
  }

  if (_platform2.default.is.TRIDENT || _platform2.default.is.EDGE) {
    if (nodeName === 'svg') {
      if (supports.focusSvg) {
        // older Internet Explorers consider <svg> keyboard focusable
        // unless they have focsable="false", but then they wouldn't
        // be focusable and thus not even reach this filter
        return true;
      }

      // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value
      return element.hasAttribute('focusable') || hasTabbableTabindex;
    }

    if (element.ownerSVGElement) {
      if (supports.focusSvgTabindexAttribute && hasTabbableTabindex) {
        return true;
      }

      // elements that have [focusable] are automatically keyboard focusable regardless of the attribute's value
      return element.hasAttribute('focusable');
    }
  }
  if (element.tabIndex === undefined) {
    return Boolean(except.onlyTabbable);
  }

  if (nodeName === 'audio') {
    if (!element.hasAttribute('controls')) {
      // In Internet Explorer the <audio> element is focusable, but not tabbable, and tabIndex property is wrong
      return false;
    } else if (_platform2.default.is.BLINK) {
      // In Chrome <audio controls tabindex="-1"> remains keyboard focusable
      return true;
    }
  }

  if (nodeName === 'video') {
    if (!element.hasAttribute('controls')) {
      if (_platform2.default.is.TRIDENT || _platform2.default.is.EDGE) {
        // In Internet Explorer and Edge the <video> element is focusable, but not tabbable, and tabIndex property is wrong
        return false;
      }
    } else if (_platform2.default.is.BLINK || _platform2.default.is.GECKO) {
      // In Chrome and Firefox <video controls tabindex="-1"> remains keyboard focusable
      return true;
    }
  }

  if (nodeName === 'object') {
    if (_platform2.default.is.BLINK || _platform2.default.is.WEBKIT) {
      // In all Blink and WebKit based browsers <embed> and <object> are never keyboard focusable, even with tabindex="0" set
      return false;
    }
  }

  if (nodeName === 'iframe') {
    // In Internet Explorer all iframes are only focusable
    // In WebKit, Blink and Gecko iframes may be tabbable depending on content.
    // Since we can't reliably investigate iframe documents because of the
    // SameOriginPolicy, we're declaring everything only focusable.
    return false;
  }

  if (!except.scrollable && _platform2.default.is.GECKO) {
    // Firefox considers scrollable containers keyboard focusable,
    // even though their tabIndex property is -1
    var _style = window.getComputedStyle(element, null);
    if ((0, _is.hasCssOverflowScroll)(_style)) {
      return hasTabbableTabindexOrNone;
    }
  }

  if (_platform2.default.is.TRIDENT || _platform2.default.is.EDGE) {
    // IE and Edge degrade <area> to script focusable, if the image
    // using the <map> has been given tabindex="-1"
    if (nodeName === 'area') {
      var img = (0, _imageMap.getImageOfArea)(element);
      if (img && (0, _tabindexValue2.default)(img) < 0) {
        return false;
      }
    }

    var _style2 = window.getComputedStyle(element, null);
    if ((0, _is.isUserModifyWritable)(_style2)) {
      // prevent being swallowed by the overzealous isScrollableContainer() below
      return element.tabIndex >= 0;
    }

    if (!except.flexbox && (0, _is.hasCssDisplayFlex)(_style2)) {
      if (_tabindex !== null) {
        return hasTabbableTabindex;
      }

      return isFocusRelevantWithoutFlexbox(element) && isTabbableWithoutFlexbox(element);
    }

    // IE considers scrollable containers script focusable only,
    // even though their tabIndex property is 0
    if ((0, _is.isScrollableContainer)(element, nodeName)) {
      return false;
    }

    var parent = element.parentElement;
    if (parent) {
      var parentNodeName = parent.nodeName.toLowerCase();
      var parentStyle = window.getComputedStyle(parent, null);
      // IE considers scrollable bodies script focusable only,
      if ((0, _is.isScrollableContainer)(parent, nodeName, parentNodeName, parentStyle)) {
        return false;
      }

      // Children of focusable elements with display:flex are focusable in IE10-11,
      // even though their tabIndex property suggests otherwise
      if ((0, _is.hasCssDisplayFlex)(parentStyle)) {
        // value of tabindex takes precedence
        return hasTabbableTabindex;
      }
    }
  }

  // https://www.w3.org/WAI/PF/aria-practices/#focus_tabindex
  return element.tabIndex >= 0;
}

// bind exceptions to an iterator callback
isTabbableRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isTabbable = function isTabbable(context) {
    return isTabbableRules({
      context: context,
      except: except
    });
  };

  isTabbable.rules = isTabbableRules;
  return isTabbable;
};

var isFocusRelevantWithoutFlexbox = _focusRelevant2.default.rules.except({ flexbox: true });
var isTabbableWithoutFlexbox = isTabbableRules.except({ flexbox: true });

// provide isTabbable(context) as default iterator callback
var isTabbable = isTabbableRules.except({});
exports.default = isTabbable;
module.exports = exports['default'];
//# sourceMappingURL=tabbable.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/valid-area.js":
/*!***********************************************!*\
  !*** ./node_modules/ally.js/is/valid-area.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var element = (0, _contextToElement2.default)({
    label: 'is/valid-area',
    context: context
  });

  var nodeName = element.nodeName.toLowerCase();
  if (nodeName !== 'area') {
    return false;
  }

  var hasTabindex = element.hasAttribute('tabindex');
  if (!supports.focusAreaTabindex && hasTabindex) {
    // Blink and WebKit do not consider <area tabindex="-1" href="#void"> focusable
    return false;
  }

  var img = (0, _imageMap.getImageOfArea)(element);
  if (!img || !(0, _visible2.default)(img)) {
    return false;
  }

  // Firefox only allows fully loaded images to reference image maps
  // https://stereochro.me/ideas/detecting-broken-images-js
  if (!supports.focusBrokenImageMap && (!img.complete || !img.naturalHeight || img.offsetWidth <= 0 || img.offsetHeight <= 0)) {
    return false;
  }

  // Firefox supports.can focus area elements even if they don't have an href attribute
  if (!supports.focusAreaWithoutHref && !element.href) {
    // Internet explorer supports.can focus area elements without href if either
    // the area element or the image element has a tabindex attribute
    return supports.focusAreaTabindex && hasTabindex || supports.focusAreaImgTabindex && img.hasAttribute('tabindex');
  }

  // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
  var childOfInteractive = (0, _parents2.default)({ context: img }).slice(1).some(function (_element) {
    var name = _element.nodeName.toLowerCase();
    return name === 'button' || name === 'a';
  });

  if (childOfInteractive) {
    return false;
  }

  return true;
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _visible = __webpack_require__(/*! ./visible */ "./node_modules/ally.js/is/visible.js");

var _visible2 = _interopRequireDefault(_visible);

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _imageMap = __webpack_require__(/*! ../util/image-map */ "./node_modules/ally.js/util/image-map.js");

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/map
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
// https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L88-L107

// determine if an <area> element is being properly used by and <img> via a <map>

module.exports = exports['default'];
//# sourceMappingURL=valid-area.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/valid-tabindex.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/is/valid-tabindex.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (context) {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var validIntegerPattern = supports.focusTabindexTrailingCharacters ? validIntegerPatternWithTrailing : validIntegerPatternNoTrailing;

  var element = (0, _contextToElement2.default)({
    label: 'is/valid-tabindex',
    resolveDocument: true,
    context: context
  });

  // Edge 14 has a capitalization problem on SVG elements,
  // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/
  var hasTabindex = element.hasAttribute('tabindex');
  var hasTabIndex = element.hasAttribute('tabIndex');

  if (!hasTabindex && !hasTabIndex) {
    return false;
  }

  // older Firefox and Internet Explorer don't support tabindex on SVG elements
  var isSvgElement = element.ownerSVGElement || element.nodeName.toLowerCase() === 'svg';
  if (isSvgElement && !supports.focusSvgTabindexAttribute) {
    return false;
  }

  // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
  if (supports.focusInvalidTabindex) {
    return true;
  }

  // an element matches the tabindex selector even if its value is invalid
  var tabindex = element.getAttribute(hasTabindex ? 'tabindex' : 'tabIndex');
  // IE11 parses tabindex="" as the value "-32768"
  // @browser-issue Trident https://connect.microsoft.com/IE/feedback/details/1072965
  if (tabindex === '-32768') {
    return false;
  }

  return Boolean(tabindex && validIntegerPattern.test(tabindex));
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// determine if an element's tabindex attribute has a valid value

var supports = void 0;

// https://www.w3.org/TR/html5/infrastructure.html#rules-for-parsing-integers
// NOTE: all browsers agree to allow trailing spaces as well
var validIntegerPatternNoTrailing = /^\s*(-|\+)?[0-9]+\s*$/;
var validIntegerPatternWithTrailing = /^\s*(-|\+)?[0-9]+.*$/;

module.exports = exports['default'];
//# sourceMappingURL=valid-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/is/visible.js":
/*!********************************************!*\
  !*** ./node_modules/ally.js/is/visible.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _arrayFindIndex = __webpack_require__(/*! ../util/array-find-index */ "./node_modules/ally.js/util/array-find-index.js");

var _arrayFindIndex2 = _interopRequireDefault(_arrayFindIndex);

var _parents = __webpack_require__(/*! ../get/parents */ "./node_modules/ally.js/get/parents.js");

var _parents2 = _interopRequireDefault(_parents);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getFrameElement = __webpack_require__(/*! ../util/get-frame-element */ "./node_modules/ally.js/util/get-frame-element.js");

var _getFrameElement2 = _interopRequireDefault(_getFrameElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/html5/rendering.html#being-rendered
// <area> is not rendered, but we *consider* it visible to simplfiy this function's usage

// determine if an element is rendered
// NOTE: that does not mean an element is visible in the viewport, see util/visible-area

var notRenderedElementsPattern = /^(area)$/;

function computedStyle(element, property) {
  return window.getComputedStyle(element, null).getPropertyValue(property);
}

function notDisplayed(_path) {
  return _path.some(function (element) {
    // display:none is not visible (optimized away at layout)
    return computedStyle(element, 'display') === 'none';
  });
}

function notVisible(_path) {
  // https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L109-L114
  // NOTE: a nested element can reverse visibility:hidden|collapse by explicitly setting visibility:visible
  // NOTE: visibility can be ["", "visible", "hidden", "collapse"]
  var hidden = (0, _arrayFindIndex2.default)(_path, function (element) {
    var visibility = computedStyle(element, 'visibility');
    return visibility === 'hidden' || visibility === 'collapse';
  });

  if (hidden === -1) {
    // there is no hidden element
    return false;
  }

  var visible = (0, _arrayFindIndex2.default)(_path, function (element) {
    return computedStyle(element, 'visibility') === 'visible';
  });

  if (visible === -1) {
    // there is no visible element (but a hidden element)
    return true;
  }

  if (hidden < visible) {
    // there is a hidden element and it's closer than the first visible element
    return true;
  }

  // there may be a hidden element, but the closest element is visible
  return false;
}

function collapsedParent(_path) {
  var offset = 1;
  if (_path[0].nodeName.toLowerCase() === 'summary') {
    offset = 2;
  }

  return _path.slice(offset).some(function (element) {
    // "content children" of a closed details element are not visible
    return element.nodeName.toLowerCase() === 'details' && element.open === false;
  });
}

function isVisibleRules() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      _ref$except = _ref.except,
      except = _ref$except === undefined ? {
    notRendered: false,
    cssDisplay: false,
    cssVisibility: false,
    detailsElement: false,
    browsingContext: false
  } : _ref$except;

  var element = (0, _contextToElement2.default)({
    label: 'is/visible',
    resolveDocument: true,
    context: context
  });

  var nodeName = element.nodeName.toLowerCase();
  if (!except.notRendered && notRenderedElementsPattern.test(nodeName)) {
    return true;
  }

  var _path = (0, _parents2.default)({ context: element });

  // in Internet Explorer <audio> has a default display: none, where others have display: inline
  // but IE allows focusing <audio style="display:none">, but not <div display:none><audio>
  // this is irrelevant to other browsers, as the controls attribute is required to make <audio> focusable
  var isAudioWithoutControls = nodeName === 'audio' && !element.hasAttribute('controls');
  if (!except.cssDisplay && notDisplayed(isAudioWithoutControls ? _path.slice(1) : _path)) {
    return false;
  }

  if (!except.cssVisibility && notVisible(_path)) {
    return false;
  }

  if (!except.detailsElement && collapsedParent(_path)) {
    return false;
  }

  if (!except.browsingContext) {
    // elements within a browsing context are affected by the
    // browsing context host element's visibility and tabindex
    var frameElement = (0, _getFrameElement2.default)(element);
    var _isVisible = isVisibleRules.except(except);
    if (frameElement && !_isVisible(frameElement)) {
      return false;
    }
  }

  return true;
}

// bind exceptions to an iterator callback
isVisibleRules.except = function () {
  var except = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var isVisible = function isVisible(context) {
    return isVisibleRules({
      context: context,
      except: except
    });
  };

  isVisible.rules = isVisibleRules;
  return isVisible;
};

// provide isVisible(context) as default iterator callback
var isVisible = isVisibleRules.except({});
exports.default = isVisible;
module.exports = exports['default'];
//# sourceMappingURL=visible.js.map

/***/ }),

/***/ "./node_modules/ally.js/maintain/disabled.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/maintain/disabled.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
/*
  Utility to make a sub-tree of the DOM inert. Inert means the elements cannot be interacted
  with and they cannot be focused via script, pointer or keyboard.

  inert attribute was [removed](https://html5.org/r/8536) [tweet by steve](https://twitter.com/stevefaulkner/status/443075900201259008)
  but definition of [inert subtrees](https://www.w3.org/html/wg/drafts/html/master/editing.html#inert-subtrees) remains.

  [implementation idea by Vasilis](https://codepen.io/vasilisvg/pen/scowI)
  [inert attribute polyfill by GoogleChrome](https://github.com/GoogleChrome/inert-polyfill)

  [Gecko Bug: Inert Attribute](https://bugzilla.mozilla.org/show_bug.cgi?id=921504)
  [Chromium Bug: Inert Attribute](https://code.google.com/p/chromium/issues/detail?id=269846)
  [Chromium Bug: Inert Subtree](https://code.google.com/p/chromium/issues/detail?id=241699)
  [WebKit Bug: Inert Subtree](https://bugs.webkit.org/show_bug.cgi?id=110952)
*/

exports.default = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref2.context,
      filter = _ref2.filter;

  var service = new InertSubtree({ context: context, filter: filter });
  return { disengage: service.disengage };
};

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _focusable = __webpack_require__(/*! ../query/focusable */ "./node_modules/ally.js/query/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _disabled = __webpack_require__(/*! ../element/disabled */ "./node_modules/ally.js/element/disabled.js");

var _disabled2 = _interopRequireDefault(_disabled);

var _shadowMutations = __webpack_require__(/*! ../observe/shadow-mutations */ "./node_modules/ally.js/observe/shadow-mutations.js");

var _shadowMutations2 = _interopRequireDefault(_shadowMutations);

var _comparePosition = __webpack_require__(/*! ../util/compare-position */ "./node_modules/ally.js/util/compare-position.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function makeElementInert(element) {
  return (0, _disabled2.default)(element, true);
}

function undoElementInert(element) {
  return (0, _disabled2.default)(element, false);
}

var observerConfig = {
  attributes: true,
  childList: true,
  subtree: true,
  attributeFilter: ['tabindex', 'disabled', 'data-ally-disabled']
};

var InertSubtree = function () {
  function InertSubtree() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        context = _ref.context,
        filter = _ref.filter;

    _classCallCheck(this, InertSubtree);

    this._context = (0, _nodeArray2.default)(context || document.documentElement)[0];
    this._filter = (0, _nodeArray2.default)(filter);
    this._inertElementCache = [];

    this.disengage = this.disengage.bind(this);
    this.handleMutation = this.handleMutation.bind(this);
    this.renderInert = this.renderInert.bind(this);
    this.filterElements = this.filterElements.bind(this);
    this.filterParentElements = this.filterParentElements.bind(this);

    var focusable = (0, _focusable2.default)({
      context: this._context,
      includeContext: true,
      strategy: 'all'
    });

    this.renderInert(focusable);

    this.shadowObserver = (0, _shadowMutations2.default)({
      context: this._context,
      config: observerConfig,
      callback: function callback(mutations) {
        return mutations.forEach(_this.handleMutation);
      }
    });
  }

  _createClass(InertSubtree, [{
    key: 'disengage',
    value: function disengage() {
      if (!this._context) {
        return;
      }

      undoElementInert(this._context);
      this._inertElementCache.forEach(function (element) {
        return undoElementInert(element);
      });

      this._inertElementCache = null;
      this._filter = null;
      this._context = null;
      this.shadowObserver && this.shadowObserver.disengage();
      this.shadowObserver = null;
    }
  }, {
    key: 'listQueryFocusable',
    value: function listQueryFocusable(list) {
      return list
      // find all focusable elements within the given contexts
      .map(function (element) {
        return (0, _focusable2.default)({ context: element, includeContext: true, strategy: 'all' });
      })
      // flatten nested arrays
      .reduce(function (previous, current) {
        return previous.concat(current);
      }, []);
    }
  }, {
    key: 'renderInert',
    value: function renderInert(elements) {
      var _this2 = this;

      var makeInert = function makeInert(element) {
        _this2._inertElementCache.push(element);
        makeElementInert(element);
      };

      elements.filter(this.filterElements).filter(this.filterParentElements)
      // ignore elements that already are disabled
      // so we don't enable them on disengage()
      .filter(function (element) {
        return !(0, _disabled2.default)(element);
      }).forEach(makeInert);
    }
  }, {
    key: 'filterElements',
    value: function filterElements(element) {
      // ignore elements within the exempted sub-trees
      var isParentOfElement = (0, _comparePosition.getParentComparator)({ element: element, includeSelf: true });
      return !this._filter.some(isParentOfElement);
    }
  }, {
    key: 'filterParentElements',
    value: function filterParentElements(element) {
      // ignore ancestors of the exempted sub-trees
      var isParentOfElement = (0, _comparePosition.getParentComparator)({ parent: element });
      return !this._filter.some(isParentOfElement);
    }
  }, {
    key: 'handleMutation',
    value: function handleMutation(mutation) {
      if (mutation.type === 'childList') {
        var addedElements = (0, _nodeArray2.default)(mutation.addedNodes).filter(function (element) {
          return element.nodeType === Node.ELEMENT_NODE;
        });
        if (!addedElements.length) {
          return;
        }

        var addedFocusableElements = this.listQueryFocusable(addedElements);
        this.renderInert(addedFocusableElements);
      } else if (mutation.type === 'attributes') {
        this.renderInert([mutation.target]);
      }
    }
  }]);

  return InertSubtree;
}();

module.exports = exports['default'];
//# sourceMappingURL=disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/maintain/tab-focus.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/maintain/tab-focus.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  if (!context) {
    context = document.documentElement;
  }

  // Make sure the supports tests are run before intercepting the Tab key,
  // or IE10 and IE11 will fail to process the first Tab key event. Not
  // limiting this warm-up to IE because it may be a problem elsewhere, too.
  (0, _tabsequence2.default)();

  return (0, _key2.default)({
    // Safari on OSX may require ALT+TAB to reach links,
    // see https://github.com/medialize/ally.js/issues/146
    '?alt+?shift+tab': function altShiftTab(event) {
      // we're completely taking over the Tab key handling
      event.preventDefault();

      var sequence = (0, _tabsequence2.default)({
        context: context
      });

      var backward = event.shiftKey;
      var first = sequence[0];
      var last = sequence[sequence.length - 1];

      // wrap around first to last, last to first
      var source = backward ? first : last;
      var target = backward ? last : first;
      if ((0, _activeElement2.default)(source)) {
        target.focus();
        return;
      }

      // find current position in tabsequence
      var currentIndex = void 0;
      var found = sequence.some(function (element, index) {
        if (!(0, _activeElement2.default)(element)) {
          return false;
        }

        currentIndex = index;
        return true;
      });

      if (!found) {
        // redirect to first as we're not in our tabsequence
        first.focus();
        return;
      }

      // shift focus to previous/next element in the sequence
      var offset = backward ? -1 : 1;
      sequence[currentIndex + offset].focus();
    }
  });
};

var _activeElement = __webpack_require__(/*! ../is/active-element */ "./node_modules/ally.js/is/active-element.js");

var _activeElement2 = _interopRequireDefault(_activeElement);

var _tabsequence = __webpack_require__(/*! ../query/tabsequence */ "./node_modules/ally.js/query/tabsequence.js");

var _tabsequence2 = _interopRequireDefault(_tabsequence);

var _key = __webpack_require__(/*! ../when/key */ "./node_modules/ally.js/when/key.js");

var _key2 = _interopRequireDefault(_key);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=tab-focus.js.map

/***/ }),

/***/ "./node_modules/ally.js/map/keycode.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/map/keycode.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// codes mostly cloned from https://github.com/keithamus/jwerty/blob/master/jwerty.js
// deliberately not exposing characters like <,.-#* because they vary *wildly*
// across keyboard layouts and may cause various problems
// (e.g. "*" is "Shift +" on a German Mac keyboard)
// (e.g. "@" is "Alt L" on a German Mac keyboard)

var keycode = {
  // Element Focus
  tab: 9,

  // Navigation
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  pageUp: 33,
  'page-up': 33,
  pageDown: 34,
  'page-down': 34,
  end: 35,
  home: 36,

  // Action
  enter: 13,
  escape: 27,
  space: 32,

  // Modifier
  shift: 16,
  capsLock: 20,
  'caps-lock': 20,
  ctrl: 17,
  alt: 18,
  meta: 91,
  // in firefox: 224
  // on mac (chrome): meta-left=91, meta-right=93
  // on win (IE11): meta-left=91, meta-right=92
  pause: 19,

  // Content Manipulation
  insert: 45,
  'delete': 46,
  backspace: 8,

  // the same logical key may be identified through different keyCodes
  _alias: {
    91: [92, 93, 224]
  }
};

// Function keys (112 - 137)
// NOTE: not every keyboard knows F13+
for (var n = 1; n < 26; n++) {
  keycode['f' + n] = n + 111;
}

// Number keys (48-57, numpad 96-105)
// NOTE: not every keyboard knows num-0+
for (var _n = 0; _n < 10; _n++) {
  var code = _n + 48;
  var numCode = _n + 96;
  keycode[_n] = code;
  keycode['num-' + _n] = numCode;
  keycode._alias[code] = [numCode];
}

// Latin characters (65 - 90)
for (var _n2 = 0; _n2 < 26; _n2++) {
  var _code = _n2 + 65;
  var name = String.fromCharCode(_code).toLowerCase();
  keycode[name] = _code;
}

exports.default = keycode;
module.exports = exports['default'];
//# sourceMappingURL=keycode.js.map

/***/ }),

/***/ "./node_modules/ally.js/observe/shadow-mutations.js":
/*!**********************************************************!*\
  !*** ./node_modules/ally.js/observe/shadow-mutations.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref2.context,
      callback = _ref2.callback,
      config = _ref2.config;

  if (typeof callback !== 'function') {
    throw new TypeError('observe/shadow-mutations requires options.callback to be a function');
  }

  if ((typeof config === 'undefined' ? 'undefined' : _typeof(config)) !== 'object') {
    throw new TypeError('observe/shadow-mutations requires options.config to be an object');
  }

  if (!window.MutationObserver) {
    // not supporting IE10 via Mutation Events, because they're too expensive
    // https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Mutation_events
    return {
      disengage: function disengage() {}
    };
  }

  var element = (0, _contextToElement2.default)({
    label: 'observe/shadow-mutations',
    resolveDocument: true,
    defaultToDocument: true,
    context: context
  });

  var service = new ShadowMutationObserver({
    context: element,
    callback: callback,
    config: config
  });

  return {
    disengage: service.disengage
  };
};

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _shadowHosts = __webpack_require__(/*! ../query/shadow-hosts */ "./node_modules/ally.js/query/shadow-hosts.js");

var _shadowHosts2 = _interopRequireDefault(_shadowHosts);

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var shadowObserverConfig = {
  childList: true,
  subtree: true
};

var ShadowMutationObserver = function () {
  function ShadowMutationObserver() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        context = _ref.context,
        callback = _ref.callback,
        config = _ref.config;

    _classCallCheck(this, ShadowMutationObserver);

    this.config = config;

    this.disengage = this.disengage.bind(this);

    this.clientObserver = new MutationObserver(callback);
    this.hostObserver = new MutationObserver(function (mutations) {
      return mutations.forEach(_this.handleHostMutation, _this);
    });

    this.observeContext(context);
    this.observeShadowHosts(context);
  }

  _createClass(ShadowMutationObserver, [{
    key: 'disengage',
    value: function disengage() {
      this.clientObserver && this.clientObserver.disconnect();
      this.clientObserver = null;
      this.hostObserver && this.hostObserver.disconnect();
      this.hostObserver = null;
    }
  }, {
    key: 'observeShadowHosts',
    value: function observeShadowHosts(context) {
      var _this2 = this;

      var hosts = (0, _shadowHosts2.default)({
        context: context
      });

      hosts.forEach(function (element) {
        return _this2.observeContext(element.shadowRoot);
      });
    }
  }, {
    key: 'observeContext',
    value: function observeContext(context) {
      this.clientObserver.observe(context, this.config);
      this.hostObserver.observe(context, shadowObserverConfig);
    }
  }, {
    key: 'handleHostMutation',
    value: function handleHostMutation(mutation) {
      if (mutation.type !== 'childList') {
        return;
      }

      var addedElements = (0, _nodeArray2.default)(mutation.addedNodes).filter(function (element) {
        return element.nodeType === Node.ELEMENT_NODE;
      });
      addedElements.forEach(this.observeShadowHosts, this);
    }
  }]);

  return ShadowMutationObserver;
}();

module.exports = exports['default'];
//# sourceMappingURL=shadow-mutations.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/focusable.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/query/focusable.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      _ref$strategy = _ref.strategy,
      strategy = _ref$strategy === undefined ? 'quick' : _ref$strategy;

  var element = (0, _contextToElement2.default)({
    label: 'query/focusable',
    resolveDocument: true,
    defaultToDocument: true,
    context: context
  });

  var options = {
    context: element,
    includeContext: includeContext,
    includeOnlyTabbable: includeOnlyTabbable,
    strategy: strategy
  };

  if (strategy === 'quick') {
    return (0, _focusable4.default)(options);
  } else if (strategy === 'strict' || strategy === 'all') {
    return (0, _focusable2.default)(options);
  }

  throw new TypeError('query/focusable requires option.strategy to be one of ["quick", "strict", "all"]');
};

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _focusable = __webpack_require__(/*! ./focusable.strict */ "./node_modules/ally.js/query/focusable.strict.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _focusable3 = __webpack_require__(/*! ./focusable.quick */ "./node_modules/ally.js/query/focusable.quick.js");

var _focusable4 = _interopRequireDefault(_focusable3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/html5/editing.html#focusable
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

module.exports = exports['default'];
//# sourceMappingURL=focusable.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/focusable.quick.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/query/focusable.quick.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queryFocusableQuick;

var _focusable = __webpack_require__(/*! ../selector/focusable */ "./node_modules/ally.js/selector/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _focusable3 = __webpack_require__(/*! ../is/focusable */ "./node_modules/ally.js/is/focusable.js");

var _focusable4 = _interopRequireDefault(_focusable3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://www.w3.org/TR/html5/editing.html#focusable
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

function queryFocusableQuick() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable;

  var _selector = (0, _focusable2.default)();
  var elements = context.querySelectorAll(_selector);
  // the selector potentially matches more than really is focusable

  var _isFocusable = _focusable4.default.rules.except({
    onlyTabbable: includeOnlyTabbable
  });

  var result = [].filter.call(elements, _isFocusable);

  // add context if requested and focusable
  if (includeContext && _isFocusable(context)) {
    result.unshift(context);
  }

  return result;
}
module.exports = exports['default'];
//# sourceMappingURL=focusable.quick.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/focusable.strict.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/query/focusable.strict.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queryFocusableStrict;

var _focusable = __webpack_require__(/*! ../is/focusable */ "./node_modules/ally.js/is/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _focusRelevant = __webpack_require__(/*! ../is/focus-relevant */ "./node_modules/ally.js/is/focus-relevant.js");

var _focusRelevant2 = _interopRequireDefault(_focusRelevant);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createFilter(condition) {
  // see https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter
  var filter = function filter(node) {
    if (node.shadowRoot) {
      // return ShadowRoot elements regardless of them being focusable,
      // so they can be walked recursively later
      return NodeFilter.FILTER_ACCEPT;
    }

    if (condition(node)) {
      // finds elements that could have been found by document.querySelectorAll()
      return NodeFilter.FILTER_ACCEPT;
    }

    return NodeFilter.FILTER_SKIP;
  };
  // IE requires a function, Browsers require {acceptNode: function}
  // see http://www.bennadel.com/blog/2607-finding-html-comment-nodes-in-the-dom-using-treewalker.htm
  filter.acceptNode = filter;
  return filter;
}
// https://www.w3.org/TR/html5/editing.html#focusable
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

var PossiblyFocusableFilter = createFilter(_focusRelevant2.default);

function queryFocusableStrict() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      strategy = _ref.strategy;

  if (!context) {
    context = document.documentElement;
  }

  var _isFocusable = _focusable2.default.rules.except({
    onlyTabbable: includeOnlyTabbable
  });

  var _document = (0, _getDocument2.default)(context);
  // see https://developer.mozilla.org/en-US/docs/Web/API/Document/createTreeWalker
  var walker = _document.createTreeWalker(
  // root element to start search in
  context,
  // element type filter
  NodeFilter.SHOW_ELEMENT,
  // custom NodeFilter filter
  strategy === 'all' ? PossiblyFocusableFilter : createFilter(_isFocusable),
  // deprecated, but IE requires it
  false);

  var list = [];

  while (walker.nextNode()) {
    if (walker.currentNode.shadowRoot) {
      if (_isFocusable(walker.currentNode)) {
        list.push(walker.currentNode);
      }

      list = list.concat(queryFocusableStrict({
        context: walker.currentNode.shadowRoot,
        includeOnlyTabbable: includeOnlyTabbable,
        strategy: strategy
      }));
    } else {
      list.push(walker.currentNode);
    }
  }

  // add context if requested and focusable
  if (includeContext) {
    if (strategy === 'all') {
      if ((0, _focusRelevant2.default)(context)) {
        list.unshift(context);
      }
    } else if (_isFocusable(context)) {
      list.unshift(context);
    }
  }

  return list;
}
module.exports = exports['default'];
//# sourceMappingURL=focusable.strict.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/shadow-hosts.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/query/shadow-hosts.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queryShadowHosts;

var _contextToElement = __webpack_require__(/*! ../util/context-to-element */ "./node_modules/ally.js/util/context-to-element.js");

var _contextToElement2 = _interopRequireDefault(_contextToElement);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// see https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter
var filter = function filter(node) {
  if (node.shadowRoot) {
    return NodeFilter.FILTER_ACCEPT;
  }

  return NodeFilter.FILTER_SKIP;
};
// IE requires a function, Browsers require {acceptNode: function}
// see http://www.bennadel.com/blog/2607-finding-html-comment-nodes-in-the-dom-using-treewalker.htm
filter.acceptNode = filter;

function queryShadowHosts() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context;

  var element = (0, _contextToElement2.default)({
    label: 'query/shadow-hosts',
    resolveDocument: true,
    defaultToDocument: true,
    context: context
  });

  var _document = (0, _getDocument2.default)(context);
  // see https://developer.mozilla.org/en-US/docs/Web/API/Document/createTreeWalker
  var walker = _document.createTreeWalker(
  // root element to start search in
  element,
  // element type filter
  NodeFilter.SHOW_ELEMENT,
  // custom NodeFilter filter
  filter,
  // deprecated, but IE requires it
  false);

  var list = [];

  if (element.shadowRoot) {
    // TreeWalker does not run the filter on the context element
    list.push(element);
    list = list.concat(queryShadowHosts({
      context: element.shadowRoot
    }));
  }

  while (walker.nextNode()) {
    list.push(walker.currentNode);
    list = list.concat(queryShadowHosts({
      context: walker.currentNode.shadowRoot
    }));
  }

  return list;
}
module.exports = exports['default'];
//# sourceMappingURL=shadow-hosts.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabbable.js":
/*!************************************************!*\
  !*** ./node_modules/ally.js/query/tabbable.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      strategy = _ref.strategy;

  var _isTabbable = _tabbable2.default.rules.except({
    onlyTabbable: includeOnlyTabbable
  });

  return (0, _focusable2.default)({
    context: context,
    includeContext: includeContext,
    includeOnlyTabbable: includeOnlyTabbable,
    strategy: strategy
  }).filter(_isTabbable);
};

var _focusable = __webpack_require__(/*! ./focusable */ "./node_modules/ally.js/query/focusable.js");

var _focusable2 = _interopRequireDefault(_focusable);

var _tabbable = __webpack_require__(/*! ../is/tabbable */ "./node_modules/ally.js/is/tabbable.js");

var _tabbable2 = _interopRequireDefault(_tabbable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
// https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
// https://www.w3.org/WAI/PF/aria-practices/#keyboard
//# sourceMappingURL=tabbable.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      context = _ref.context,
      includeContext = _ref.includeContext,
      includeOnlyTabbable = _ref.includeOnlyTabbable,
      strategy = _ref.strategy;

  if (!supports) {
    supports = (0, _supports3.default)();
  }

  var _context = (0, _nodeArray2.default)(context)[0] || document.documentElement;
  var elements = (0, _tabbable2.default)({
    context: _context,
    includeContext: includeContext,
    includeOnlyTabbable: includeOnlyTabbable,
    strategy: strategy
  });

  if (document.body.createShadowRoot && _platform2.default.is.BLINK) {
    // sort tabindex localized to shadow dom
    // see https://github.com/medialize/ally.js/issues/6
    elements = (0, _tabsequence4.default)(elements, _context, sortElements);
  } else {
    elements = sortElements(elements, _context);
  }

  if (includeContext) {
    // if we include the context itself, it has to be the first
    // element of the sequence
    elements = moveContextToBeginning(elements, _context);
  }

  return elements;
};

var _tabbable = __webpack_require__(/*! ./tabbable */ "./node_modules/ally.js/query/tabbable.js");

var _tabbable2 = _interopRequireDefault(_tabbable);

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

var _tabsequence = __webpack_require__(/*! ./tabsequence.sort-area */ "./node_modules/ally.js/query/tabsequence.sort-area.js");

var _tabsequence2 = _interopRequireDefault(_tabsequence);

var _tabsequence3 = __webpack_require__(/*! ./tabsequence.sort-shadowed */ "./node_modules/ally.js/query/tabsequence.sort-shadowed.js");

var _tabsequence4 = _interopRequireDefault(_tabsequence3);

var _tabsequence5 = __webpack_require__(/*! ./tabsequence.sort-tabindex */ "./node_modules/ally.js/query/tabsequence.sort-tabindex.js");

var _tabsequence6 = _interopRequireDefault(_tabsequence5);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supports = void 0;
// https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
// https://www.w3.org/WAI/PF/aria-practices/#keyboard

function moveContextToBeginning(elements, context) {
  var pos = elements.indexOf(context);
  if (pos > 0) {
    var tmp = elements.splice(pos, 1);
    return tmp.concat(elements);
  }

  return elements;
}

function sortElements(elements, _context) {
  if (supports.tabsequenceAreaAtImgPosition) {
    // Some browsers sort <area> in DOM order, some place the <area>s
    // where the <img> referecing them would've been in DOM order.
    // https://github.com/medialize/ally.js/issues/5
    elements = (0, _tabsequence2.default)(elements, _context);
  }

  elements = (0, _tabsequence6.default)(elements);
  return elements;
}

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.sort-area.js":
/*!*************************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.sort-area.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
// move <area> elements to the location of the <img> elements that reference them

exports.default = function (elements, context) {
  // images - unless they are focusable themselves, likely not
  // part of the elements list, so we'll have to find them and
  // sort them into the elements list manually
  var usemaps = context.querySelectorAll('img[usemap]');
  var maps = new Maps(context);

  // remove all <area> elements from the elements list,
  // but put them the map for later retrieval
  var _elements = maps.extractAreasFromList(elements);

  if (!usemaps.length) {
    // the context does not contain any <area>s so no need
    // to replace anything, just remove any maps
    return _elements;
  }

  return (0, _mergeDomOrder2.default)({
    list: _elements,
    elements: usemaps,
    resolveElement: function resolveElement(image) {
      var name = image.getAttribute('usemap').slice(1);
      return maps.getAreasFor(name);
    }
  });
};

var _tabbable = __webpack_require__(/*! ./tabbable */ "./node_modules/ally.js/query/tabbable.js");

var _tabbable2 = _interopRequireDefault(_tabbable);

var _mergeDomOrder = __webpack_require__(/*! ../util/merge-dom-order */ "./node_modules/ally.js/util/merge-dom-order.js");

var _mergeDomOrder2 = _interopRequireDefault(_mergeDomOrder);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

var _imageMap = __webpack_require__(/*! ../util/image-map */ "./node_modules/ally.js/util/image-map.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Maps = function () {
  function Maps(context) {
    _classCallCheck(this, Maps);

    this._document = (0, _getDocument2.default)(context);
    this.maps = {};
  }

  _createClass(Maps, [{
    key: 'getAreasFor',
    value: function getAreasFor(name) {
      if (!this.maps[name]) {
        // the map is not defined within the context, so we
        // have to go find it elsewhere in the document
        this.addMapByName(name);
      }

      return this.maps[name];
    }
  }, {
    key: 'addMapByName',
    value: function addMapByName(name) {
      var map = (0, _imageMap.getMapByName)(name, this._document);
      if (!map) {
        // if there is no map, the img[usemap] wasn't doing anything anyway
        return;
      }

      this.maps[map.name] = (0, _tabbable2.default)({ context: map });
    }
  }, {
    key: 'extractAreasFromList',
    value: function extractAreasFromList(elements) {
      // remove all <area> elements from the elements list,
      // but put them the map for later retrieval
      return elements.filter(function (element) {
        var nodeName = element.nodeName.toLowerCase();
        if (nodeName !== 'area') {
          return true;
        }

        var map = element.parentNode;
        if (!this.maps[map.name]) {
          this.maps[map.name] = [];
        }

        this.maps[map.name].push(element);
        return false;
      }, this);
    }
  }]);

  return Maps;
}();

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.sort-area.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.sort-shadowed.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.sort-shadowed.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = function (elements, context, sortElements) {
  var shadows = new Shadows(context, sortElements);
  var _elements = shadows.extractElements(elements);

  if (_elements.length === elements.length) {
    // no shadowed content found, no need to continue
    return sortElements(elements);
  }

  return shadows.sort(_elements);
};

var _shadowHost = __webpack_require__(/*! ../get/shadow-host */ "./node_modules/ally.js/get/shadow-host.js");

var _shadowHost2 = _interopRequireDefault(_shadowHost);

var _mergeDomOrder = __webpack_require__(/*! ../util/merge-dom-order */ "./node_modules/ally.js/util/merge-dom-order.js");

var _mergeDomOrder2 = _interopRequireDefault(_mergeDomOrder);

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Shadows = function () {
  function Shadows(context, sortElements) {
    _classCallCheck(this, Shadows);

    // document context we're working with
    this.context = context;
    // callback that sorts an array of elements
    this.sortElements = sortElements;
    // reference to create unique IDs for each ShadowHost
    this.hostCounter = 1;
    // reference map for child-ShadowHosts of a ShadowHost
    this.inHost = {};
    // reference map for child-ShadowHost of the document
    this.inDocument = [];
    // reference map for ShadowHosts
    this.hosts = {};
    // reference map for tabbable elements of a ShadowHost
    this.elements = {};
  }

  // remember which hosts we have to sort within later


  _createClass(Shadows, [{
    key: '_registerHost',
    value: function _registerHost(host) {
      if (host._sortingId) {
        return;
      }

      // make the ShadowHost identifiable (see cleanup() for undo)
      host._sortingId = 'shadow-' + this.hostCounter++;
      this.hosts[host._sortingId] = host;

      // hosts may contain other hosts
      var parentHost = (0, _shadowHost2.default)({ context: host });
      if (parentHost) {
        this._registerHost(parentHost);
        this._registerHostParent(host, parentHost);
      } else {
        this.inDocument.push(host);
      }
    }

    // remember which host is the child of which other host

  }, {
    key: '_registerHostParent',
    value: function _registerHostParent(host, parent) {
      if (!this.inHost[parent._sortingId]) {
        this.inHost[parent._sortingId] = [];
      }

      this.inHost[parent._sortingId].push(host);
    }

    // remember which elements a host contains

  }, {
    key: '_registerElement',
    value: function _registerElement(element, host) {
      if (!this.elements[host._sortingId]) {
        this.elements[host._sortingId] = [];
      }

      this.elements[host._sortingId].push(element);
    }

    // remove shadowed elements from the sequence and register
    // the ShadowHosts they belong to so we know what to sort
    // later on

  }, {
    key: 'extractElements',
    value: function extractElements(elements) {
      return elements.filter(function (element) {
        var host = (0, _shadowHost2.default)({ context: element });
        if (!host) {
          return true;
        }

        this._registerHost(host);
        this._registerElement(element, host);
        return false;
      }, this);
    }

    // inject hosts into the sequence, sort everything,
    // and recoursively replace hosts by its descendants

  }, {
    key: 'sort',
    value: function sort(elements) {
      var _elements = this._injectHosts(elements);
      _elements = this._replaceHosts(_elements);
      this._cleanup();
      return _elements;
    }

    // merge ShadowHosts into the element lists of other ShadowHosts
    // or the document, then sort the individual lists

  }, {
    key: '_injectHosts',
    value: function _injectHosts(elements) {
      Object.keys(this.hosts).forEach(function (_sortingId) {
        var _list = this.elements[_sortingId];
        var _elements = this.inHost[_sortingId];
        var _context = this.hosts[_sortingId].shadowRoot;
        this.elements[_sortingId] = this._merge(_list, _elements, _context);
      }, this);

      return this._merge(elements, this.inDocument, this.context);
    }
  }, {
    key: '_merge',
    value: function _merge(list, elements, context) {
      var merged = (0, _mergeDomOrder2.default)({
        list: list,
        elements: elements
      });

      return this.sortElements(merged, context);
    }
  }, {
    key: '_replaceHosts',
    value: function _replaceHosts(elements) {
      return (0, _mergeDomOrder2.default)({
        list: elements,
        elements: this.inDocument,
        resolveElement: this._resolveHostElement.bind(this)
      });
    }
  }, {
    key: '_resolveHostElement',
    value: function _resolveHostElement(host) {
      var merged = (0, _mergeDomOrder2.default)({
        list: this.elements[host._sortingId],
        elements: this.inHost[host._sortingId],
        resolveElement: this._resolveHostElement.bind(this)
      });

      var _tabindex = (0, _tabindexValue2.default)(host);
      if (_tabindex !== null && _tabindex > -1) {
        return [host].concat(merged);
      }

      return merged;
    }
  }, {
    key: '_cleanup',
    value: function _cleanup() {
      // remove those identifers we put on the ShadowHost to avoid using Map()
      Object.keys(this.hosts).forEach(function (key) {
        delete this.hosts[key]._sortingId;
      }, this);
    }
  }]);

  return Shadows;
}();

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.sort-shadowed.js.map

/***/ }),

/***/ "./node_modules/ally.js/query/tabsequence.sort-tabindex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/query/tabsequence.sort-tabindex.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (elements) {
  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.tabIndex
  // elements with tabIndex "0" (including tabbableElements without tabIndex) should be navigated in the order they appear.
  // elements with a positive tabIndex:
  //   Elements that have identical tabIndexes should be navigated in the order they appear.
  //   Navigation proceeds from the lowest tabIndex to the highest tabIndex.

  // NOTE: sort implementation may be unstable and thus mess up DOM order,
  // that's why we build a map that's being sorted instead. If we were able to rely
  // on a stable sorting algorithm, sortTabindex() could be as simple as
  // elements.sort(function(a, b) { return a.tabIndex - b.tabIndex; });
  // at this time Chrome does not use a stable sorting algorithm
  // see http://blog.rodneyrehm.de/archives/14-Sorting-Were-Doing-It-Wrong.html#stability

  // NOTE: compareDocumentPosition seemed like more overhead than just sorting this with buckets
  // https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition

  var map = {};
  var indexes = [];
  var normal = elements.filter(function (element) {
    // in Trident and Gecko SVGElement does not know about the tabIndex property
    var tabIndex = element.tabIndex;
    if (tabIndex === undefined) {
      tabIndex = (0, _tabindexValue2.default)(element);
    }

    // extract elements that don't need sorting
    if (tabIndex <= 0 || tabIndex === null || tabIndex === undefined) {
      return true;
    }

    if (!map[tabIndex]) {
      // create sortable bucket for dom-order-preservation of elements with the same tabIndex
      map[tabIndex] = [];
      // maintain a list of unique tabIndexes
      indexes.push(tabIndex);
    }

    // sort element into the proper bucket
    map[tabIndex].push(element);
    // element moved to sorting map, so not "normal" anymore
    return false;
  });

  // sort the tabindex ascending,
  // then resolve them to their appropriate buckets,
  // then flatten the array of arrays to an array
  var _elements = indexes.sort().map(function (tabIndex) {
    return map[tabIndex];
  }).reduceRight(function (previous, current) {
    return current.concat(previous);
  }, normal);

  return _elements;
};

var _tabindexValue = __webpack_require__(/*! ../util/tabindex-value */ "./node_modules/ally.js/util/tabindex-value.js");

var _tabindexValue2 = _interopRequireDefault(_tabindexValue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=tabsequence.sort-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/selector/focusable.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/selector/focusable.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  if (!supports) {
    supports = (0, _supports3.default)();
  }

  if (typeof selector === 'string') {
    return selector;
  }

  // https://www.w3.org/TR/html5/editing.html#sequential-focus-navigation-and-the-tabindex-attribute
  selector = ''
  // IE11 supports.can focus <table> and <td>
  + (supports.focusTable ? 'table, td,' : '')
  // IE11 supports.can focus <fieldset>
  + (supports.focusFieldset ? 'fieldset,' : '')
  // Namespace problems of [xlink:href] explained in https://stackoverflow.com/a/23047888/515124
  // svg a[*|href] does not match in IE9, but since we're filtering
  // through is/focusable we can include all <a> from SVG
  + 'svg a,'
  // may behave as 'svg, svg *,' in chrome as *every* svg element with a focus event listener is focusable
  // navigational elements
  + 'a[href],'
  // validity determined by is/valid-area.js
  + 'area[href],'
  // validity determined by is/disabled.js
  + 'input, select, textarea, button,'
  // browsing context containers
  + 'iframe, object, embed,'
  // interactive content
  + 'keygen,' + (supports.focusAudioWithoutControls ? 'audio,' : 'audio[controls],') + (supports.focusVideoWithoutControls ? 'video,' : 'video[controls],') + (supports.focusSummary ? 'summary,' : '')
  // validity determined by is/valid-tabindex.js
  + '[tabindex],'
  // editing hosts
  + '[contenteditable]';

  // where ShadowDOM is supported, we also want the shadowed focusable elements (via ">>>" or "/deep/")
  selector = (0, _selectInShadows2.default)(selector);

  return selector;
};

var _selectInShadows = __webpack_require__(/*! ../util/select-in-shadows */ "./node_modules/ally.js/util/select-in-shadows.js");

var _selectInShadows2 = _interopRequireDefault(_selectInShadows);

var _supports2 = __webpack_require__(/*! ../supports/supports */ "./node_modules/ally.js/supports/supports.js");

var _supports3 = _interopRequireDefault(_supports2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: this selector MUST *never* be used directly,
// always go through query/focusable or is/focusable.js
// there are too many edge cases that they could be covered in
// a simple CSS selector…

var supports = void 0;

var selector = void 0;

module.exports = exports['default'];
//# sourceMappingURL=focusable.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var combinator = void 0;

  // see https://dev.w3.org/csswg/css-scoping-1/#deep-combinator
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1117572
  // https://code.google.com/p/chromium/issues/detail?id=446051
  try {
    document.querySelector('html >>> :first-child');
    combinator = '>>>';
  } catch (noArrowArrowArrow) {
    try {
      // old syntax supported at least up to Chrome 41
      // https://code.google.com/p/chromium/issues/detail?id=446051
      document.querySelector('html /deep/ :first-child');
      combinator = '/deep/';
    } catch (noDeep) {
      combinator = '';
    }
  }

  return combinator;
};

module.exports = exports['default'];
//# sourceMappingURL=css-shadow-piercing-deep-combinator.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/detect-focus.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/supports/detect-focus.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (tests) {
  var data = before();

  var results = {};
  Object.keys(tests).map(function (key) {
    results[key] = test(data, tests[key]);
  });

  after(data);
  return results;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function before() {
  var data = {
    // remember what had focus to restore after test
    activeElement: document.activeElement,
    // remember scroll positions to restore after test
    windowScrollTop: window.scrollTop,
    windowScrollLeft: window.scrollLeft,
    bodyScrollTop: document.body.scrollTop,
    bodyScrollLeft: document.body.scrollLeft
  };

  // wrap tests in an element hidden from screen readers to prevent them
  // from announcing focus, which can be quite irritating to the user
  var iframe = document.createElement('iframe');
  iframe.setAttribute('style', 'position:absolute; position:fixed; top:0; left:-2px; width:1px; height:1px; overflow:hidden;');
  iframe.setAttribute('aria-live', 'off');
  iframe.setAttribute('aria-busy', 'true');
  iframe.setAttribute('aria-hidden', 'true');
  document.body.appendChild(iframe);

  var _window = iframe.contentWindow;
  var _document = _window.document;

  _document.open();
  _document.close();
  var wrapper = _document.createElement('div');
  _document.body.appendChild(wrapper);

  data.iframe = iframe;
  data.wrapper = wrapper;
  data.window = _window;
  data.document = _document;

  return data;
}

// options.element:
//  {string} element name
//  {function} callback(wrapper, document) to generate an element
// options.mutate: (optional)
//  {function} callback(element, wrapper, document) to manipulate element prior to focus-test.
//             Can return DOMElement to define focus target (default: element)
// options.validate: (optional)
//  {function} callback(element, focusTarget, document) to manipulate test-result
function test(data, options) {
  // make sure we operate on a clean slate
  data.wrapper.innerHTML = '';
  // create dummy element to test focusability of
  var element = typeof options.element === 'string' ? data.document.createElement(options.element) : options.element(data.wrapper, data.document);
  // allow callback to further specify dummy element
  // and optionally define element to focus
  var focus = options.mutate && options.mutate(element, data.wrapper, data.document);
  if (!focus && focus !== false) {
    focus = element;
  }
  // element needs to be part of the DOM to be focusable
  !element.parentNode && data.wrapper.appendChild(element);
  // test if the element with invalid tabindex can be focused
  focus && focus.focus && focus.focus();
  // validate test's result
  return options.validate ? options.validate(element, focus, data.document) : data.document.activeElement === focus;
}

function after(data) {
  // restore focus to what it was before test and cleanup
  if (data.activeElement === document.body) {
    document.activeElement && document.activeElement.blur && document.activeElement.blur();
    if (_platform2.default.is.IE10) {
      // IE10 does not redirect focus to <body> when the activeElement is removed
      document.body.focus();
    }
  } else {
    data.activeElement && data.activeElement.focus && data.activeElement.focus();
  }

  document.body.removeChild(data.iframe);

  // restore scroll position
  window.scrollTop = data.windowScrollTop;
  window.scrollLeft = data.windowScrollLeft;
  document.body.scrollTop = data.bodyScrollTop;
  document.body.scrollLeft = data.bodyScrollLeft;
}

module.exports = exports['default'];
//# sourceMappingURL=detect-focus.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-area-img-tabindex.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-area-img-tabindex.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-tabindex-test">' + '<area shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" tabindex="-1" alt="" src="' + _gif2.default + '">';

    return element.querySelector('area');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-area-img-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-area-tabindex.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-area-tabindex.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-tabindex-test">' + '<area href="#void" tabindex="-1" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" alt="" src="' + _gif2.default + '">';

    return false;
  },
  validate: function validate(element, focusTarget, _document) {
    if (_platform2.default.is.GECKO) {
      // fixes https://github.com/medialize/ally.js/issues/35
      // Firefox loads the DataURI asynchronously, causing a false-negative
      return true;
    }

    var focus = element.querySelector('area');
    focus.focus();
    return _document.activeElement === focus;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-area-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-area-without-href.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-area-without-href.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-area-href-test">' + '<area shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-area-href-test" alt="" src="' + _gif2.default + '">';

    return element.querySelector('area');
  },
  validate: function validate(element, focusTarget, _document) {
    if (_platform2.default.is.GECKO) {
      // fixes https://github.com/medialize/ally.js/issues/35
      // Firefox loads the DataURI asynchronously, causing a false-negative
      return true;
    }

    return _document.activeElement === focusTarget;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-area-without-href.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-audio-without-controls.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-audio-without-controls.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mp = __webpack_require__(/*! ./media/mp3 */ "./node_modules/ally.js/supports/media/mp3.js");

var _mp2 = _interopRequireDefault(_mp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: 'can-focus-audio-without-controls',
  element: 'audio',
  mutate: function mutate(element) {
    try {
      // invalid media file can trigger warning in console, data-uri to prevent HTTP request
      element.setAttribute('src', _mp2.default);
    } catch (e) {
      // IE9 may throw "Error: Not implemented"
    }
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-audio-without-controls.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-broken-image-map.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-broken-image-map.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif.invalid */ "./node_modules/ally.js/supports/media/gif.invalid.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: https://github.com/medialize/ally.js/issues/35
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="broken-image-map-test"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#broken-image-map-test" alt="" src="' + _gif2.default + '">';

    return element.querySelector('area');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-broken-image-map.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-children-of-focusable-flexbox.js":
/*!******************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-children-of-focusable-flexbox.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// Children of focusable elements with display:flex are focusable in IE10-11
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', '-1');
    element.setAttribute('style', 'display: -webkit-flex; display: -ms-flexbox; display: flex;');
    element.innerHTML = '<span style="display: block;">hello</span>';
    return element.querySelector('span');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-children-of-focusable-flexbox.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-fieldset-disabled.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-fieldset-disabled.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// fieldset[tabindex=0][disabled] should not be focusable, but Blink and WebKit disagree
// @specification https://www.w3.org/TR/html5/disabled-elements.html#concept-element-disabled
// @browser-issue Chromium https://crbug.com/453847
// @browser-issue WebKit https://bugs.webkit.org/show_bug.cgi?id=141086
exports.default = {
  element: 'fieldset',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', 0);
    element.setAttribute('disabled', 'disabled');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-fieldset-disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-fieldset.js":
/*!*********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-fieldset.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'fieldset',
  mutate: function mutate(element) {
    element.innerHTML = '<legend>legend</legend><p>content</p>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-fieldset.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-flexbox-container.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-flexbox-container.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// elements with display:flex are focusable in IE10-11
exports.default = {
  element: 'span',
  mutate: function mutate(element) {
    element.setAttribute('style', 'display: -webkit-flex; display: -ms-flexbox; display: flex;');
    element.innerHTML = '<span style="display: block;">hello</span>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-flexbox-container.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-form-disabled.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-form-disabled.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// form[tabindex=0][disabled] should be focusable as the
// specification doesn't know the disabled attribute on the form element
// @specification https://www.w3.org/TR/html5/forms.html#the-form-element
exports.default = {
  element: 'form',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', 0);
    element.setAttribute('disabled', 'disabled');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-form-disabled.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-img-ismap.js":
/*!**********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-img-ismap.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: https://github.com/medialize/ally.js/issues/35
// fixes https://github.com/medialize/ally.js/issues/20
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-ismap
exports.default = {
  element: 'a',
  mutate: function mutate(element) {
    element.href = '#void';
    element.innerHTML = '<img ismap src="' + _gif2.default + '" alt="">';
    return element.querySelector('img');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-img-ismap.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-img-usemap-tabindex.js":
/*!********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-img-usemap-tabindex.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// NOTE: https://github.com/medialize/ally.js/issues/35
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-usemap
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="image-map-tabindex-test"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#image-map-tabindex-test" tabindex="-1" alt="" ' + 'src="' + _gif2.default + '">';

    return element.querySelector('img');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-img-usemap-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-in-hidden-iframe.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-in-hidden-iframe.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: function element(wrapper, _document) {
    var iframe = _document.createElement('iframe');

    // iframe must be part of the DOM before accessing the contentWindow is possible
    wrapper.appendChild(iframe);

    // create the iframe's default document (<html><head></head><body></body></html>)
    var iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.close();
    return iframe;
  },
  mutate: function mutate(iframe) {
    iframe.style.visibility = 'hidden';

    var iframeDocument = iframe.contentWindow.document;
    var input = iframeDocument.createElement('input');
    iframeDocument.body.appendChild(input);
    return input;
  },
  validate: function validate(iframe) {
    var iframeDocument = iframe.contentWindow.document;
    var focus = iframeDocument.querySelector('input');
    return iframeDocument.activeElement === focus;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-in-hidden-iframe.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-in-zero-dimension-object.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-in-zero-dimension-object.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var result = !_platform2.default.is.WEBKIT;

module.exports = exports['default'];
//# sourceMappingURL=focus-in-zero-dimension-object.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-invalid-tabindex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-invalid-tabindex.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// Firefox allows *any* value and treats invalid values like tabindex="-1"
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', 'invalid-value');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-invalid-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-label-tabindex.js":
/*!***************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-label-tabindex.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'label',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', '-1');
  },
  validate: function validate(element, focusTarget, _document) {
    // force layout in Chrome 49, otherwise the element won't be focusable
    /* eslint-disable no-unused-vars */
    var variableToPreventDeadCodeElimination = element.offsetHeight;
    /* eslint-enable no-unused-vars */
    element.focus();
    return _document.activeElement === element;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-label-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-object-svg-hidden.js":
/*!******************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-object-svg-hidden.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./media/svg */ "./node_modules/ally.js/supports/media/svg.js");

var _svg2 = _interopRequireDefault(_svg);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Note: IE10 on BrowserStack does not like this test

exports.default = {
  element: 'object',
  mutate: function mutate(element) {
    element.setAttribute('type', 'image/svg+xml');
    element.setAttribute('data', _svg2.default);
    element.setAttribute('width', '200');
    element.setAttribute('height', '50');
    element.style.visibility = 'hidden';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-object-svg-hidden.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-object-svg.js":
/*!***********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-object-svg.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./media/svg */ "./node_modules/ally.js/supports/media/svg.js");

var _svg2 = _interopRequireDefault(_svg);

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Note: IE10 on BrowserStack does not like this test

exports.default = {
  name: 'can-focus-object-svg',
  element: 'object',
  mutate: function mutate(element) {
    element.setAttribute('type', 'image/svg+xml');
    element.setAttribute('data', _svg2.default);
    element.setAttribute('width', '200');
    element.setAttribute('height', '50');
  },
  validate: function validate(element, focusTarget, _document) {
    if (_platform2.default.is.GECKO) {
      // Firefox seems to be handling the object creation asynchronously and thereby produces a false negative test result.
      // Because we know Firefox is able to focus object elements referencing SVGs, we simply cheat by sniffing the user agent string
      return true;
    }

    return _document.activeElement === element;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-object-svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-object-swf.js":
/*!***********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-object-swf.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Every Environment except IE9 considers SWF objects focusable
var result = !_platform2.default.is.IE9;

module.exports = exports['default'];
//# sourceMappingURL=focus-object-swf.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-redirect-img-usemap.js":
/*!********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-redirect-img-usemap.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./media/gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = '<map name="focus-redirect-img-usemap"><area href="#void" shape="rect" coords="63,19,144,45"></map>' + '<img usemap="#focus-redirect-img-usemap" alt="" ' + 'src="' + _gif2.default + '">';

    // focus the <img>, not the <div>
    return element.querySelector('img');
  },
  validate: function validate(element, focusTarget, _document) {
    var target = element.querySelector('area');
    return _document.activeElement === target;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-redirect-img-usemap.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-redirect-legend.js":
/*!****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-redirect-legend.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// see https://jsbin.com/nenirisage/edit?html,js,console,output

exports.default = {
  element: 'fieldset',
  mutate: function mutate(element) {
    element.innerHTML = '<legend>legend</legend><input tabindex="-1"><input tabindex="0">';
    // take care of focus in validate();
    return false;
  },
  validate: function validate(element, focusTarget, _document) {
    var focusable = element.querySelector('input[tabindex="-1"]');
    var tabbable = element.querySelector('input[tabindex="0"]');

    // Firefox requires this test to focus the <fieldset> first, while this is not necessary in
    // https://jsbin.com/nenirisage/edit?html,js,console,output
    element.focus();

    element.querySelector('legend').focus();
    return _document.activeElement === focusable && 'focusable' || _document.activeElement === tabbable && 'tabbable' || '';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-redirect-legend.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-scroll-body.js":
/*!************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-scroll-body.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// https://github.com/medialize/ally.js/issues/21
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('style', 'width: 100px; height: 50px; overflow: auto;');
    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
    return element.querySelector('div');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-scroll-body.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-scroll-container-without-overflow.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-scroll-container-without-overflow.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// https://github.com/medialize/ally.js/issues/21
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('style', 'width: 100px; height: 50px;');
    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-scroll-container-without-overflow.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-scroll-container.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-scroll-container.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// https://github.com/medialize/ally.js/issues/21
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('style', 'width: 100px; height: 50px; overflow: auto;');
    element.innerHTML = '<div style="width: 500px; height: 40px;">scrollable content</div>';
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-scroll-container.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-summary.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-summary.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'details',
  mutate: function mutate(element) {
    element.innerHTML = '<summary>foo</summary><p>content</p>';
    return element.firstElementChild;
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-summary.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-focusable-attribute.js":
/*!************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-focusable-attribute.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<text focusable="true">a</text>');
    return element.querySelector('text');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-focusable-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-foreignobject-tabindex.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-foreignobject-tabindex.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<foreignObject tabindex="-1"><input type="text" /></foreignObject>');
    // Safari 8's quersSelector() can't identify foreignObject, but getElementyByTagName() can
    return element.querySelector('foreignObject') || element.getElementsByTagName('foreignObject')[0];
  },
  validate: _svg.validate

};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-foreignobject-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-in-iframe.js":
/*!**************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-in-iframe.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Firefox seems to be handling the SVG-document-in-iframe creation asynchronously
// and thereby produces a false negative test result. Thus the test is pointless
// and we resort to UA sniffing once again.
// see http://jsbin.com/vunadohoko/1/edit?js,console,output

var result = Boolean(_platform2.default.is.GECKO && typeof SVGElement !== 'undefined' && SVGElement.prototype.focus);

module.exports = exports['default'];
//# sourceMappingURL=focus-svg-in-iframe.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-negative-tabindex-attribute.js":
/*!********************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-negative-tabindex-attribute.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<text tabindex="-1">a</text>');
    return element.querySelector('text');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-negative-tabindex-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-tabindex-attribute.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-tabindex-attribute.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('<text tabindex="0">a</text>');
    return element.querySelector('text');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-tabindex-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg-use-tabindex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg-use-tabindex.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)(['<g id="ally-test-target"><a xlink:href="#void"><text>link</text></a></g>', '<use xlink:href="#ally-test-target" x="0" y="0" tabindex="-1" />'].join(''));

    return element.querySelector('use');
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg-use-tabindex.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-svg.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-svg.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svg = __webpack_require__(/*! ./helper/svg */ "./node_modules/ally.js/supports/helper/svg.js");

exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.innerHTML = (0, _svg.generate)('');
    return element.firstChild;
  },
  validate: _svg.validate
};
module.exports = exports['default'];
//# sourceMappingURL=focus-svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-tabindex-trailing-characters.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-tabindex-trailing-characters.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// Firefox allows *any* value and treats invalid values like tabindex="-1"
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
exports.default = {
  element: 'div',
  mutate: function mutate(element) {
    element.setAttribute('tabindex', '3x');
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-tabindex-trailing-characters.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-table.js":
/*!******************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-table.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  element: 'table',
  mutate: function mutate(element, wrapper, _document) {
    // IE9 has a problem replacing TBODY contents with innerHTML.
    // https://stackoverflow.com/a/8097055/515124
    // element.innerHTML = '<tr><td>cell</td></tr>';
    var fragment = _document.createDocumentFragment();
    fragment.innerHTML = '<tr><td>cell</td></tr>';
    element.appendChild(fragment);
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-table.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/focus-video-without-controls.js":
/*!***********************************************************************!*\
  !*** ./node_modules/ally.js/supports/focus-video-without-controls.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mp = __webpack_require__(/*! ./media/mp4 */ "./node_modules/ally.js/supports/media/mp4.js");

var _mp2 = _interopRequireDefault(_mp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  element: 'video',
  mutate: function mutate(element) {
    try {
      // invalid media file can trigger warning in console, data-uri to prevent HTTP request
      element.setAttribute('src', _mp2.default);
    } catch (e) {
      // IE9 may throw "Error: Not implemented"
    }
  }
};
module.exports = exports['default'];
//# sourceMappingURL=focus-video-without-controls.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/helper/svg.js":
/*!*****************************************************!*\
  !*** ./node_modules/ally.js/supports/helper/svg.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generate = generate;
exports.focus = focus;
exports.validate = validate;

var _focus = __webpack_require__(/*! ../../element/focus.svg-foreign-object-hack */ "./node_modules/ally.js/element/focus.svg-foreign-object-hack.js");

var _focus2 = _interopRequireDefault(_focus);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function generate(element) {
  return '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">' + element + '</svg>';
}

function focus(element) {
  if (element.focus) {
    return;
  }

  try {
    HTMLElement.prototype.focus.call(element);
  } catch (e) {
    (0, _focus2.default)(element);
  }
}

function validate(element, focusTarget, _document) {
  focus(focusTarget);
  return _document.activeElement === focusTarget;
}
//# sourceMappingURL=svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/gif.invalid.js":
/*!************************************************************!*\
  !*** ./node_modules/ally.js/supports/media/gif.invalid.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ';
module.exports = exports['default'];
//# sourceMappingURL=gif.invalid.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/gif.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/gif.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
module.exports = exports['default'];
//# sourceMappingURL=gif.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/mp3.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/mp3.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _gif2.default;
// export default 'data:audio/mp3;base64,audio-focus-test';

module.exports = exports['default'];
//# sourceMappingURL=mp3.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/mp4.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/mp4.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _gif = __webpack_require__(/*! ./gif */ "./node_modules/ally.js/supports/media/gif.js");

var _gif2 = _interopRequireDefault(_gif);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _gif2.default;
// export default 'data:video/mp4;base64,video-focus-test';

module.exports = exports['default'];
//# sourceMappingURL=mp4.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/media/svg.js":
/*!****************************************************!*\
  !*** ./node_modules/ally.js/supports/media/svg.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtb' + 'G5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0ic3ZnIj48dGV4dCB4PSIxMCIgeT0iMjAiIGlkPSJ' + 'zdmctbGluay10ZXh0Ij50ZXh0PC90ZXh0Pjwvc3ZnPg==';
module.exports = exports['default'];
//# sourceMappingURL=svg.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/supports-cache.js":
/*!*********************************************************!*\
  !*** ./node_modules/ally.js/supports/supports-cache.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _version = __webpack_require__(/*! ../version */ "./node_modules/ally.js/version.js");

var _version2 = _interopRequireDefault(_version);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function readLocalStorage(key) {
  // allow reading from storage to retrieve previous support results
  // even while the document does not have focus
  var data = void 0;

  try {
    data = window.localStorage && window.localStorage.getItem(key);
    data = data ? JSON.parse(data) : {};
  } catch (e) {
    data = {};
  }

  return data;
} /*
      Facility to cache test results in localStorage.
  
      USAGE:
        cache.get('key');
        cache.set('key', 'value');
   */

function writeLocalStorage(key, value) {
  if (!document.hasFocus()) {
    // if the document does not have focus when tests are executed, focus() may
    // not be handled properly and events may not be dispatched immediately.
    // This can happen when a document is reloaded while Developer Tools have focus.
    try {
      window.localStorage && window.localStorage.removeItem(key);
    } catch (e) {
      // ignore
    }

    return;
  }

  try {
    window.localStorage && window.localStorage.setItem(key, JSON.stringify(value));
  } catch (e) {
    // ignore
  }
}

var userAgent = typeof window !== 'undefined' && window.navigator.userAgent || '';
var cacheKey = 'ally-supports-cache';
var cache = readLocalStorage(cacheKey);

// update the cache if ally or the user agent changed (newer version, etc)
if (cache.userAgent !== userAgent || cache.version !== _version2.default) {
  cache = {};
}

cache.userAgent = userAgent;
cache.version = _version2.default;

exports.default = {
  get: function get() {
    return cache;
  },
  set: function set(values) {
    Object.keys(values).forEach(function (key) {
      cache[key] = values[key];
    });

    cache.time = new Date().toISOString();
    writeLocalStorage(cacheKey, cache);
  }
};
module.exports = exports['default'];
//# sourceMappingURL=supports-cache.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/supports.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/supports/supports.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  if (supportsCache) {
    return supportsCache;
  }

  supportsCache = _supportsCache2.default.get();
  if (!supportsCache.time) {
    _supportsCache2.default.set(executeTests());
    supportsCache = _supportsCache2.default.get();
  }

  return supportsCache;
};

var _detectFocus = __webpack_require__(/*! ./detect-focus */ "./node_modules/ally.js/supports/detect-focus.js");

var _detectFocus2 = _interopRequireDefault(_detectFocus);

var _supportsCache = __webpack_require__(/*! ./supports-cache */ "./node_modules/ally.js/supports/supports-cache.js");

var _supportsCache2 = _interopRequireDefault(_supportsCache);

var _cssShadowPiercingDeepCombinator = __webpack_require__(/*! ./css-shadow-piercing-deep-combinator */ "./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js");

var _cssShadowPiercingDeepCombinator2 = _interopRequireDefault(_cssShadowPiercingDeepCombinator);

var _focusAreaImgTabindex = __webpack_require__(/*! ./focus-area-img-tabindex */ "./node_modules/ally.js/supports/focus-area-img-tabindex.js");

var _focusAreaImgTabindex2 = _interopRequireDefault(_focusAreaImgTabindex);

var _focusAreaTabindex = __webpack_require__(/*! ./focus-area-tabindex */ "./node_modules/ally.js/supports/focus-area-tabindex.js");

var _focusAreaTabindex2 = _interopRequireDefault(_focusAreaTabindex);

var _focusAreaWithoutHref = __webpack_require__(/*! ./focus-area-without-href */ "./node_modules/ally.js/supports/focus-area-without-href.js");

var _focusAreaWithoutHref2 = _interopRequireDefault(_focusAreaWithoutHref);

var _focusAudioWithoutControls = __webpack_require__(/*! ./focus-audio-without-controls */ "./node_modules/ally.js/supports/focus-audio-without-controls.js");

var _focusAudioWithoutControls2 = _interopRequireDefault(_focusAudioWithoutControls);

var _focusBrokenImageMap = __webpack_require__(/*! ./focus-broken-image-map */ "./node_modules/ally.js/supports/focus-broken-image-map.js");

var _focusBrokenImageMap2 = _interopRequireDefault(_focusBrokenImageMap);

var _focusChildrenOfFocusableFlexbox = __webpack_require__(/*! ./focus-children-of-focusable-flexbox */ "./node_modules/ally.js/supports/focus-children-of-focusable-flexbox.js");

var _focusChildrenOfFocusableFlexbox2 = _interopRequireDefault(_focusChildrenOfFocusableFlexbox);

var _focusFieldsetDisabled = __webpack_require__(/*! ./focus-fieldset-disabled */ "./node_modules/ally.js/supports/focus-fieldset-disabled.js");

var _focusFieldsetDisabled2 = _interopRequireDefault(_focusFieldsetDisabled);

var _focusFieldset = __webpack_require__(/*! ./focus-fieldset */ "./node_modules/ally.js/supports/focus-fieldset.js");

var _focusFieldset2 = _interopRequireDefault(_focusFieldset);

var _focusFlexboxContainer = __webpack_require__(/*! ./focus-flexbox-container */ "./node_modules/ally.js/supports/focus-flexbox-container.js");

var _focusFlexboxContainer2 = _interopRequireDefault(_focusFlexboxContainer);

var _focusFormDisabled = __webpack_require__(/*! ./focus-form-disabled */ "./node_modules/ally.js/supports/focus-form-disabled.js");

var _focusFormDisabled2 = _interopRequireDefault(_focusFormDisabled);

var _focusImgIsmap = __webpack_require__(/*! ./focus-img-ismap */ "./node_modules/ally.js/supports/focus-img-ismap.js");

var _focusImgIsmap2 = _interopRequireDefault(_focusImgIsmap);

var _focusImgUsemapTabindex = __webpack_require__(/*! ./focus-img-usemap-tabindex */ "./node_modules/ally.js/supports/focus-img-usemap-tabindex.js");

var _focusImgUsemapTabindex2 = _interopRequireDefault(_focusImgUsemapTabindex);

var _focusInHiddenIframe = __webpack_require__(/*! ./focus-in-hidden-iframe */ "./node_modules/ally.js/supports/focus-in-hidden-iframe.js");

var _focusInHiddenIframe2 = _interopRequireDefault(_focusInHiddenIframe);

var _focusInZeroDimensionObject = __webpack_require__(/*! ./focus-in-zero-dimension-object */ "./node_modules/ally.js/supports/focus-in-zero-dimension-object.js");

var _focusInZeroDimensionObject2 = _interopRequireDefault(_focusInZeroDimensionObject);

var _focusInvalidTabindex = __webpack_require__(/*! ./focus-invalid-tabindex */ "./node_modules/ally.js/supports/focus-invalid-tabindex.js");

var _focusInvalidTabindex2 = _interopRequireDefault(_focusInvalidTabindex);

var _focusLabelTabindex = __webpack_require__(/*! ./focus-label-tabindex */ "./node_modules/ally.js/supports/focus-label-tabindex.js");

var _focusLabelTabindex2 = _interopRequireDefault(_focusLabelTabindex);

var _focusObjectSvgHidden = __webpack_require__(/*! ./focus-object-svg-hidden */ "./node_modules/ally.js/supports/focus-object-svg-hidden.js");

var _focusObjectSvgHidden2 = _interopRequireDefault(_focusObjectSvgHidden);

var _focusObjectSvg = __webpack_require__(/*! ./focus-object-svg */ "./node_modules/ally.js/supports/focus-object-svg.js");

var _focusObjectSvg2 = _interopRequireDefault(_focusObjectSvg);

var _focusObjectSwf = __webpack_require__(/*! ./focus-object-swf */ "./node_modules/ally.js/supports/focus-object-swf.js");

var _focusObjectSwf2 = _interopRequireDefault(_focusObjectSwf);

var _focusRedirectImgUsemap = __webpack_require__(/*! ./focus-redirect-img-usemap */ "./node_modules/ally.js/supports/focus-redirect-img-usemap.js");

var _focusRedirectImgUsemap2 = _interopRequireDefault(_focusRedirectImgUsemap);

var _focusRedirectLegend = __webpack_require__(/*! ./focus-redirect-legend */ "./node_modules/ally.js/supports/focus-redirect-legend.js");

var _focusRedirectLegend2 = _interopRequireDefault(_focusRedirectLegend);

var _focusScrollBody = __webpack_require__(/*! ./focus-scroll-body */ "./node_modules/ally.js/supports/focus-scroll-body.js");

var _focusScrollBody2 = _interopRequireDefault(_focusScrollBody);

var _focusScrollContainerWithoutOverflow = __webpack_require__(/*! ./focus-scroll-container-without-overflow */ "./node_modules/ally.js/supports/focus-scroll-container-without-overflow.js");

var _focusScrollContainerWithoutOverflow2 = _interopRequireDefault(_focusScrollContainerWithoutOverflow);

var _focusScrollContainer = __webpack_require__(/*! ./focus-scroll-container */ "./node_modules/ally.js/supports/focus-scroll-container.js");

var _focusScrollContainer2 = _interopRequireDefault(_focusScrollContainer);

var _focusSummary = __webpack_require__(/*! ./focus-summary */ "./node_modules/ally.js/supports/focus-summary.js");

var _focusSummary2 = _interopRequireDefault(_focusSummary);

var _focusSvgFocusableAttribute = __webpack_require__(/*! ./focus-svg-focusable-attribute */ "./node_modules/ally.js/supports/focus-svg-focusable-attribute.js");

var _focusSvgFocusableAttribute2 = _interopRequireDefault(_focusSvgFocusableAttribute);

var _focusSvgTabindexAttribute = __webpack_require__(/*! ./focus-svg-tabindex-attribute */ "./node_modules/ally.js/supports/focus-svg-tabindex-attribute.js");

var _focusSvgTabindexAttribute2 = _interopRequireDefault(_focusSvgTabindexAttribute);

var _focusSvgNegativeTabindexAttribute = __webpack_require__(/*! ./focus-svg-negative-tabindex-attribute */ "./node_modules/ally.js/supports/focus-svg-negative-tabindex-attribute.js");

var _focusSvgNegativeTabindexAttribute2 = _interopRequireDefault(_focusSvgNegativeTabindexAttribute);

var _focusSvgUseTabindex = __webpack_require__(/*! ./focus-svg-use-tabindex */ "./node_modules/ally.js/supports/focus-svg-use-tabindex.js");

var _focusSvgUseTabindex2 = _interopRequireDefault(_focusSvgUseTabindex);

var _focusSvgForeignobjectTabindex = __webpack_require__(/*! ./focus-svg-foreignobject-tabindex */ "./node_modules/ally.js/supports/focus-svg-foreignobject-tabindex.js");

var _focusSvgForeignobjectTabindex2 = _interopRequireDefault(_focusSvgForeignobjectTabindex);

var _focusSvgInIframe = __webpack_require__(/*! ./focus-svg-in-iframe */ "./node_modules/ally.js/supports/focus-svg-in-iframe.js");

var _focusSvgInIframe2 = _interopRequireDefault(_focusSvgInIframe);

var _focusSvg = __webpack_require__(/*! ./focus-svg */ "./node_modules/ally.js/supports/focus-svg.js");

var _focusSvg2 = _interopRequireDefault(_focusSvg);

var _focusTabindexTrailingCharacters = __webpack_require__(/*! ./focus-tabindex-trailing-characters */ "./node_modules/ally.js/supports/focus-tabindex-trailing-characters.js");

var _focusTabindexTrailingCharacters2 = _interopRequireDefault(_focusTabindexTrailingCharacters);

var _focusTable = __webpack_require__(/*! ./focus-table */ "./node_modules/ally.js/supports/focus-table.js");

var _focusTable2 = _interopRequireDefault(_focusTable);

var _focusVideoWithoutControls = __webpack_require__(/*! ./focus-video-without-controls */ "./node_modules/ally.js/supports/focus-video-without-controls.js");

var _focusVideoWithoutControls2 = _interopRequireDefault(_focusVideoWithoutControls);

var _tabsequenceAreaAtImgPosition = __webpack_require__(/*! ./tabsequence-area-at-img-position */ "./node_modules/ally.js/supports/tabsequence-area-at-img-position.js");

var _tabsequenceAreaAtImgPosition2 = _interopRequireDefault(_tabsequenceAreaAtImgPosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var testCallbacks = {
  cssShadowPiercingDeepCombinator: _cssShadowPiercingDeepCombinator2.default,
  focusInZeroDimensionObject: _focusInZeroDimensionObject2.default,
  focusObjectSwf: _focusObjectSwf2.default,
  focusSvgInIframe: _focusSvgInIframe2.default,
  tabsequenceAreaAtImgPosition: _tabsequenceAreaAtImgPosition2.default
};

var testDescriptions = {
  focusAreaImgTabindex: _focusAreaImgTabindex2.default,
  focusAreaTabindex: _focusAreaTabindex2.default,
  focusAreaWithoutHref: _focusAreaWithoutHref2.default,
  focusAudioWithoutControls: _focusAudioWithoutControls2.default,
  focusBrokenImageMap: _focusBrokenImageMap2.default,
  focusChildrenOfFocusableFlexbox: _focusChildrenOfFocusableFlexbox2.default,
  focusFieldsetDisabled: _focusFieldsetDisabled2.default,
  focusFieldset: _focusFieldset2.default,
  focusFlexboxContainer: _focusFlexboxContainer2.default,
  focusFormDisabled: _focusFormDisabled2.default,
  focusImgIsmap: _focusImgIsmap2.default,
  focusImgUsemapTabindex: _focusImgUsemapTabindex2.default,
  focusInHiddenIframe: _focusInHiddenIframe2.default,
  focusInvalidTabindex: _focusInvalidTabindex2.default,
  focusLabelTabindex: _focusLabelTabindex2.default,
  focusObjectSvg: _focusObjectSvg2.default,
  focusObjectSvgHidden: _focusObjectSvgHidden2.default,
  focusRedirectImgUsemap: _focusRedirectImgUsemap2.default,
  focusRedirectLegend: _focusRedirectLegend2.default,
  focusScrollBody: _focusScrollBody2.default,
  focusScrollContainerWithoutOverflow: _focusScrollContainerWithoutOverflow2.default,
  focusScrollContainer: _focusScrollContainer2.default,
  focusSummary: _focusSummary2.default,
  focusSvgFocusableAttribute: _focusSvgFocusableAttribute2.default,
  focusSvgTabindexAttribute: _focusSvgTabindexAttribute2.default,
  focusSvgNegativeTabindexAttribute: _focusSvgNegativeTabindexAttribute2.default,
  focusSvgUseTabindex: _focusSvgUseTabindex2.default,
  focusSvgForeignobjectTabindex: _focusSvgForeignobjectTabindex2.default,
  focusSvg: _focusSvg2.default,
  focusTabindexTrailingCharacters: _focusTabindexTrailingCharacters2.default,
  focusTable: _focusTable2.default,
  focusVideoWithoutControls: _focusVideoWithoutControls2.default
};

function executeTests() {
  var results = (0, _detectFocus2.default)(testDescriptions);
  Object.keys(testCallbacks).forEach(function (key) {
    results[key] = testCallbacks[key]();
  });

  return results;
}

var supportsCache = null;

module.exports = exports['default'];
//# sourceMappingURL=supports.js.map

/***/ }),

/***/ "./node_modules/ally.js/supports/tabsequence-area-at-img-position.js":
/*!***************************************************************************!*\
  !*** ./node_modules/ally.js/supports/tabsequence-area-at-img-position.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  return result;
};

var _platform = __webpack_require__(/*! ../util/platform */ "./node_modules/ally.js/util/platform.js");

var _platform2 = _interopRequireDefault(_platform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// https://jsbin.com/vafaba/3/edit?html,js,console,output
var result = _platform2.default.is.GECKO || _platform2.default.is.TRIDENT || _platform2.default.is.EDGE;

module.exports = exports['default'];
//# sourceMappingURL=tabsequence-area-at-img-position.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/array-find-index.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/util/array-find-index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = findIndex;
function findIndex(array, callback) {
  // attempt to use native or polyfilled Array#findIndex first
  if (array.findIndex) {
    return array.findIndex(callback);
  }

  var length = array.length;

  // shortcut if the array is empty
  if (length === 0) {
    return -1;
  }

  // otherwise loop over array
  for (var i = 0; i < length; i++) {
    if (callback(array[i], i, array)) {
      return i;
    }
  }

  return -1;
}
module.exports = exports["default"];
//# sourceMappingURL=array-find-index.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/compare-position.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/util/compare-position.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getParentComparator = getParentComparator;

// Node.compareDocumentPosition is available since IE9
// see https://developer.mozilla.org/en-US/docs/Web/API/Node.compareDocumentPosition

// callback returns true when element is contained by parent or is the parent suited for use with Array.some()
/*
  USAGE:
    var isChildOf = getParentComparator({parent: someNode});
    listOfElements.some(isChildOf)
*/

function getParentComparator() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      parent = _ref.parent,
      element = _ref.element,
      includeSelf = _ref.includeSelf;

  if (parent) {
    return function isChildOf(node) {
      return Boolean(includeSelf && node === parent || parent.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY);
    };
  } else if (element) {
    return function isParentOf(node) {
      return Boolean(includeSelf && element === node || node.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_CONTAINED_BY);
    };
  }

  throw new TypeError('util/compare-position#getParentComparator required either options.parent or options.element');
}
//# sourceMappingURL=compare-position.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/context-to-element.js":
/*!*********************************************************!*\
  !*** ./node_modules/ally.js/util/context-to-element.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var context = _ref.context,
      _ref$label = _ref.label,
      label = _ref$label === undefined ? 'context-to-element' : _ref$label,
      resolveDocument = _ref.resolveDocument,
      defaultToDocument = _ref.defaultToDocument;

  var element = (0, _nodeArray2.default)(context)[0];

  if (resolveDocument && element && element.nodeType === Node.DOCUMENT_NODE) {
    element = element.documentElement;
  }

  if (!element && defaultToDocument) {
    return document.documentElement;
  }

  if (!element) {
    throw new TypeError(label + ' requires valid options.context');
  }

  if (element.nodeType !== Node.ELEMENT_NODE && element.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
    throw new TypeError(label + ' requires options.context to be an Element');
  }

  return element;
};

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=context-to-element.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/element-matches.js":
/*!******************************************************!*\
  !*** ./node_modules/ally.js/util/element-matches.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = elementMatches;

// Element.prototype.matches may be available at a different name
// https://developer.mozilla.org/en/docs/Web/API/Element/matches

var names = ['matches', 'webkitMatchesSelector', 'mozMatchesSelector', 'msMatchesSelector'];
var name = null;

function findMethodName(element) {
  names.some(function (_name) {
    if (!element[_name]) {
      return false;
    }

    name = _name;
    return true;
  });
}

function elementMatches(element, selector) {
  if (!name) {
    findMethodName(element);
  }

  return element[name](selector);
}
module.exports = exports['default'];
//# sourceMappingURL=element-matches.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-content-document.js":
/*!***********************************************************!*\
  !*** ./node_modules/ally.js/util/get-content-document.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  try {
    // works on <object> and <iframe>
    return node.contentDocument
    // works on <object> and <iframe>
    || node.contentWindow && node.contentWindow.document
    // works on <object> and <iframe> that contain SVG
    || node.getSVGDocument && node.getSVGDocument() || null;
  } catch (e) {
    // SecurityError: Failed to read the 'contentDocument' property from 'HTMLObjectElement'
    // also IE may throw member not found exception e.g. on <object type="image/png">
    return null;
  }
};

module.exports = exports["default"];
//# sourceMappingURL=get-content-document.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-document.js":
/*!***************************************************!*\
  !*** ./node_modules/ally.js/util/get-document.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  if (!node) {
    return document;
  }

  if (node.nodeType === Node.DOCUMENT_NODE) {
    return node;
  }

  return node.ownerDocument || document;
};

module.exports = exports["default"];
//# sourceMappingURL=get-document.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-frame-element.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/util/get-frame-element.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getFrameElement;

var _getContentDocument = __webpack_require__(/*! ./get-content-document */ "./node_modules/ally.js/util/get-content-document.js");

var _getContentDocument2 = _interopRequireDefault(_getContentDocument);

var _getWindow = __webpack_require__(/*! ./get-window */ "./node_modules/ally.js/util/get-window.js");

var _getWindow2 = _interopRequireDefault(_getWindow);

var _selectInShadows = __webpack_require__(/*! ./select-in-shadows */ "./node_modules/ally.js/util/select-in-shadows.js");

var _selectInShadows2 = _interopRequireDefault(_selectInShadows);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var selector = void 0;

function findDocumentHostElement(_window) {
  if (!selector) {
    selector = (0, _selectInShadows2.default)('object, iframe');
  }

  if (_window._frameElement !== undefined) {
    return _window._frameElement;
  }

  _window._frameElement = null;

  var potentialHosts = _window.parent.document.querySelectorAll(selector);
  [].some.call(potentialHosts, function (element) {
    var _document = (0, _getContentDocument2.default)(element);
    if (_document !== _window.document) {
      return false;
    }

    _window._frameElement = element;
    return true;
  });

  return _window._frameElement;
}

function getFrameElement(element) {
  var _window = (0, _getWindow2.default)(element);
  if (!_window.parent || _window.parent === _window) {
    // if there is no parent browsing context,
    // we're not going to get a frameElement either way
    return null;
  }

  try {
    // see https://developer.mozilla.org/en-US/docs/Web/API/Window/frameElement
    // does not work within <embed> anywhere, and not within in <object> in IE
    return _window.frameElement || findDocumentHostElement(_window);
  } catch (e) {
    return null;
  }
}
module.exports = exports['default'];
//# sourceMappingURL=get-frame-element.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/get-window.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/util/get-window.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node) {
  var _document = (0, _getDocument2.default)(node);
  return _document.defaultView || window;
};

var _getDocument = __webpack_require__(/*! ./get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=get-window.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/image-map.js":
/*!************************************************!*\
  !*** ./node_modules/ally.js/util/image-map.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMapByName = getMapByName;
exports.getMapOfImage = getMapOfImage;
exports.getImageOfArea = getImageOfArea;

var _css = __webpack_require__(/*! css.escape */ "./node_modules/css.escape/css.escape.js");

var _css2 = _interopRequireDefault(_css);

var _getDocument = __webpack_require__(/*! ../util/get-document */ "./node_modules/ally.js/util/get-document.js");

var _getDocument2 = _interopRequireDefault(_getDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getMapByName(name, _document) {
  // apparently getElementsByName() also considers id attribute in IE & opera
  // https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
  var map = _document.querySelector('map[name="' + (0, _css2.default)(name) + '"]');
  return map || null;
}

function getMapOfImage(element) {
  var usemap = element.getAttribute('usemap');
  if (!usemap) {
    return null;
  }

  var _document = (0, _getDocument2.default)(element);
  return getMapByName(usemap.slice(1), _document);
}

function getImageOfArea(element) {
  var map = element.parentElement;

  if (!map.name || map.nodeName.toLowerCase() !== 'map') {
    return null;
  }

  // NOTE: image maps can also be applied to <object> with image content,
  // but no browser supports this at the moment

  // HTML5 specifies HTMLMapElement.images to be an HTMLCollection of all
  // <img> and <object> referencing the <map> element, but no browser implements this
  //   https://www.w3.org/TR/html5/embedded-content-0.html#the-map-element
  //   https://developer.mozilla.org/en-US/docs/Web/API/HTMLMapElement
  // the image must be valid and loaded for the map to take effect
  var _document = (0, _getDocument2.default)(element);
  return _document.querySelector('img[usemap="#' + (0, _css2.default)(map.name) + '"]') || null;
}
//# sourceMappingURL=image-map.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/logger.js":
/*!*********************************************!*\
  !*** ./node_modules/ally.js/util/logger.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var noop = function noop() {};
var _console = {
  log: noop,
  debug: noop,
  info: noop,
  warn: noop,
  error: noop
};

exports.default = typeof console !== 'undefined' ? console : _console;
module.exports = exports['default'];
//# sourceMappingURL=logger.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/merge-dom-order.js":
/*!******************************************************!*\
  !*** ./node_modules/ally.js/util/merge-dom-order.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      list = _ref.list,
      elements = _ref.elements,
      resolveElement = _ref.resolveElement;

  // operate on a copy so we don't mutate the original array
  var _list = list.slice(0);
  // make sure the elements we're injecting are provided in DOM order
  var _elements = (0, _nodeArray2.default)(elements).slice(0);
  (0, _sortDomOrder2.default)(_elements);
  // find the offsets within the target array (list) at which to inject
  // each individual element (from elements)
  var insertions = findInsertionOffsets(_list, _elements, resolveElement);
  // actually inject the elements into the target array at the identified positions
  insertElementsAtOffsets(_list, insertions);
  return _list;
};

var _arrayFindIndex = __webpack_require__(/*! ../util/array-find-index */ "./node_modules/ally.js/util/array-find-index.js");

var _arrayFindIndex2 = _interopRequireDefault(_arrayFindIndex);

var _nodeArray = __webpack_require__(/*! ./node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _sortDomOrder = __webpack_require__(/*! ./sort-dom-order */ "./node_modules/ally.js/util/sort-dom-order.js");

var _sortDomOrder2 = _interopRequireDefault(_sortDomOrder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getFirstSuccessorOffset(list, target) {
  // find the first element that comes AFTER the target element
  return (0, _arrayFindIndex2.default)(list, function (element) {
    return target.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_FOLLOWING;
  });
}
// sort a list of elements into another list of elements in DOM order

/*
  USAGE:
    mergeDomOrder({
      // DOM ordered array of elements to use as base of merge
      list: [],
      // unordered array of elements to merge into base list
      elements: [],
      // callback function to resolve an element
      resolveElement: function(element) {
        // return null to skip
        // return element to replace insertion
        // return [element1, element2, …] to replace insertion with multiple elements
        return element;
      },
    })
*/

function findInsertionOffsets(list, elements, resolveElement) {
  // instead of mutating the elements list directly, remember position and map
  // to inject later, when we can do this more efficiently
  var insertions = [];
  elements.forEach(function (element) {
    var replace = true;
    var offset = list.indexOf(element);

    if (offset === -1) {
      // element is not in target list
      offset = getFirstSuccessorOffset(list, element);
      replace = false;
    }

    if (offset === -1) {
      // there is no successor in the tabsequence,
      // meaning the image must be the last element
      offset = list.length;
    }

    // allow the consumer to replace the injected element
    var injections = (0, _nodeArray2.default)(resolveElement ? resolveElement(element) : element);
    if (!injections.length) {
      // we can't inject zero elements
      return;
    }

    insertions.push({
      offset: offset,
      replace: replace,
      elements: injections
    });
  });

  return insertions;
}

function insertElementsAtOffsets(list, insertions) {
  // remember the number of elements we have already injected
  // so we account for the caused index offset
  var inserted = 0;
  // make sure that we insert the elements in sequence,
  // otherwise the offset compensation won't work
  insertions.sort(function (a, b) {
    return a.offset - b.offset;
  });
  insertions.forEach(function (insertion) {
    // array.splice has an annoying function signature :(
    var remove = insertion.replace ? 1 : 0;
    var args = [insertion.offset + inserted, remove].concat(insertion.elements);
    list.splice.apply(list, args);
    inserted += insertion.elements.length - remove;
  });
}

module.exports = exports['default'];
//# sourceMappingURL=merge-dom-order.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/node-array.js":
/*!*************************************************!*\
  !*** ./node_modules/ally.js/util/node-array.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (input) {
  if (!input) {
    return [];
  }

  if (Array.isArray(input)) {
    return input;
  }

  // instanceof Node - does not work with iframes
  if (input.nodeType !== undefined) {
    return [input];
  }

  if (typeof input === 'string') {
    input = document.querySelectorAll(input);
  }

  if (input.length !== undefined) {
    return [].slice.call(input, 0);
  }

  throw new TypeError('unexpected input ' + String(input));
};

module.exports = exports['default'];
// input may be undefined, selector-tring, Node, NodeList, HTMLCollection, array of Nodes
// yes, to some extent this is a bad replica of jQuery's constructor function
//# sourceMappingURL=node-array.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/platform.js":
/*!***********************************************!*\
  !*** ./node_modules/ally.js/util/platform.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _platform2 = __webpack_require__(/*! platform */ "./node_modules/platform/platform.js");

var _platform3 = _interopRequireDefault(_platform2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// deep clone of original platform
var platform = JSON.parse(JSON.stringify(_platform3.default));

// operating system

// sugar for https://github.com/bestiejs/platform.js
// make sure to ALWAYS reference the layout engine,
// even if it is not necessary for the condition,
// as this makes grepping for this stuff simpler

var os = platform.os.family || '';
var ANDROID = os === 'Android';
var WINDOWS = os.slice(0, 7) === 'Windows';
var OSX = os === 'OS X';
var IOS = os === 'iOS';

// layout
var BLINK = platform.layout === 'Blink';
var GECKO = platform.layout === 'Gecko';
var TRIDENT = platform.layout === 'Trident';
var EDGE = platform.layout === 'EdgeHTML';
var WEBKIT = platform.layout === 'WebKit';

// browser version (not layout engine version!)
var version = parseFloat(platform.version);
var majorVersion = Math.floor(version);
platform.majorVersion = majorVersion;

platform.is = {
  // operating system
  ANDROID: ANDROID,
  WINDOWS: WINDOWS,
  OSX: OSX,
  IOS: IOS,
  // layout
  BLINK: BLINK, // "Chrome", "Chrome Mobile", "Opera"
  GECKO: GECKO, // "Firefox"
  TRIDENT: TRIDENT, // "Internet Explorer"
  EDGE: EDGE, // "Microsoft Edge"
  WEBKIT: WEBKIT, // "Safari"
  // INTERNET EXPLORERS
  IE9: TRIDENT && majorVersion === 9,
  IE10: TRIDENT && majorVersion === 10,
  IE11: TRIDENT && majorVersion === 11
};

exports.default = platform;
module.exports = exports['default'];
//# sourceMappingURL=platform.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/select-in-shadows.js":
/*!********************************************************!*\
  !*** ./node_modules/ally.js/util/select-in-shadows.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (selector) {
  if (typeof shadowPrefix !== 'string') {
    var operator = (0, _cssShadowPiercingDeepCombinator2.default)();
    if (operator) {
      shadowPrefix = ', html ' + operator + ' ';
    }
  }

  if (!shadowPrefix) {
    return selector;
  }

  return selector + shadowPrefix + selector.replace(/\s*,\s*/g, ',').split(',').join(shadowPrefix);
};

var _cssShadowPiercingDeepCombinator = __webpack_require__(/*! ../supports/css-shadow-piercing-deep-combinator */ "./node_modules/ally.js/supports/css-shadow-piercing-deep-combinator.js");

var _cssShadowPiercingDeepCombinator2 = _interopRequireDefault(_cssShadowPiercingDeepCombinator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var shadowPrefix = void 0;
// convert a CSS selector so that it also pierces ShadowDOM
// takes ".a, #b" and turns it into ".a, #b, html >>> .a, html >>> #b"

module.exports = exports['default'];
//# sourceMappingURL=select-in-shadows.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/sort-dom-order.js":
/*!*****************************************************!*\
  !*** ./node_modules/ally.js/util/sort-dom-order.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (elements) {
  return elements.sort(compareDomPosition);
};

// sorts a list of elements according to their order in the DOM

function compareDomPosition(a, b) {
  return a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
}

module.exports = exports["default"];
//# sourceMappingURL=sort-dom-order.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/tabindex-value.js":
/*!*****************************************************!*\
  !*** ./node_modules/ally.js/util/tabindex-value.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (element) {
  if (!(0, _validTabindex2.default)(element)) {
    return null;
  }

  // Edge 14 has a capitalization problem on SVG elements,
  // see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9282058/
  var hasTabindex = element.hasAttribute('tabindex');
  var attributeName = hasTabindex ? 'tabindex' : 'tabIndex';

  // @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054
  var tabindex = parseInt(element.getAttribute(attributeName), 10);
  return isNaN(tabindex) ? -1 : tabindex;
};

var _validTabindex = __webpack_require__(/*! ../is/valid-tabindex */ "./node_modules/ally.js/is/valid-tabindex.js");

var _validTabindex2 = _interopRequireDefault(_validTabindex);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
//# sourceMappingURL=tabindex-value.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/toggle-attribute-value.js":
/*!*************************************************************!*\
  !*** ./node_modules/ally.js/util/toggle-attribute-value.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var element = _ref.element,
      attribute = _ref.attribute,
      temporaryValue = _ref.temporaryValue,
      saveValue = _ref.saveValue;

  var temporaryAttribute = 'data-cached-' + attribute;

  if (temporaryValue !== undefined) {
    var _value = saveValue || element.getAttribute(attribute);
    element.setAttribute(temporaryAttribute, _value || '');
    element.setAttribute(attribute, temporaryValue);
  } else {
    var _value2 = element.getAttribute(temporaryAttribute);
    element.removeAttribute(temporaryAttribute);
    if (_value2 === '') {
      element.removeAttribute(attribute);
    } else {
      element.setAttribute(attribute, _value2);
    }
  }
};

module.exports = exports['default'];
// helper to turn
//  <div some-attribute="original">
// into
//  <div some-attribute="new" data-cached-some-attribute="original">
// and back
//# sourceMappingURL=toggle-attribute-value.js.map

/***/ }),

/***/ "./node_modules/ally.js/util/toggle-attribute.js":
/*!*******************************************************!*\
  !*** ./node_modules/ally.js/util/toggle-attribute.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (_ref) {
  var element = _ref.element,
      attribute = _ref.attribute;

  var temporaryAttribute = 'data-cached-' + attribute;
  var temporaryAttributeValue = element.getAttribute(temporaryAttribute);

  if (temporaryAttributeValue === null) {
    var _value = element.getAttribute(attribute);
    if (_value === null) {
      // can't remove what's not there
      return;
    }

    element.setAttribute(temporaryAttribute, _value || '');
    element.removeAttribute(attribute);
  } else {
    var _value2 = element.getAttribute(temporaryAttribute);
    element.removeAttribute(temporaryAttribute);
    element.setAttribute(attribute, _value2);
  }
};

module.exports = exports['default'];
// helper to turn
//  <div some-attribute="original">
// into
//  <div data-cached-some-attribute="original">
// and back
//# sourceMappingURL=toggle-attribute.js.map

/***/ }),

/***/ "./node_modules/ally.js/version.js":
/*!*****************************************!*\
  !*** ./node_modules/ally.js/version.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// this file is overwritten by `npm run build:pre`
var version = '1.4.1';
exports.default = version;
module.exports = exports['default'];
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/ally.js/when/key.binding.js":
/*!**************************************************!*\
  !*** ./node_modules/ally.js/when/key.binding.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (text) {
  return text.split(/\s+/).map(function (_text) {
    var tokens = _text.split('+');
    var _modifiers = resolveModifiers(tokens.slice(0, -1));
    var _keyCodes = resolveKey(tokens.slice(-1));
    return {
      keyCodes: _keyCodes,
      modifiers: _modifiers,
      matchModifiers: matchModifiers.bind(null, _modifiers)
    };
  });
};

var _keycode = __webpack_require__(/*! ../map/keycode */ "./node_modules/ally.js/map/keycode.js");

var _keycode2 = _interopRequireDefault(_keycode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var modifier = {
  alt: 'altKey',
  ctrl: 'ctrlKey',
  meta: 'metaKey',
  shift: 'shiftKey'
};
/*
  decodes a key binding token to a JavaScript structure

  returns an array of objects:
    {
      // key name translated to keyCode (possibly more than one)
      keyCodes: [<number>],
      // translated modifiers
      modifiers: {
        altKey: null,   // ignore
        ctrKey: false,  // expect not pressed
        metaKey: true,  // expect pressed
        shiftKey: true, // expect pressed
      },
      // callback that returns true if event's
      // modifier keys match the expected state
      matchModifiers: function(event){},
    }
*/

var modifierSequence = Object.keys(modifier).map(function (name) {
  return modifier[name];
});

function createExpectedModifiers(ignoreModifiers) {
  var value = ignoreModifiers ? null : false;
  return {
    altKey: value,
    ctrlKey: value,
    metaKey: value,
    shiftKey: value
  };
}

function resolveModifiers(modifiers) {
  var ignoreModifiers = modifiers.indexOf('*') !== -1;
  var expected = createExpectedModifiers(ignoreModifiers);

  modifiers.forEach(function (token) {
    if (token === '*') {
      // we've already covered the all-in operator
      return;
    }

    // we want the modifier pressed
    var value = true;
    var operator = token.slice(0, 1);
    if (operator === '?') {
      // we don't care if the modifier is pressed
      value = null;
    } else if (operator === '!') {
      // we do not want the modifier pressed
      value = false;
    }

    if (value !== true) {
      // compensate for the modifier's operator
      token = token.slice(1);
    }

    var propertyName = modifier[token];
    if (!propertyName) {
      throw new TypeError('Unknown modifier "' + token + '"');
    }

    expected[propertyName] = value;
  });

  return expected;
}

function resolveKey(key) {
  var code = _keycode2.default[key] || parseInt(key, 10);
  if (!code || typeof code !== 'number' || isNaN(code)) {
    throw new TypeError('Unknown key "' + key + '"');
  }

  return [code].concat(_keycode2.default._alias[code] || []);
}

function matchModifiers(expected, event) {
  // returns true on match
  return !modifierSequence.some(function (prop) {
    // returns true on mismatch
    return typeof expected[prop] === 'boolean' && Boolean(event[prop]) !== expected[prop];
  });
}

module.exports = exports['default'];
//# sourceMappingURL=key.binding.js.map

/***/ }),

/***/ "./node_modules/ally.js/when/key.js":
/*!******************************************!*\
  !*** ./node_modules/ally.js/when/key.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  var map = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var bindings = {};

  var context = (0, _nodeArray2.default)(map.context)[0] || document.documentElement;
  delete map.context;
  var filter = (0, _nodeArray2.default)(map.filter);
  delete map.filter;

  var mapKeys = Object.keys(map);
  if (!mapKeys.length) {
    throw new TypeError('when/key requires at least one option key');
  }

  var registerBinding = function registerBinding(event) {
    event.keyCodes.forEach(function (code) {
      if (!bindings[code]) {
        bindings[code] = [];
      }

      bindings[code].push(event);
    });
  };

  mapKeys.forEach(function (text) {
    if (typeof map[text] !== 'function') {
      throw new TypeError('when/key requires option["' + text + '"] to be a function');
    }

    var addCallback = function addCallback(event) {
      event.callback = map[text];
      return event;
    };

    (0, _key2.default)(text).map(addCallback).forEach(registerBinding);
  });

  var handleKeyDown = function handleKeyDown(event) {
    if (event.defaultPrevented) {
      return;
    }

    if (filter.length) {
      // ignore elements within the exempted sub-trees
      var isParentOfElement = (0, _comparePosition.getParentComparator)({ element: event.target, includeSelf: true });
      if (filter.some(isParentOfElement)) {
        return;
      }
    }

    var key = event.keyCode || event.which;
    if (!bindings[key]) {
      return;
    }

    bindings[key].forEach(function (_event) {
      if (!_event.matchModifiers(event)) {
        return;
      }

      _event.callback.call(context, event, disengage);
    });
  };

  context.addEventListener('keydown', handleKeyDown, false);

  var disengage = function disengage() {
    context.removeEventListener('keydown', handleKeyDown, false);
  };

  return { disengage: disengage };
};

var _key = __webpack_require__(/*! ./key.binding */ "./node_modules/ally.js/when/key.binding.js");

var _key2 = _interopRequireDefault(_key);

var _nodeArray = __webpack_require__(/*! ../util/node-array */ "./node_modules/ally.js/util/node-array.js");

var _nodeArray2 = _interopRequireDefault(_nodeArray);

var _comparePosition = __webpack_require__(/*! ../util/compare-position */ "./node_modules/ally.js/util/compare-position.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];

// Bug 286933 - Key events in the autocomplete popup should be hidden from page scripts
// @browser-issue Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=286933
//# sourceMappingURL=key.js.map

/***/ }),

/***/ "./node_modules/anser/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/anser/lib/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file was originally written by @drudru (https://github.com/drudru/ansi_up), MIT, 2011

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ANSI_COLORS = [[{ color: "0, 0, 0", "class": "ansi-black" }, { color: "187, 0, 0", "class": "ansi-red" }, { color: "0, 187, 0", "class": "ansi-green" }, { color: "187, 187, 0", "class": "ansi-yellow" }, { color: "0, 0, 187", "class": "ansi-blue" }, { color: "187, 0, 187", "class": "ansi-magenta" }, { color: "0, 187, 187", "class": "ansi-cyan" }, { color: "255,255,255", "class": "ansi-white" }], [{ color: "85, 85, 85", "class": "ansi-bright-black" }, { color: "255, 85, 85", "class": "ansi-bright-red" }, { color: "0, 255, 0", "class": "ansi-bright-green" }, { color: "255, 255, 85", "class": "ansi-bright-yellow" }, { color: "85, 85, 255", "class": "ansi-bright-blue" }, { color: "255, 85, 255", "class": "ansi-bright-magenta" }, { color: "85, 255, 255", "class": "ansi-bright-cyan" }, { color: "255, 255, 255", "class": "ansi-bright-white" }]];

var Anser = function () {
    _createClass(Anser, null, [{
        key: "escapeForHtml",


        /**
         * Anser.escapeForHtml
         * Escape the input HTML.
         *
         * This does the minimum escaping of text to make it compliant with HTML.
         * In particular, the '&','<', and '>' characters are escaped. This should
         * be run prior to `ansiToHtml`.
         *
         * @name Anser.escapeForHtml
         * @function
         * @param {String} txt The input text (containing the ANSI snippets).
         * @returns {String} The escaped html.
         */
        value: function escapeForHtml(txt) {
            return new Anser().escapeForHtml(txt);
        }

        /**
         * Anser.linkify
         * Adds the links in the HTML.
         *
         * This replaces any links in the text with anchor tags that display the
         * link. The links should have at least one whitespace character
         * surrounding it. Also, you should apply this after you have run
         * `ansiToHtml` on the text.
         *
         * @name Anser.linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML containing the <a> tags (unescaped).
         */

    }, {
        key: "linkify",
        value: function linkify(txt) {
            return new Anser().linkify(txt);
        }

        /**
         * Anser.ansiToHtml
         * This replaces ANSI terminal escape codes with SPAN tags that wrap the
         * content.
         *
         * This function only interprets ANSI SGR (Select Graphic Rendition) codes
         * that can be represented in HTML.
         * For example, cursor movement codes are ignored and hidden from output.
         * The default style uses colors that are very close to the prescribed
         * standard. The standard assumes that the text will have a black
         * background. These colors are set as inline styles on the SPAN tags.
         *
         * Another option is to set `use_classes: true` in the options argument.
         * This will instead set classes on the spans so the colors can be set via
         * CSS. The class names used are of the format `ansi-*-fg/bg` and
         * `ansi-bright-*-fg/bg` where `*` is the color name,
         * i.e black/red/green/yellow/blue/magenta/cyan/white.
         *
         * @name Anser.ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
            return new Anser().ansiToHtml(txt, options);
        }

        /**
         * Anser.ansiToJson
         * Converts ANSI input into JSON output.
         *
         * @name Anser.ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed to the ansiToHTML method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
            return new Anser().ansiToJson(txt, options);
        }

        /**
         * Anser.ansiToText
         * Converts ANSI input into text output.
         *
         * @name Anser.ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */

    }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
            return new Anser().ansiToText(txt);
        }

        /**
         * Anser
         * The `Anser` class.
         *
         * @name Anser
         * @function
         * @returns {Anser}
         */

    }]);

    function Anser() {
        _classCallCheck(this, Anser);

        this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;
        this.bright = 0;
    }

    /**
     * setupPalette
     * Sets up the palette.
     *
     * @name setupPalette
     * @function
     */


    _createClass(Anser, [{
        key: "setupPalette",
        value: function setupPalette() {
            this.PALETTE_COLORS = [];

            // Index 0..15 : System color
            for (var i = 0; i < 2; ++i) {
                for (var j = 0; j < 8; ++j) {
                    this.PALETTE_COLORS.push(ANSI_COLORS[i][j].color);
                }
            }

            // Index 16..231 : RGB 6x6x6
            // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml
            var levels = [0, 95, 135, 175, 215, 255];
            var format = function format(r, g, b) {
                return levels[r] + ", " + levels[g] + ", " + levels[b];
            };
            var r = void 0,
                g = void 0,
                b = void 0;
            for (var _r = 0; _r < 6; ++_r) {
                for (var _g = 0; _g < 6; ++_g) {
                    for (var _b = 0; _b < 6; ++_b) {
                        this.PALETTE_COLORS.push(format(_r, _g, _b));
                    }
                }
            }

            // Index 232..255 : Grayscale
            var level = 8;
            for (var _i = 0; _i < 24; ++_i, level += 10) {
                this.PALETTE_COLORS.push(format(level, level, level));
            }
        }

        /**
         * escapeForHtml
         * Escapes the input text.
         *
         * @name escapeForHtml
         * @function
         * @param {String} txt The input text.
         * @returns {String} The escpaed HTML output.
         */

    }, {
        key: "escapeForHtml",
        value: function escapeForHtml(txt) {
            return txt.replace(/[&<>]/gm, function (str) {
                return str == "&" ? "&amp;" : str == "<" ? "&lt;" : str == ">" ? "&gt;" : "";
            });
        }

        /**
         * linkify
         * Adds HTML link elements.
         *
         * @name linkify
         * @function
         * @param {String} txt The input text.
         * @returns {String} The HTML output containing link elements.
         */

    }, {
        key: "linkify",
        value: function linkify(txt) {
            return txt.replace(/(https?:\/\/[^\s]+)/gm, function (str) {
                return "<a href=\"" + str + "\">" + str + "</a>";
            });
        }

        /**
         * ansiToHtml
         * Converts ANSI input into HTML output.
         *
         * @name ansiToHtml
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The HTML output.
         */

    }, {
        key: "ansiToHtml",
        value: function ansiToHtml(txt, options) {
            return this.process(txt, options, true);
        }

        /**
         * ansiToJson
         * Converts ANSI input into HTML output.
         *
         * @name ansiToJson
         * @function
         * @param {String} txt The input text.
         * @param {Object} options The options passed ot the `process` method.
         * @returns {String} The JSON output.
         */

    }, {
        key: "ansiToJson",
        value: function ansiToJson(txt, options) {
            options = options || {};
            options.json = true;
            options.clearLine = false;
            return this.process(txt, options, true);
        }

        /**
         * ansiToText
         * Converts ANSI input into HTML output.
         *
         * @name ansiToText
         * @function
         * @param {String} txt The input text.
         * @returns {String} The text output.
         */

    }, {
        key: "ansiToText",
        value: function ansiToText(txt) {
            return this.process(txt, {}, false);
        }

        /**
         * process
         * Processes the input.
         *
         * @name process
         * @function
         * @param {String} txt The input text.
         * @param {Object} options An object passed to `processChunk` method, extended with:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup
         */

    }, {
        key: "process",
        value: function process(txt, options, markup) {
            var _this = this;

            var self = this;
            var raw_text_chunks = txt.split(/\033\[/);
            var first_chunk = raw_text_chunks.shift(); // the first chunk is not the result of the split

            if (options === undefined || options === null) {
                options = {};
            }
            options.clearLine = /\r/.test(txt); // check for Carriage Return
            var color_chunks = raw_text_chunks.map(function (chunk) {
                return _this.processChunk(chunk, options, markup);
            });

            if (options && options.json) {
                var first = self.processChunkJson("");
                first.content = first_chunk;
                first.clearLine = options.clearLine;
                color_chunks.unshift(first);
                if (options.remove_empty) {
                    color_chunks = color_chunks.filter(function (c) {
                        return !c.isEmpty();
                    });
                }
                return color_chunks;
            } else {
                color_chunks.unshift(first_chunk);
            }

            return color_chunks.join("");
        }

        /**
         * processChunkJson
         * Processes the current chunk into json output.
         *
         * @name processChunkJson
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object} The result object:
         *
         *  - `content` (String): The text.
         *  - `fg` (String|null): The foreground color.
         *  - `bg` (String|null): The background color.
         *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).
         *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).
         *  - `clearLine` (Boolean): `true` if a carriageReturn \r was fount at end of line.
         *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.
         *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.
         *
         */

    }, {
        key: "processChunkJson",
        value: function processChunkJson(text, options, markup) {

            // Are we using classes or styles?
            options = typeof options == "undefined" ? {} : options;
            var use_classes = options.use_classes = typeof options.use_classes != "undefined" && options.use_classes;
            var key = options.key = use_classes ? "class" : "color";

            var result = {
                content: text,
                fg: null,
                bg: null,
                fg_truecolor: null,
                bg_truecolor: null,
                clearLine: options.clearLine,
                decoration: null,
                was_processed: false,
                isEmpty: function isEmpty() {
                    return !result.content;
                }
            };

            // Each "chunk" is the text after the CSI (ESC + "[") and before the next CSI/EOF.
            //
            // This regex matches four groups within a chunk.
            //
            // The first and third groups match code type.
            // We supported only SGR command. It has empty first group and "m" in third.
            //
            // The second group matches all of the number+semicolon command sequences
            // before the "m" (or other trailing) character.
            // These are the graphics or SGR commands.
            //
            // The last group is the text (including newlines) that is colored by
            // the other group"s commands.
            var matches = text.match(/^([!\x3c-\x3f]*)([\d;]*)([\x20-\x2c]*[\x40-\x7e])([\s\S]*)/m);

            if (!matches) return result;

            var orig_txt = result.content = matches[4];
            var nums = matches[2].split(";");

            // We currently support only "SGR" (Select Graphic Rendition)
            // Simply ignore if not a SGR command.
            if (matches[1] !== "" || matches[3] !== "m") {
                return result;
            }

            if (!markup) {
                return result;
            }

            var self = this;

            self.decoration = null;

            while (nums.length > 0) {
                var num_str = nums.shift();
                var num = parseInt(num_str);

                if (isNaN(num) || num === 0) {
                    self.fg = self.bg = self.decoration = null;
                } else if (num === 1) {
                    self.decoration = "bold";
                } else if (num === 2) {
                    self.decoration = "dim";
                    // Enable code 2 to get string
                } else if (num == 3) {
                    self.decoration = "italic";
                } else if (num == 4) {
                    self.decoration = "underline";
                } else if (num == 5) {
                    self.decoration = "blink";
                } else if (num === 7) {
                    self.decoration = "reverse";
                } else if (num === 8) {
                    self.decoration = "hidden";
                    // Enable code 9 to get strikethrough
                } else if (num === 9) {
                    self.decoration = "strikethrough";
                } else if (num == 39) {
                    self.fg = null;
                } else if (num == 49) {
                    self.bg = null;
                    // Foreground color
                } else if (num >= 30 && num < 38) {
                    self.fg = ANSI_COLORS[0][num % 10][key];
                    // Foreground bright color
                } else if (num >= 90 && num < 98) {
                    self.fg = ANSI_COLORS[1][num % 10][key];
                    // Background color
                } else if (num >= 40 && num < 48) {
                    self.bg = ANSI_COLORS[0][num % 10][key];
                    // Background bright color
                } else if (num >= 100 && num < 108) {
                    self.bg = ANSI_COLORS[1][num % 10][key];
                } else if (num === 38 || num === 48) {
                    // extend color (38=fg, 48=bg)
                    var is_foreground = num === 38;
                    if (nums.length >= 1) {
                        var mode = nums.shift();
                        if (mode === "5" && nums.length >= 1) {
                            // palette color
                            var palette_index = parseInt(nums.shift());
                            if (palette_index >= 0 && palette_index <= 255) {
                                if (!use_classes) {
                                    if (!this.PALETTE_COLORS) {
                                        self.setupPalette();
                                    }
                                    if (is_foreground) {
                                        self.fg = this.PALETTE_COLORS[palette_index];
                                    } else {
                                        self.bg = this.PALETTE_COLORS[palette_index];
                                    }
                                } else {
                                    var klass = palette_index >= 16 ? "ansi-palette-" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8]["class"];
                                    if (is_foreground) {
                                        self.fg = klass;
                                    } else {
                                        self.bg = klass;
                                    }
                                }
                            }
                        } else if (mode === "2" && nums.length >= 3) {
                            // true color
                            var r = parseInt(nums.shift());
                            var g = parseInt(nums.shift());
                            var b = parseInt(nums.shift());
                            if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {
                                var color = r + ", " + g + ", " + b;
                                if (!use_classes) {
                                    if (is_foreground) {
                                        self.fg = color;
                                    } else {
                                        self.bg = color;
                                    }
                                } else {
                                    if (is_foreground) {
                                        self.fg = "ansi-truecolor";
                                        self.fg_truecolor = color;
                                    } else {
                                        self.bg = "ansi-truecolor";
                                        self.bg_truecolor = color;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (self.fg === null && self.bg === null && self.decoration === null) {
                return result;
            } else {
                var styles = [];
                var classes = [];
                var data = {};

                result.fg = self.fg;
                result.bg = self.bg;
                result.fg_truecolor = self.fg_truecolor;
                result.bg_truecolor = self.bg_truecolor;
                result.decoration = self.decoration;
                result.was_processed = true;

                return result;
            }
        }

        /**
         * processChunk
         * Processes the current chunk of text.
         *
         * @name processChunk
         * @function
         * @param {String} text The input text.
         * @param {Object} options An object containing the following fields:
         *
         *  - `json` (Boolean): If `true`, the result will be an object.
         *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.
         *
         * @param {Boolean} markup If false, the colors will not be parsed.
         * @return {Object|String} The result (object if `json` is wanted back or string otherwise).
         */

    }, {
        key: "processChunk",
        value: function processChunk(text, options, markup) {
            var _this2 = this;

            var self = this;
            options = options || {};
            var jsonChunk = this.processChunkJson(text, options, markup);

            if (options.json) {
                return jsonChunk;
            }
            if (jsonChunk.isEmpty()) {
                return "";
            }
            if (!jsonChunk.was_processed) {
                return jsonChunk.content;
            }

            var use_classes = options.use_classes;

            var styles = [];
            var classes = [];
            var data = {};
            var render_data = function render_data(data) {
                var fragments = [];
                var key = void 0;
                for (key in data) {
                    if (data.hasOwnProperty(key)) {
                        fragments.push("data-" + key + "=\"" + _this2.escapeForHtml(data[key]) + "\"");
                    }
                }
                return fragments.length > 0 ? " " + fragments.join(" ") : "";
            };

            if (jsonChunk.fg) {
                if (use_classes) {
                    classes.push(jsonChunk.fg + "-fg");
                    if (jsonChunk.fg_truecolor !== null) {
                        data["ansi-truecolor-fg"] = jsonChunk.fg_truecolor;
                        jsonChunk.fg_truecolor = null;
                    }
                } else {
                    styles.push("color:rgb(" + jsonChunk.fg + ")");
                }
            }

            if (jsonChunk.bg) {
                if (use_classes) {
                    classes.push(jsonChunk.bg + "-bg");
                    if (jsonChunk.bg_truecolor !== null) {
                        data["ansi-truecolor-bg"] = jsonChunk.bg_truecolor;
                        jsonChunk.bg_truecolor = null;
                    }
                } else {
                    styles.push("background-color:rgb(" + jsonChunk.bg + ")");
                }
            }

            if (jsonChunk.decoration) {
                if (use_classes) {
                    classes.push("ansi-" + jsonChunk.decoration);
                } else if (jsonChunk.decoration === "bold") {
                    styles.push("font-weight:bold");
                } else if (jsonChunk.decoration === "dim") {
                    styles.push("opacity:0.5");
                } else if (jsonChunk.decoration === "italic") {
                    styles.push("font-style:italic");
                    // underline and blink are treated bellow
                } else if (jsonChunk.decoration === "reverse") {
                    styles.push("filter:invert(100%)");
                } else if (jsonChunk.decoration === "hidden") {
                    styles.push("visibility:hidden");
                } else if (jsonChunk.decoration === "strikethrough") {
                    styles.push("text-decoration:line-through");
                } else {
                    styles.push("text-decoration:" + jsonChunk.decoration);
                }
            }

            if (use_classes) {
                return "<span class=\"" + classes.join(" ") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
            } else {
                return "<span style=\"" + styles.join(";") + "\"" + render_data(data) + ">" + jsonChunk.content + "</span>";
            }
        }
    }]);

    return Anser;
}();

;

module.exports = Anser;

/***/ }),

/***/ "./node_modules/css.escape/css.escape.js":
/*!***********************************************!*\
  !*** ./node_modules/css.escape/css.escape.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*! https://mths.be/cssescape v1.5.1 by @mathias | MIT license */
;(function(root, factory) {
	// https://github.com/umdjs/umd/blob/master/returnExports.js
	if (true) {
		// For Node.js.
		module.exports = factory(root);
	} else {}
}(typeof global != 'undefined' ? global : this, function(root) {

	if (root.CSS && root.CSS.escape) {
		return root.CSS.escape;
	}

	// https://drafts.csswg.org/cssom/#serialize-an-identifier
	var cssEscape = function(value) {
		if (arguments.length == 0) {
			throw new TypeError('`CSS.escape` requires an argument.');
		}
		var string = String(value);
		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = '';
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);
			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += '\uFFFD';
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += '\\' + codeUnit.toString(16) + ' ';
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += '\\' + string.charAt(index);
				continue;
			}

			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += '\\' + string.charAt(index);

		}
		return result;
	};

	if (!root.CSS) {
		root.CSS = {};
	}

	root.CSS.escape = cssEscape;
	return cssEscape;

}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/native-url/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/native-url/dist/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var e,t=(e=__webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js"))&&"object"==typeof e&&"default"in e?e.default:e,r=/https?|ftp|gopher|file/;function o(e){"string"==typeof e&&(e=g(e));var o=function(e,t,r){var o=e.auth,a=e.hostname,s=e.protocol||"",c=e.pathname||"",h=e.hash||"",p=e.query||"",n=!1;o=o?encodeURIComponent(o).replace(/%3A/i,":")+"@":"",e.host?n=o+e.host:a&&(n=o+(~a.indexOf(":")?"["+a+"]":a),e.port&&(n+=":"+e.port)),p&&"object"==typeof p&&(p=t.encode(p));var l=e.search||p&&"?"+p||"";return s&&":"!==s.substr(-1)&&(s+=":"),e.slashes||(!s||r.test(s))&&!1!==n?(n="//"+(n||""),c&&"/"!==c[0]&&(c="/"+c)):n||(n=""),h&&"#"!==h[0]&&(h="#"+h),l&&"?"!==l[0]&&(l="?"+l),{protocol:s,host:n,pathname:c=c.replace(/[?#]/g,encodeURIComponent),search:l=l.replace("#","%23"),hash:h}}(e,t,r);return""+o.protocol+o.host+o.pathname+o.search+o.hash}var a="http://",s="w.w",c=a+s,h=/^([a-z0-9.+-]*:\/\/\/)([a-z0-9.+-]:\/*)?/i,p=/https?|ftp|gopher|file/;function n(e,t){var r="string"==typeof e?g(e):e;e="object"==typeof e?o(e):e;var s=g(t),n="";r.protocol&&!r.slashes&&(n=r.protocol,e=e.replace(r.protocol,""),n+="/"===t[0]||"/"===e[0]?"/":""),n&&s.protocol&&(n="",s.slashes||(n=s.protocol,t=t.replace(s.protocol,"")));var l=e.match(h);l&&!s.protocol&&(e=e.substr((n=l[1]+(l[2]||"")).length),/^\/\/[^/]/.test(t)&&(n=n.slice(0,-1)));var i=new URL(e,c+"/"),f=new URL(t,i).toString().replace(c,""),u=s.protocol||r.protocol;return u+=r.slashes||s.slashes?"//":"",!n&&u?f=f.replace(a,u):n&&(f=f.replace(a,"")),p.test(f)||~t.indexOf(".")||"/"===e.slice(-1)||"/"===t.slice(-1)||"/"!==f.slice(-1)||(f=f.slice(0,-1)),n&&(f=n+("/"===f[0]?f.substr(1):f)),f}function l(){}l.parse=g,l.format=o,l.resolve=n,l.resolveObject=n;var i=/^https?|ftp|gopher|file/,f=/^(.*?)([#?].*)/,u=/^([a-z0-9.+-]*:)(\/{0,3})(.*)/i,m=/^([a-z0-9.+-]*:)?\/\/\/*/i,v=/^([a-z0-9.+-]*:)(\/{0,2})\[(.*)\]$/i;function d(e){try{return decodeURI(e)}catch(t){return e}}function g(e,r,a){if(void 0===r&&(r=!1),void 0===a&&(a=!1),e&&"object"==typeof e&&e instanceof l)return e;var h=(e=e.trim()).match(f);e=h?d(h[1]).replace(/\\/g,"/")+h[2]:d(e).replace(/\\/g,"/"),v.test(e)&&"/"!==e.slice(-1)&&(e+="/");var p=!/(^javascript)/.test(e)&&e.match(u),n=m.test(e),g="";p&&(i.test(p[1])||(g=p[1].toLowerCase(),e=""+p[2]+p[3]),p[2]||(n=!1,i.test(p[1])?(g=p[1],e=""+p[3]):e="//"+p[3]),3!==p[2].length&&1!==p[2].length||(g=p[1],e="/"+p[3]));var b,y=(h?h[1]:e).match(/(:[0-9]+)/),j="";y&&y[1]&&3===y[1].length&&(e=e.replace(j=y[1],j+"00"));var w=new l,x="",U="";try{b=new URL(e)}catch(t){x=t,g||a||!/^\/\//.test(e)||/^\/\/.+[@.]/.test(e)||(U="/",e=e.substr(1));try{b=new URL(e,c)}catch(e){return w.protocol=g,w.href=g,w}}w.slashes=n&&!U,w.host=b.host===s?"":b.host,w.hostname=b.hostname===s?"":b.hostname.replace(/(\[|\])/g,""),w.protocol=x?g||null:b.protocol,w.search=b.search.replace(/\\/g,"%5C"),w.hash=b.hash.replace(/\\/g,"%5C");var R=e.split("#");!w.search&&~R[0].indexOf("?")&&(w.search="?"),w.hash||""!==R[1]||(w.hash="#"),w.query=r?t.decode(b.search.substr(1)):w.search.substr(1),w.pathname=U+d(b.pathname).replace(/"/g,"%22"),"about:"===w.protocol&&"blank"===w.pathname&&(w.protocol="",w.pathname=""),x&&"/"!==e[0]&&(w.pathname=w.pathname.substr(1)),g&&!i.test(g)&&"/"!==e.slice(-1)&&"/"===w.pathname&&(w.pathname=""),w.path=w.pathname+w.search,w.auth=[b.username,b.password].map(decodeURIComponent).filter(Boolean).join(":"),w.port=b.port,j&&(w.host=w.host.replace(j+"00",j),w.port=w.port.slice(0,-2)),w.href=U?""+w.pathname+w.search+w.hash:o(w);var O=/^(file)/.test(w.href)?["host","hostname"]:[];return Object.keys(w).forEach(function(e){~O.indexOf(e)||(w[e]=w[e]||null)}),w}exports.parse=g,exports.format=o,exports.resolve=n,exports.resolveObject=function(e,t){return g(n(e,t))},exports.Url=l;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/finally-polyfill.min.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/finally-polyfill.min.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

Promise.prototype.finally=function(n){if("function"!=typeof n)return this.then(n,n);var t=this.constructor||Promise;return this.then(function(r){return t.resolve(n()).then(function(){return r})},function(r){return t.resolve(n()).then(function(){throw r})})};

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/unfetch.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/unfetch.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports=function(e,n){return n=n||{},new Promise(function(t,r){var s=new XMLHttpRequest,o=[],u=[],i={},a=function(){return{ok:2==(s.status/100|0),statusText:s.statusText,status:s.status,url:s.responseURL,text:function(){return Promise.resolve(s.responseText)},json:function(){return Promise.resolve(JSON.parse(s.responseText))},blob:function(){return Promise.resolve(new Blob([s.response]))},clone:a,headers:{keys:function(){return o},entries:function(){return u},get:function(e){return i[e.toLowerCase()]},has:function(e){return e.toLowerCase()in i}}}};for(var l in s.open(n.method||"get",e,!0),s.onload=function(){s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm,function(e,n,t){o.push(n=n.toLowerCase()),u.push([n,t]),i[n]=i[n]?i[n]+","+t:t}),t(a())},s.onerror=r,s.withCredentials="include"==n.credentials,n.headers)s.setRequestHeader(l,n.headers[l]);s.send(n.body||null)})};
//# sourceMappingURL=unfetch.js.map


/***/ }),

/***/ "./node_modules/next/dist/client/dev/dev-build-watcher.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/dev-build-watcher.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = initializeBuildWatcher;

var _eventsource = __webpack_require__(/*! ./error-overlay/eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");

function initializeBuildWatcher() {
  var shadowHost = document.createElement('div');
  shadowHost.id = '__next-build-watcher'; // Make sure container is fixed and on a high zIndex so it shows

  shadowHost.style.position = 'fixed';
  shadowHost.style.bottom = '10px';
  shadowHost.style.right = '20px';
  shadowHost.style.width = 0;
  shadowHost.style.height = 0;
  shadowHost.style.zIndex = 99999;
  document.body.appendChild(shadowHost);
  var shadowRoot;
  var prefix = '';

  if (shadowHost.attachShadow) {
    shadowRoot = shadowHost.attachShadow({
      mode: 'open'
    });
  } else {
    // If attachShadow is undefined then the browser does not support
    // the Shadow DOM, we need to prefix all the names so there
    // will be no conflicts
    shadowRoot = shadowHost;
    prefix = '__next-build-watcher-';
  } // Container


  var container = createContainer(prefix);
  shadowRoot.appendChild(container); // CSS

  var css = createCss(prefix);
  shadowRoot.appendChild(css); // State

  var isVisible = false;
  var isBuilding = false;
  var timeoutId = null; // Handle events

  var evtSource = (0, _eventsource.getEventSourceWrapper)({
    path: '/_next/webpack-hmr'
  });
  evtSource.addMessageListener(function (event) {
    // This is the heartbeat event
    if (event.data === "\uD83D\uDC93") {
      return;
    }

    try {
      handleMessage(event);
    } catch (_unused) {}
  });

  function handleMessage(event) {
    var obj = JSON.parse(event.data); // eslint-disable-next-line default-case

    switch (obj.action) {
      case 'building':
        timeoutId && clearTimeout(timeoutId);
        isVisible = true;
        isBuilding = true;
        updateContainer();
        break;

      case 'built':
      case 'sync':
        isBuilding = false; // Wait for the fade out transtion to complete

        timeoutId = setTimeout(function () {
          isVisible = false;
          updateContainer();
        }, 100);
        updateContainer();
        break;
    }
  }

  function updateContainer() {
    if (isBuilding) {
      container.classList.add(prefix + "building");
    } else {
      container.classList.remove(prefix + "building");
    }

    if (isVisible) {
      container.classList.add(prefix + "visible");
    } else {
      container.classList.remove(prefix + "visible");
    }
  }
}

function createContainer(prefix) {
  var container = document.createElement('div');
  container.id = prefix + "container";
  container.innerHTML = "\n    <div id=\"" + prefix + "icon-wrapper\">\n      <svg viewBox=\"0 0 226 200\">\n        <defs>\n          <linearGradient\n            x1=\"114.720775%\"\n            y1=\"181.283245%\"\n            x2=\"39.5399306%\"\n            y2=\"100%\"\n            id=\"" + prefix + "linear-gradient\"\n          >\n            <stop stop-color=\"#FFFFFF\" offset=\"0%\" />\n            <stop stop-color=\"#000000\" offset=\"100%\" />\n          </linearGradient>\n        </defs>\n        <g id=\"" + prefix + "icon-group\" fill=\"none\" stroke=\"url(#" + prefix + "linear-gradient)\" stroke-width=\"18\">\n          <path d=\"M113,5.08219117 L4.28393801,197.5 L221.716062,197.5 L113,5.08219117 Z\" />\n        </g>\n      </svg>\n    </div>\n  ";
  return container;
}

function createCss(prefix) {
  var css = document.createElement('style');
  css.textContent = "\n    #" + prefix + "container {\n      position: absolute;\n      bottom: 10px;\n      right: 30px;\n\n      background: #fff;\n      color: #000;\n      font: initial;\n      cursor: initial;\n      letter-spacing: initial;\n      text-shadow: initial;\n      text-transform: initial;\n      visibility: initial;\n\n      padding: 8px 10px;\n      align-items: center;\n      box-shadow: 0 11px 40px 0 rgba(0, 0, 0, 0.25), 0 2px 10px 0 rgba(0, 0, 0, 0.12);\n\n      display: none;\n      opacity: 0;\n      transition: opacity 0.1s ease, bottom 0.1s ease;\n      animation: " + prefix + "fade-in 0.1s ease-in-out;\n    }\n\n    #" + prefix + "container." + prefix + "visible {\n      display: flex;\n    }\n\n    #" + prefix + "container." + prefix + "building {\n      bottom: 20px;\n      opacity: 1;\n    }\n\n    #" + prefix + "icon-wrapper {\n      width: 16px;\n      height: 16px;\n    }\n\n    #" + prefix + "icon-wrapper > svg {\n      width: 100%;\n      height: 100%;\n    }\n\n    #" + prefix + "icon-group {\n      animation: " + prefix + "strokedash 1s ease-in-out both infinite;\n    }\n\n    @keyframes " + prefix + "fade-in {\n      from {\n        bottom: 10px;\n        opacity: 0;\n      }\n      to {\n        bottom: 20px;\n        opacity: 1;\n      }\n    }\n\n    @keyframes " + prefix + "strokedash {\n      0% {\n        stroke-dasharray: 0 226;\n      }\n      80%,\n      100% {\n        stroke-dasharray: 659 226;\n      }\n    }\n  ";
  return css;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/eventsource.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getEventSourceWrapper = getEventSourceWrapper;
var eventCallbacks = [];

function EventSourceWrapper(options) {
  var source;
  var lastActivity = new Date();
  var listeners = [];

  if (!options.timeout) {
    options.timeout = 20 * 1000;
  }

  init();
  var timer = setInterval(function () {
    if (new Date() - lastActivity > options.timeout) {
      handleDisconnect();
    }
  }, options.timeout / 2);

  function init() {
    source = new window.EventSource(options.path);
    source.onopen = handleOnline;
    source.onerror = handleDisconnect;
    source.onmessage = handleMessage;
  }

  function handleOnline() {
    if (options.log) console.log('[HMR] connected');
    lastActivity = new Date();
  }

  function handleMessage(event) {
    lastActivity = new Date();

    for (var i = 0; i < listeners.length; i++) {
      listeners[i](event);
    }

    if (event.data.indexOf('action') !== -1) {
      eventCallbacks.forEach(function (cb) {
        return cb(event);
      });
    }
  }

  function handleDisconnect() {
    clearInterval(timer);
    source.close();
    setTimeout(init, options.timeout);
  }

  return {
    close: function close() {
      clearInterval(timer);
      source.close();
    },
    addMessageListener: function addMessageListener(fn) {
      listeners.push(fn);
    }
  };
}

_c = EventSourceWrapper;

function getEventSourceWrapper(options) {
  if (!options.ondemand) {
    return {
      addMessageListener: function addMessageListener(cb) {
        eventCallbacks.push(cb);
      }
    };
  }

  return EventSourceWrapper(options);
}

var _c;

$RefreshReg$(_c, "EventSourceWrapper");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
/**
MIT License
Copyright (c) 2015-present, Facebook, Inc.
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
// This file is based on https://github.com/facebook/create-react-app/blob/7b1a32be6ec9f99a6c9a3c66813f3ac09c4736b9/packages/react-dev-utils/formatWebpackMessages.js
// It's been edited to remove chalk and CRA-specific logic

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var friendlySyntaxErrorLabel = 'Syntax error:';

function isLikelyASyntaxError(message) {
  return message.indexOf(friendlySyntaxErrorLabel) !== -1;
} // Cleans up webpack error messages.


function formatMessage(message) {
  var lines = message.split('\n'); // Strip Webpack-added headers off errors/warnings
  // https://github.com/webpack/webpack/blob/master/lib/ModuleError.js

  lines = lines.filter(function (line) {
    return !/Module [A-z ]+\(from/.test(line);
  }); // Transform parsing error into syntax error
  // TODO: move this to our ESLint formatter?

  lines = lines.map(function (line) {
    var parsingError = /Line (\d+):(?:(\d+):)?\s*Parsing error: (.+)$/.exec(line);

    if (!parsingError) {
      return line;
    }

    var _parsingError = _slicedToArray(parsingError, 4),
        errorLine = _parsingError[1],
        errorColumn = _parsingError[2],
        errorMessage = _parsingError[3];

    return friendlySyntaxErrorLabel + " " + errorMessage + " (" + errorLine + ":" + errorColumn + ")";
  });
  message = lines.join('\n'); // Smoosh syntax errors (commonly found in CSS)

  message = message.replace(/SyntaxError\s+\((\d+):(\d+)\)\s*(.+?)\n/g, friendlySyntaxErrorLabel + " $3 ($1:$2)\n"); // Clean up export errors

  message = message.replace(/^.*export '(.+?)' was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$2'.");
  message = message.replace(/^.*export 'default' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$2' does not contain a default export (imported as '$1').");
  message = message.replace(/^.*export '(.+?)' \(imported as '(.+?)'\) was not found in '(.+?)'.*$/gm, "Attempted import error: '$1' is not exported from '$3' (imported as '$2').");
  lines = message.split('\n'); // Remove leading newline

  if (lines.length > 2 && lines[1].trim() === '') {
    lines.splice(1, 1);
  } // Clean up file name


  lines[0] = lines[0].replace(/^(.*) \d+:\d+-\d+$/, '$1'); // Cleans up verbose "module not found" messages for files and packages.

  if (lines[1] && lines[1].indexOf('Module not found: ') === 0) {
    lines = [lines[0], lines[1].replace('Error: ', '').replace('Module not found: Cannot find file:', 'Cannot find file:')];
  } // Add helpful message for users trying to use Sass for the first time


  if (lines[1] && lines[1].match(/Cannot find module.+node-sass/)) {
    // ./file.module.scss (<<loader info>>) => ./file.module.scss
    lines[0] = lines[0].replace(/(.+) \(.+?(?=\?\?).+?\)/, '$1');
    lines[1] = "To use Next.js' built-in Sass support, you first need to install `sass`.\n";
    lines[1] += 'Run `npm i sass` or `yarn add sass` inside your workspace.\n';
    lines[1] += '\nLearn more: https://err.sh/next.js/install-sass';
  }

  message = lines.join('\n'); // Internal stacks are generally useless so we strip them... with the
  // exception of stacks containing `webpack:` because they're normally
  // from user code generated by Webpack. For more information see
  // https://github.com/facebook/create-react-app/pull/1050

  message = message.replace(/^\s*at\s((?!webpack:).)*:\d+:\d+[\s)]*(\n|$)/gm, ''); // at ... ...:x:y

  message = message.replace(/^\s*at\s<anonymous>(\n|$)/gm, ''); // at <anonymous>

  lines = message.split('\n'); // Remove duplicated newlines

  lines = lines.filter(function (line, index, arr) {
    return index === 0 || line.trim() !== '' || line.trim() !== arr[index - 1].trim();
  }); // Reassemble the message

  message = lines.join('\n');
  return message.trim();
}

function formatWebpackMessages(json) {
  var formattedErrors = json.errors.map(function (message) {
    return formatMessage(message, true);
  });
  var formattedWarnings = json.warnings.map(function (message) {
    return formatMessage(message, false);
  });
  var result = {
    errors: formattedErrors,
    warnings: formattedWarnings
  };

  if (result.errors.some(isLikelyASyntaxError)) {
    // If there are any syntax errors, show just them.
    result.errors = result.errors.filter(isLikelyASyntaxError);
  }

  return result;
}

module.exports = formatWebpackMessages;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports["default"] = connect;

var DevOverlay = _interopRequireWildcard(__webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"));

var _stripAnsi = _interopRequireDefault(__webpack_require__(/*! next/dist/compiled/strip-ansi */ "./node_modules/next/dist/compiled/strip-ansi/index.js"));

var _eventsource = __webpack_require__(/*! ./eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");

var _formatWebpackMessages = _interopRequireDefault(__webpack_require__(/*! ./format-webpack-messages */ "./node_modules/next/dist/client/dev/error-overlay/format-webpack-messages.js"));
/**
* MIT License
*
* Copyright (c) 2013-present, Facebook, Inc.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in all
* copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*/
// This file is a modified version of the Create React App HMR dev client that
// can be found here:
// https://github.com/facebook/create-react-app/blob/v3.4.1/packages/react-dev-utils/webpackHotDevClient.js
// This alternative WebpackDevServer combines the functionality of:
// https://github.com/webpack/webpack-dev-server/blob/webpack-1/client/index.js
// https://github.com/webpack/webpack/blob/webpack-1/hot/dev-server.js
// It only supports their simplest configuration (hot updates on same server).
// It makes some opinionated choices on top, like adding a syntax error overlay
// that looks similar to our console output. The error overlay is inspired by:
// https://github.com/glenjamin/webpack-hot-middleware


var hadRuntimeError = false;
var customHmrEventHandler;

function connect(options) {
  DevOverlay.register();
  (0, _eventsource.getEventSourceWrapper)(options).addMessageListener(function (event) {
    // This is the heartbeat event
    if (event.data === "\uD83D\uDC93") {
      return;
    }

    try {
      processMessage(event);
    } catch (ex) {
      console.warn('Invalid HMR message: ' + event.data + '\n' + ex);
    }
  });
  return {
    subscribeToHmrEvent: function subscribeToHmrEvent(handler) {
      customHmrEventHandler = handler;
    },
    onUnrecoverableError: function onUnrecoverableError() {
      hadRuntimeError = true;
    }
  };
} // Remember some state related to hot module replacement.


var isFirstCompilation = true;
var mostRecentCompilationHash = null;
var hasCompileErrors = false;

function clearOutdatedErrors() {
  // Clean up outdated compile errors, if any.
  if (typeof console !== 'undefined' && typeof console.clear === 'function') {
    if (hasCompileErrors) {
      console.clear();
    }
  }
} // Successful compilation.


function handleSuccess() {
  clearOutdatedErrors();
  var isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false; // Attempt to apply hot updates or reload.

  if (isHotUpdate) {
    tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {
      // Only dismiss it when we're sure it's a hot update.
      // Otherwise it would flicker right before the reload.
      onFastRefresh(hasUpdates);
    });
  }
} // Compilation with warnings (e.g. ESLint).


function handleWarnings(warnings) {
  clearOutdatedErrors();
  var isHotUpdate = !isFirstCompilation;
  isFirstCompilation = false;
  hasCompileErrors = false;

  function printWarnings() {
    // Print warnings to the console.
    var formatted = (0, _formatWebpackMessages["default"])({
      warnings: warnings,
      errors: []
    });

    if (typeof console !== 'undefined' && typeof console.warn === 'function') {
      for (var i = 0; i < formatted.warnings.length; i++) {
        if (i === 5) {
          console.warn('There were more warnings in other files.\n' + 'You can find a complete log in the terminal.');
          break;
        }

        console.warn((0, _stripAnsi["default"])(formatted.warnings[i]));
      }
    }
  }

  printWarnings(); // Attempt to apply hot updates or reload.

  if (isHotUpdate) {
    tryApplyUpdates(function onSuccessfulHotUpdate(hasUpdates) {
      // Only dismiss it when we're sure it's a hot update.
      // Otherwise it would flicker right before the reload.
      onFastRefresh(hasUpdates);
    });
  }
} // Compilation with errors (e.g. syntax error or missing modules).


function handleErrors(errors) {
  clearOutdatedErrors();
  isFirstCompilation = false;
  hasCompileErrors = true; // "Massage" webpack messages.

  var formatted = (0, _formatWebpackMessages["default"])({
    errors: errors,
    warnings: []
  }); // Only show the first error.

  DevOverlay.onBuildError(formatted.errors[0]); // Also log them to the console.

  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    for (var i = 0; i < formatted.errors.length; i++) {
      console.error((0, _stripAnsi["default"])(formatted.errors[i]));
    }
  } // Do not attempt to reload now.
  // We will reload on next success instead.


  if (undefined) {
    if (self.__NEXT_HMR_CB) {
      self.__NEXT_HMR_CB(formatted.errors[0]);

      self.__NEXT_HMR_CB = null;
    }
  }
}

function onFastRefresh(hasUpdates) {
  DevOverlay.onBuildOk();

  if (hasUpdates) {
    DevOverlay.onRefresh();
  }

  console.log('[Fast Refresh] done');
} // There is a newer version of the code available.


function handleAvailableHash(hash) {
  // Update last known compilation hash.
  mostRecentCompilationHash = hash;
} // Handle messages from the server.


function processMessage(e) {
  var obj = JSON.parse(e.data);

  switch (obj.action) {
    case 'building':
      {
        console.log('[Fast Refresh] rebuilding');
        break;
      }

    case 'built':
    case 'sync':
      {
        if (obj.hash) {
          handleAvailableHash(obj.hash);
        }

        var errors = obj.errors,
            warnings = obj.warnings;
        var hasErrors = Boolean(errors && errors.length);

        if (hasErrors) {
          return handleErrors(errors);
        }

        var hasWarnings = Boolean(warnings && warnings.length);

        if (hasWarnings) {
          return handleWarnings(warnings);
        }

        return handleSuccess();
      }

    default:
      {
        if (customHmrEventHandler) {
          customHmrEventHandler(obj);
          break;
        }

        break;
      }
  }
} // Is there a newer version of this code available?


function isUpdateAvailable() {
  /* globals __webpack_hash__ */
  // __webpack_hash__ is the hash of the current compilation.
  // It's a global variable injected by Webpack.
  return mostRecentCompilationHash !== __webpack_require__.h();
} // Webpack disallows updates in other states.


function canApplyUpdates() {
  return module.hot.status() === 'idle';
}

function afterApplyUpdates(fn) {
  if (canApplyUpdates()) {
    fn();
  } else {
    var handler = function handler(status) {
      if (status === 'idle') {
        module.hot.removeStatusHandler(handler);
        fn();
      }
    };

    module.hot.addStatusHandler(handler);
  }
} // Attempt to update code on the fly, fall back to a hard reload.


function tryApplyUpdates(onHotUpdateSuccess) {
  if (false) {}

  if (!isUpdateAvailable() || !canApplyUpdates()) {
    return;
  }

  function handleApplyUpdates(err, updatedModules) {
    if (err || hadRuntimeError || !updatedModules) {
      if (err) {
        console.warn('[Fast Refresh] performing full reload\n\n' + "Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React tree.\n" + 'You might have a file which renders a React component but also exports a value that is imported by a non-React component.\n' + 'Consider migrating the non-React component export to a separate file and importing it into both files.\n\n' + 'It is also possible you are using class components at the top-level of your application, which disables Fast Refresh.\n' + 'Fast Refresh requires at least one function component in your React tree.');
      } else if (hadRuntimeError) {
        console.warn('[Fast Refresh] performing full reload because your application had an unrecoverable error');
      }

      window.location.reload();
      return;
    }

    var hasUpdates = Boolean(updatedModules.length);

    if (typeof onHotUpdateSuccess === 'function') {
      // Maybe we want to do something.
      onHotUpdateSuccess(hasUpdates);
    }

    if (isUpdateAvailable()) {
      // While we were updating, there was a new update! Do it again.
      tryApplyUpdates(hasUpdates ? undefined : onHotUpdateSuccess);
    } else {
      if (undefined) {
        afterApplyUpdates(function () {
          if (self.__NEXT_HMR_CB) {
            self.__NEXT_HMR_CB();

            self.__NEXT_HMR_CB = null;
          }
        });
      }
    }
  } // https://webpack.js.org/api/hot-module-replacement/#check


  module.hot.check(
  /* autoApply */
  true).then(function (updatedModules) {
    handleApplyUpdates(null, updatedModules);
  }, function (err) {
    handleApplyUpdates(err, null);
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/event-source-polyfill.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/event-source-polyfill.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _unfetch = _interopRequireDefault(__webpack_require__(/*! next/dist/build/polyfills/unfetch */ "./node_modules/next/dist/build/polyfills/unfetch.js"));
/* eslint-disable */
// Improved version of https://github.com/Yaffle/EventSource/
// Available under MIT License (MIT)
// Only tries to support IE11 and nothing below


var document = window.document;
var Response = window.Response;
var TextDecoder = window.TextDecoder;
var TextEncoder = window.TextEncoder;
var AbortController = window.AbortController;

if (AbortController == undefined) {
  AbortController = function AbortController() {
    this.signal = null;

    this.abort = function () {};
  };
}

function TextDecoderPolyfill() {
  this.bitsNeeded = 0;
  this.codePoint = 0;
}

_c = TextDecoderPolyfill;

TextDecoderPolyfill.prototype.decode = function (octets) {
  function valid(codePoint, shift, octetsCount) {
    if (octetsCount === 1) {
      return codePoint >= 0x0080 >> shift && codePoint << shift <= 0x07ff;
    }

    if (octetsCount === 2) {
      return codePoint >= 0x0800 >> shift && codePoint << shift <= 0xd7ff || codePoint >= 0xe000 >> shift && codePoint << shift <= 0xffff;
    }

    if (octetsCount === 3) {
      return codePoint >= 0x010000 >> shift && codePoint << shift <= 0x10ffff;
    }

    throw new Error();
  }

  function octetsCount(bitsNeeded, codePoint) {
    if (bitsNeeded === 6 * 1) {
      return codePoint >> 6 > 15 ? 3 : codePoint > 31 ? 2 : 1;
    }

    if (bitsNeeded === 6 * 2) {
      return codePoint > 15 ? 3 : 2;
    }

    if (bitsNeeded === 6 * 3) {
      return 3;
    }

    throw new Error();
  }

  var REPLACER = 0xfffd;
  var string = '';
  var bitsNeeded = this.bitsNeeded;
  var codePoint = this.codePoint;

  for (var i = 0; i < octets.length; i += 1) {
    var octet = octets[i];

    if (bitsNeeded !== 0) {
      if (octet < 128 || octet > 191 || !valid(codePoint << 6 | octet & 63, bitsNeeded - 6, octetsCount(bitsNeeded, codePoint))) {
        bitsNeeded = 0;
        codePoint = REPLACER;
        string += String.fromCharCode(codePoint);
      }
    }

    if (bitsNeeded === 0) {
      if (octet >= 0 && octet <= 127) {
        bitsNeeded = 0;
        codePoint = octet;
      } else if (octet >= 192 && octet <= 223) {
        bitsNeeded = 6 * 1;
        codePoint = octet & 31;
      } else if (octet >= 224 && octet <= 239) {
        bitsNeeded = 6 * 2;
        codePoint = octet & 15;
      } else if (octet >= 240 && octet <= 247) {
        bitsNeeded = 6 * 3;
        codePoint = octet & 7;
      } else {
        bitsNeeded = 0;
        codePoint = REPLACER;
      }

      if (bitsNeeded !== 0 && !valid(codePoint, bitsNeeded, octetsCount(bitsNeeded, codePoint))) {
        bitsNeeded = 0;
        codePoint = REPLACER;
      }
    } else {
      bitsNeeded -= 6;
      codePoint = codePoint << 6 | octet & 63;
    }

    if (bitsNeeded === 0) {
      if (codePoint <= 0xffff) {
        string += String.fromCharCode(codePoint);
      } else {
        string += String.fromCharCode(0xd800 + (codePoint - 0xffff - 1 >> 10));
        string += String.fromCharCode(0xdc00 + (codePoint - 0xffff - 1 & 0x3ff));
      }
    }
  }

  this.bitsNeeded = bitsNeeded;
  this.codePoint = codePoint;
  return string;
}; // Firefox < 38 throws an error with stream option


var supportsStreamOption = function supportsStreamOption() {
  try {
    return new TextDecoder().decode(new TextEncoder().encode('test'), {
      stream: true
    }) === 'test';
  } catch (error) {
    console.log(error);
  }

  return false;
}; // IE, Edge


if (TextDecoder == undefined || TextEncoder == undefined || !supportsStreamOption()) {
  TextDecoder = TextDecoderPolyfill;
}

var k = function k() {};

function XHRWrapper(xhr) {
  this.withCredentials = false;
  this.responseType = '';
  this.readyState = 0;
  this.status = 0;
  this.statusText = '';
  this.responseText = '';
  this.onprogress = k;
  this.onreadystatechange = k;
  this._contentType = '';
  this._xhr = xhr;
  this._sendTimeout = 0;
  this._abort = k;
}

_c2 = XHRWrapper;

XHRWrapper.prototype.open = function (method, url) {
  this._abort(true);

  var that = this;
  var xhr = this._xhr;
  var state = 1;
  var timeout = 0;

  this._abort = function (silent) {
    if (that._sendTimeout !== 0) {
      clearTimeout(that._sendTimeout);
      that._sendTimeout = 0;
    }

    if (state === 1 || state === 2 || state === 3) {
      state = 4;
      xhr.onload = k;
      xhr.onerror = k;
      xhr.onabort = k;
      xhr.onprogress = k;
      xhr.onreadystatechange = k; // IE 8 - 9: XDomainRequest#abort() does not fire any event
      // Opera < 10: XMLHttpRequest#abort() does not fire any event

      xhr.abort();

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      if (!silent) {
        that.readyState = 4;
        that.onreadystatechange();
      }
    }

    state = 0;
  };

  var onStart = function onStart() {
    if (state === 1) {
      // state = 2;
      var status = 0;
      var statusText = '';
      var contentType = undefined;

      if (!('contentType' in xhr)) {
        try {
          status = xhr.status;
          statusText = xhr.statusText;
          contentType = xhr.getResponseHeader('Content-Type');
        } catch (error) {
          // IE < 10 throws exception for `xhr.status` when xhr.readyState === 2 || xhr.readyState === 3
          // Opera < 11 throws exception for `xhr.status` when xhr.readyState === 2
          // https://bugs.webkit.org/show_bug.cgi?id=29121
          status = 0;
          statusText = '';
          contentType = undefined; // Firefox < 14, Chrome ?, Safari ?
          // https://bugs.webkit.org/show_bug.cgi?id=29658
          // https://bugs.webkit.org/show_bug.cgi?id=77854
        }
      } else {
        status = 200;
        statusText = 'OK';
        contentType = xhr.contentType;
      }

      if (status !== 0) {
        state = 2;
        that.readyState = 2;
        that.status = status;
        that.statusText = statusText;
        that._contentType = contentType;
        that.onreadystatechange();
      }
    }
  };

  var onProgress = function onProgress() {
    onStart();

    if (state === 2 || state === 3) {
      state = 3;
      var responseText = '';

      try {
        responseText = xhr.responseText;
      } catch (error) {// IE 8 - 9 with XMLHttpRequest
      }

      that.readyState = 3;
      that.responseText = responseText;
      that.onprogress();
    }
  };

  var onFinish = function onFinish() {
    // Firefox 52 fires "readystatechange" (xhr.readyState === 4) without final "readystatechange" (xhr.readyState === 3)
    // IE 8 fires "onload" without "onprogress"
    onProgress();

    if (state === 1 || state === 2 || state === 3) {
      state = 4;

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      that.readyState = 4;
      that.onreadystatechange();
    }
  };

  var onReadyStateChange = function onReadyStateChange() {
    if (xhr != undefined) {
      // Opera 12
      if (xhr.readyState === 4) {
        onFinish();
      } else if (xhr.readyState === 3) {
        onProgress();
      } else if (xhr.readyState === 2) {
        onStart();
      }
    }
  };

  var onTimeout = function onTimeout() {
    timeout = setTimeout(function () {
      onTimeout();
    }, 500);

    if (xhr.readyState === 3) {
      onProgress();
    }
  }; // XDomainRequest#abort removes onprogress, onerror, onload


  xhr.onload = onFinish;
  xhr.onerror = onFinish; // improper fix to match Firefox behaviour, but it is better than just ignore abort
  // see https://bugzilla.mozilla.org/show_bug.cgi?id=768596
  // https://bugzilla.mozilla.org/show_bug.cgi?id=880200
  // https://code.google.com/p/chromium/issues/detail?id=153570
  // IE 8 fires "onload" without "onprogress

  xhr.onabort = onFinish; // https://bugzilla.mozilla.org/show_bug.cgi?id=736723

  if (!('sendAsBinary' in XMLHttpRequest.prototype) && !('mozAnon' in XMLHttpRequest.prototype)) {
    xhr.onprogress = onProgress;
  } // IE 8 - 9 (XMLHTTPRequest)
  // Opera < 12
  // Firefox < 3.5
  // Firefox 3.5 - 3.6 - ? < 9.0
  // onprogress is not fired sometimes or delayed
  // see also #64


  xhr.onreadystatechange = onReadyStateChange;

  if ('contentType' in xhr) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + 'padding=true';
  }

  xhr.open(method, url, true);

  if ('readyState' in xhr) {
    // workaround for Opera 12 issue with "progress" events
    // #91
    timeout = setTimeout(function () {
      onTimeout();
    }, 0);
  }
};

XHRWrapper.prototype.abort = function () {
  this._abort(false);
};

XHRWrapper.prototype.getResponseHeader = function (name) {
  return this._contentType;
};

XHRWrapper.prototype.setRequestHeader = function (name, value) {
  var xhr = this._xhr;

  if ('setRequestHeader' in xhr) {
    xhr.setRequestHeader(name, value);
  }
};

XHRWrapper.prototype.getAllResponseHeaders = function () {
  return this._xhr.getAllResponseHeaders != undefined ? this._xhr.getAllResponseHeaders() : '';
};

XHRWrapper.prototype.send = function () {
  // loading indicator in Safari < ? (6), Chrome < 14, Firefox
  if (!('ontimeout' in XMLHttpRequest.prototype) && document != undefined && document.readyState != undefined && document.readyState !== 'complete') {
    var that = this;
    that._sendTimeout = setTimeout(function () {
      that._sendTimeout = 0;
      that.send();
    }, 4);
    return;
  }

  var xhr = this._xhr; // withCredentials should be set after "open" for Safari and Chrome (< 19 ?)

  xhr.withCredentials = this.withCredentials;
  xhr.responseType = this.responseType;

  try {
    // xhr.send(); throws "Not enough arguments" in Firefox 3.0
    xhr.send(undefined);
  } catch (error1) {
    // Safari 5.1.7, Opera 12
    throw error1;
  }
};

function toLowerCase(name) {
  return name.replace(/[A-Z]/g, function (c) {
    return String.fromCharCode(c.charCodeAt(0) + 0x20);
  });
}

function HeadersPolyfill(all) {
  // Get headers: implemented according to mozilla's example code: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders#Example
  var map = Object.create(null);
  var array = all.split('\r\n');

  for (var i = 0; i < array.length; i += 1) {
    var line = array[i];
    var parts = line.split(': ');
    var name = parts.shift();
    var value = parts.join(': ');
    map[toLowerCase(name)] = value;
  }

  this._map = map;
}

_c3 = HeadersPolyfill;

HeadersPolyfill.prototype.get = function (name) {
  return this._map[toLowerCase(name)];
};

function XHRTransport() {}

_c4 = XHRTransport;

XHRTransport.prototype.open = function (xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {
  xhr.open('GET', url);
  var offset = 0;

  xhr.onprogress = function () {
    var responseText = xhr.responseText;
    var chunk = responseText.slice(offset);
    offset += chunk.length;
    onProgressCallback(chunk);
  };

  xhr.onreadystatechange = function () {
    if (xhr.readyState === 2) {
      var status = xhr.status;
      var statusText = xhr.statusText;
      var contentType = xhr.getResponseHeader('Content-Type');
      var headers = xhr.getAllResponseHeaders();
      onStartCallback(status, statusText, contentType, new HeadersPolyfill(headers), function () {
        xhr.abort();
      });
    } else if (xhr.readyState === 4) {
      onFinishCallback();
    }
  };

  xhr.withCredentials = withCredentials;
  xhr.responseType = 'text';

  for (var name in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, name)) {
      xhr.setRequestHeader(name, headers[name]);
    }
  }

  xhr.send();
};

function HeadersWrapper(headers) {
  this._headers = headers;
}

_c5 = HeadersWrapper;

HeadersWrapper.prototype.get = function (name) {
  return this._headers.get(name);
};

function FetchTransport() {}

_c6 = FetchTransport;

FetchTransport.prototype.open = function (xhr, onStartCallback, onProgressCallback, onFinishCallback, url, withCredentials, headers) {
  var controller = new AbortController();
  var signal = controller.signal; // see #120

  var textDecoder = new TextDecoder();
  (0, _unfetch["default"])(url, {
    headers: headers,
    credentials: withCredentials ? 'include' : 'same-origin',
    signal: signal,
    cache: 'no-store'
  }).then(function (response) {
    var reader = response.body.getReader();
    onStartCallback(response.status, response.statusText, response.headers.get('Content-Type'), new HeadersWrapper(response.headers), function () {
      controller.abort();
      reader.cancel();
    });
    return new Promise(function (resolve, reject) {
      var readNextChunk = function readNextChunk() {
        reader.read().then(function (result) {
          if (result.done) {
            // Note: bytes in textDecoder are ignored
            resolve(undefined);
          } else {
            var chunk = textDecoder.decode(result.value, {
              stream: true
            });
            onProgressCallback(chunk);
            readNextChunk();
          }
        })['catch'](function (error) {
          reject(error);
        });
      };

      readNextChunk();
    });
  }).then(function (result) {
    onFinishCallback();
    return result;
  }, function (error) {
    onFinishCallback();
    return Promise.reject(error);
  });
};

function EventTarget() {
  this._listeners = Object.create(null);
}

_c7 = EventTarget;

function throwError(e) {
  setTimeout(function () {
    throw e;
  }, 0);
}

EventTarget.prototype.dispatchEvent = function (event) {
  event.target = this;
  var typeListeners = this._listeners[event.type];

  if (typeListeners != undefined) {
    var length = typeListeners.length;

    for (var i = 0; i < length; i += 1) {
      var listener = typeListeners[i];

      try {
        if (typeof listener.handleEvent === 'function') {
          listener.handleEvent(event);
        } else {
          listener.call(this, event);
        }
      } catch (e) {
        throwError(e);
      }
    }
  }
};

EventTarget.prototype.addEventListener = function (type, listener) {
  type = String(type);
  var listeners = this._listeners;
  var typeListeners = listeners[type];

  if (typeListeners == undefined) {
    typeListeners = [];
    listeners[type] = typeListeners;
  }

  var found = false;

  for (var i = 0; i < typeListeners.length; i += 1) {
    if (typeListeners[i] === listener) {
      found = true;
    }
  }

  if (!found) {
    typeListeners.push(listener);
  }
};

EventTarget.prototype.removeEventListener = function (type, listener) {
  type = String(type);
  var listeners = this._listeners;
  var typeListeners = listeners[type];

  if (typeListeners != undefined) {
    var filtered = [];

    for (var i = 0; i < typeListeners.length; i += 1) {
      if (typeListeners[i] !== listener) {
        filtered.push(typeListeners[i]);
      }
    }

    if (filtered.length === 0) {
      delete listeners[type];
    } else {
      listeners[type] = filtered;
    }
  }
};

function Event(type) {
  this.type = type;
  this.target = undefined;
}

_c8 = Event;

function MessageEvent(type, options) {
  Event.call(this, type);
  this.data = options.data;
  this.lastEventId = options.lastEventId;
}

_c9 = MessageEvent;
MessageEvent.prototype = Object.create(Event.prototype);

function ConnectionEvent(type, options) {
  Event.call(this, type);
  this.status = options.status;
  this.statusText = options.statusText;
  this.headers = options.headers;
}

_c10 = ConnectionEvent;
ConnectionEvent.prototype = Object.create(Event.prototype);
var WAITING = -1;
var CONNECTING = 0;
var OPEN = 1;
var CLOSED = 2;
var AFTER_CR = -1;
var FIELD_START = 0;
var FIELD = 1;
var VALUE_START = 2;
var VALUE = 3;
var contentTypeRegExp = /^text\/event\-stream;?(\s*charset\=utf\-8)?$/i;
var MINIMUM_DURATION = 1000;
var MAXIMUM_DURATION = 18000000;

var parseDuration = function parseDuration(value, def) {
  var n = parseInt(value, 10);

  if (n !== n) {
    n = def;
  }

  return clampDuration(n);
};

var clampDuration = function clampDuration(n) {
  return Math.min(Math.max(n, MINIMUM_DURATION), MAXIMUM_DURATION);
};

var fire = function fire(that, f, event) {
  try {
    if (typeof f === 'function') {
      f.call(that, event);
    }
  } catch (e) {
    throwError(e);
  }
};

function EventSourcePolyfill(url, options) {
  EventTarget.call(this);
  this.onopen = undefined;
  this.onmessage = undefined;
  this.onerror = undefined;
  this.url = undefined;
  this.readyState = undefined;
  this.withCredentials = undefined;
  this._close = undefined;
  start(this, url, options);
}

_c11 = EventSourcePolyfill;
var isFetchSupported = _unfetch["default"] != undefined && Response != undefined && 'body' in Response.prototype;

function start(es, url, options) {
  url = String(url);
  var withCredentials = options != undefined && Boolean(options.withCredentials);
  var initialRetry = clampDuration(1000);
  var heartbeatTimeout = options != undefined && options.heartbeatTimeout != undefined ? parseDuration(options.heartbeatTimeout, 45000) : clampDuration(45000);
  var lastEventId = '';
  var retry = initialRetry;
  var wasActivity = false;
  var headers = options != undefined && options.headers != undefined ? JSON.parse(JSON.stringify(options.headers)) : undefined;
  var CurrentTransport = options != undefined && options.Transport != undefined ? options.Transport : XMLHttpRequest;
  var xhr = isFetchSupported && !(options != undefined && options.Transport != undefined) ? undefined : new XHRWrapper(new CurrentTransport());
  var transport = xhr == undefined ? new FetchTransport() : new XHRTransport();
  var cancelFunction = undefined;
  var timeout = 0;
  var currentState = WAITING;
  var dataBuffer = '';
  var lastEventIdBuffer = '';
  var eventTypeBuffer = '';
  var textBuffer = '';
  var state = FIELD_START;
  var fieldStart = 0;
  var valueStart = 0;

  var onStart = function onStart(status, statusText, contentType, headers, cancel) {
    if (currentState === CONNECTING) {
      cancelFunction = cancel;

      if (status === 200 && contentType != undefined && contentTypeRegExp.test(contentType)) {
        currentState = OPEN;
        wasActivity = true;
        retry = initialRetry;
        es.readyState = OPEN;
        var event = new ConnectionEvent('open', {
          status: status,
          statusText: statusText,
          headers: headers
        });
        es.dispatchEvent(event);
        fire(es, es.onopen, event);
      } else {
        var message = '';

        if (status !== 200) {
          if (statusText) {
            statusText = statusText.replace(/\s+/g, ' ');
          }

          message = "EventSource's response has a status " + status + ' ' + statusText + ' that is not 200. Aborting the connection.';
        } else {
          message = "EventSource's response has a Content-Type specifying an unsupported type: " + (contentType == undefined ? '-' : contentType.replace(/\s+/g, ' ')) + '. Aborting the connection.';
        }

        throwError(new Error(message));
        close();
        var event = new ConnectionEvent('error', {
          status: status,
          statusText: statusText,
          headers: headers
        });
        es.dispatchEvent(event);
        fire(es, es.onerror, event);
      }
    }
  };

  var onProgress = function onProgress(textChunk) {
    if (currentState === OPEN) {
      var n = -1;

      for (var i = 0; i < textChunk.length; i += 1) {
        var c = textChunk.charCodeAt(i);

        if (c === '\n'.charCodeAt(0) || c === '\r'.charCodeAt(0)) {
          n = i;
        }
      }

      var chunk = (n !== -1 ? textBuffer : '') + textChunk.slice(0, n + 1);
      textBuffer = (n === -1 ? textBuffer : '') + textChunk.slice(n + 1);

      if (chunk !== '') {
        wasActivity = true;
      }

      for (var position = 0; position < chunk.length; position += 1) {
        var c = chunk.charCodeAt(position);

        if (state === AFTER_CR && c === '\n'.charCodeAt(0)) {
          state = FIELD_START;
        } else {
          if (state === AFTER_CR) {
            state = FIELD_START;
          }

          if (c === '\r'.charCodeAt(0) || c === '\n'.charCodeAt(0)) {
            if (state !== FIELD_START) {
              if (state === FIELD) {
                valueStart = position + 1;
              }

              var field = chunk.slice(fieldStart, valueStart - 1);
              var value = chunk.slice(valueStart + (valueStart < position && chunk.charCodeAt(valueStart) === ' '.charCodeAt(0) ? 1 : 0), position);

              if (field === 'data') {
                dataBuffer += '\n';
                dataBuffer += value;
              } else if (field === 'id') {
                lastEventIdBuffer = value;
              } else if (field === 'event') {
                eventTypeBuffer = value;
              } else if (field === 'retry') {
                initialRetry = parseDuration(value, initialRetry);
                retry = initialRetry;
              } else if (field === 'heartbeatTimeout') {
                heartbeatTimeout = parseDuration(value, heartbeatTimeout);

                if (timeout !== 0) {
                  clearTimeout(timeout);
                  timeout = setTimeout(function () {
                    onTimeout();
                  }, heartbeatTimeout);
                }
              }
            }

            if (state === FIELD_START) {
              if (dataBuffer !== '') {
                lastEventId = lastEventIdBuffer;

                if (eventTypeBuffer === '') {
                  eventTypeBuffer = 'message';
                }

                var event = new MessageEvent(eventTypeBuffer, {
                  data: dataBuffer.slice(1),
                  lastEventId: lastEventIdBuffer
                });
                es.dispatchEvent(event);

                if (eventTypeBuffer === 'message') {
                  fire(es, es.onmessage, event);
                }

                if (currentState === CLOSED) {
                  return;
                }
              }

              dataBuffer = '';
              eventTypeBuffer = '';
            }

            state = c === '\r'.charCodeAt(0) ? AFTER_CR : FIELD_START;
          } else {
            if (state === FIELD_START) {
              fieldStart = position;
              state = FIELD;
            }

            if (state === FIELD) {
              if (c === ':'.charCodeAt(0)) {
                valueStart = position + 1;
                state = VALUE_START;
              }
            } else if (state === VALUE_START) {
              state = VALUE;
            }
          }
        }
      }
    }
  };

  var onFinish = function onFinish() {
    if (currentState === OPEN || currentState === CONNECTING) {
      currentState = WAITING;

      if (timeout !== 0) {
        clearTimeout(timeout);
        timeout = 0;
      }

      timeout = setTimeout(function () {
        onTimeout();
      }, retry);
      retry = clampDuration(Math.min(initialRetry * 16, retry * 2));
      es.readyState = CONNECTING;
      var event = new Event('error');
      es.dispatchEvent(event);
      fire(es, es.onerror, event);
    }
  };

  var close = function close() {
    currentState = CLOSED;

    if (cancelFunction != undefined) {
      cancelFunction();
      cancelFunction = undefined;
    }

    if (timeout !== 0) {
      clearTimeout(timeout);
      timeout = 0;
    }

    es.readyState = CLOSED;
  };

  var onTimeout = function onTimeout() {
    timeout = 0;

    if (currentState !== WAITING) {
      if (!wasActivity && cancelFunction != undefined) {
        throwError(new Error('No activity within ' + heartbeatTimeout + ' milliseconds. Reconnecting.'));
        cancelFunction();
        cancelFunction = undefined;
      } else {
        wasActivity = false;
        timeout = setTimeout(function () {
          onTimeout();
        }, heartbeatTimeout);
      }

      return;
    }

    wasActivity = false;
    timeout = setTimeout(function () {
      onTimeout();
    }, heartbeatTimeout);
    currentState = CONNECTING;
    dataBuffer = '';
    eventTypeBuffer = '';
    lastEventIdBuffer = lastEventId;
    textBuffer = '';
    fieldStart = 0;
    valueStart = 0;
    state = FIELD_START; // https://bugzilla.mozilla.org/show_bug.cgi?id=428916
    // Request header field Last-Event-ID is not allowed by Access-Control-Allow-Headers.

    var requestURL = url;

    if (url.slice(0, 5) !== 'data:' && url.slice(0, 5) !== 'blob:') {
      if (lastEventId !== '') {
        requestURL += (url.indexOf('?') === -1 ? '?' : '&') + 'lastEventId=' + encodeURIComponent(lastEventId);
      }
    }

    var requestHeaders = {};
    requestHeaders['Accept'] = 'text/event-stream';

    if (headers != undefined) {
      for (var name in headers) {
        if (Object.prototype.hasOwnProperty.call(headers, name)) {
          requestHeaders[name] = headers[name];
        }
      }
    }

    try {
      transport.open(xhr, onStart, onProgress, onFinish, requestURL, withCredentials, requestHeaders);
    } catch (error) {
      close();
      throw error;
    }
  };

  es.url = url;
  es.readyState = CONNECTING;
  es.withCredentials = withCredentials;
  es._close = close;
  onTimeout();
}

EventSourcePolyfill.prototype = Object.create(EventTarget.prototype);
EventSourcePolyfill.prototype.CONNECTING = CONNECTING;
EventSourcePolyfill.prototype.OPEN = OPEN;
EventSourcePolyfill.prototype.CLOSED = CLOSED;

EventSourcePolyfill.prototype.close = function () {
  this._close();
};

EventSourcePolyfill.CONNECTING = CONNECTING;
EventSourcePolyfill.OPEN = OPEN;
EventSourcePolyfill.CLOSED = CLOSED;
EventSourcePolyfill.prototype.withCredentials = undefined;
var _default = EventSourcePolyfill;
exports["default"] = _default;

var _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11;

$RefreshReg$(_c, "TextDecoderPolyfill");
$RefreshReg$(_c2, "XHRWrapper");
$RefreshReg$(_c3, "HeadersPolyfill");
$RefreshReg$(_c4, "XHRTransport");
$RefreshReg$(_c5, "HeadersWrapper");
$RefreshReg$(_c6, "FetchTransport");
$RefreshReg$(_c7, "EventTarget");
$RefreshReg$(_c8, "Event");
$RefreshReg$(_c9, "MessageEvent");
$RefreshReg$(_c10, "ConnectionEvent");
$RefreshReg$(_c11, "EventSourcePolyfill");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/fouc.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/dev/fouc.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.displayContent = displayContent;

function displayContent(callback) {
  // This is the fallback helper that removes Next.js' no-FOUC styles when
  // CSS mode is enabled. This only really activates if you haven't created
  // _any_ styles in your application yet.
  ;
  (window.requestAnimationFrame || setTimeout)(function () {
    for (var x = document.querySelectorAll('[data-next-hide-fouc]'), i = x.length; i--;) {
      x[i].parentNode.removeChild(x[i]);
    }

    if (callback) {
      callback();
    }
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-client.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-client.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _router = _interopRequireDefault(__webpack_require__(/*! next/router */ "./node_modules/next/dist/client/router.js"));

var _onDemandEntriesUtils = __webpack_require__(/*! ./on-demand-entries-utils */ "./node_modules/next/dist/client/dev/on-demand-entries-utils.js");

var _default = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {
    var assetPrefix;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            assetPrefix = _ref.assetPrefix;

            _router["default"].ready(function () {
              _router["default"].events.on('routeChangeComplete', _onDemandEntriesUtils.setupPing.bind(void 0, assetPrefix, function () {
                return _router["default"].pathname;
              }));
            });

            (0, _onDemandEntriesUtils.setupPing)(assetPrefix, function () {
              return _router["default"].pathname;
            }, _onDemandEntriesUtils.currentPage); // prevent HMR connection from being closed when running tests

            if (!undefined) {
              document.addEventListener('visibilitychange', function (event) {
                var state = document.visibilityState;

                if (state === 'visible') {
                  (0, _onDemandEntriesUtils.setupPing)(assetPrefix, function () {
                    return _router["default"].pathname;
                  }, true);
                } else {
                  (0, _onDemandEntriesUtils.closePing)();
                }
              });
              window.addEventListener('beforeunload', function () {
                (0, _onDemandEntriesUtils.closePing)();
              });
            }

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function _default(_x) {
    return _ref2.apply(this, arguments);
  };
}();

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/on-demand-entries-utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/on-demand-entries-utils.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.closePing = closePing;
exports.setupPing = setupPing;
exports.currentPage = void 0;

var _unfetch = _interopRequireDefault(__webpack_require__(/*! next/dist/build/polyfills/unfetch */ "./node_modules/next/dist/build/polyfills/unfetch.js"));

var _eventsource = __webpack_require__(/*! ./error-overlay/eventsource */ "./node_modules/next/dist/client/dev/error-overlay/eventsource.js");
/* global location */


var evtSource;
var currentPage;
exports.currentPage = currentPage;

function closePing() {
  if (evtSource) evtSource.close();
  evtSource = null;
}

function setupPing(assetPrefix, pathnameFn, retry) {
  var pathname = pathnameFn(); // Make sure to only create new EventSource request if page has changed

  if (pathname === currentPage && !retry) return;
  exports.currentPage = currentPage = pathname; // close current EventSource connection

  closePing();
  var url = assetPrefix + "/_next/webpack-hmr?page=" + currentPage;
  evtSource = (0, _eventsource.getEventSourceWrapper)({
    path: url,
    timeout: 5000,
    ondemand: 1
  });
  evtSource.addMessageListener(function (event) {
    if (event.data.indexOf('{') === -1) return;

    try {
      var payload = JSON.parse(event.data);

      if (payload.invalid) {
        // Payload can be invalid even if the page does not exist.
        // So, we need to make sure it exists before reloading.
        (0, _unfetch["default"])(location.href, {
          credentials: 'same-origin'
        }).then(function (pageRes) {
          if (pageRes.status === 200) {
            location.reload();
          }
        });
      }
    } catch (err) {
      console.error('on-demand-entries failed to parse response', err);
    }
  });
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/prerender-indicator.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/prerender-indicator.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = initializeBuildWatcher;

var _router = _interopRequireDefault(__webpack_require__(/*! ../router */ "./node_modules/next/dist/client/router.js"));

function initializeBuildWatcher() {
  var shadowHost = document.createElement('div');
  shadowHost.id = '__next-prerender-indicator'; // Make sure container is fixed and on a high zIndex so it shows

  shadowHost.style.position = 'fixed';
  shadowHost.style.bottom = '20px';
  shadowHost.style.right = '10px';
  shadowHost.style.width = 0;
  shadowHost.style.height = 0;
  shadowHost.style.zIndex = 99998;
  shadowHost.style.transition = 'all 100ms ease';
  document.body.appendChild(shadowHost);
  var shadowRoot;
  var prefix = '';

  if (shadowHost.attachShadow) {
    shadowRoot = shadowHost.attachShadow({
      mode: 'open'
    });
  } else {
    // If attachShadow is undefined then the browser does not support
    // the Shadow DOM, we need to prefix all the names so there
    // will be no conflicts
    shadowRoot = shadowHost;
    prefix = '__next-prerender-indicator-';
  } // Container


  var container = createContainer(prefix);
  shadowRoot.appendChild(container); // CSS

  var css = createCss(prefix);
  shadowRoot.appendChild(css);
  var expandEl = container.querySelector('a');
  var closeEl = container.querySelector("#" + prefix + "close"); // State

  var dismissKey = '__NEXT_DISMISS_PRERENDER_INDICATOR';
  var dismissUntil = parseInt(window.localStorage.getItem(dismissKey), 10);
  var dismissed = dismissUntil > new Date().getTime();
  var isVisible = !dismissed && window.__NEXT_DATA__.nextExport;

  function updateContainer() {
    if (isVisible) {
      container.classList.add(prefix + "visible");
    } else {
      container.classList.remove(prefix + "visible");
    }
  }

  var expandedClass = prefix + "expanded";
  var toggleTimeout;

  var toggleExpand = function toggleExpand(expand) {
    if (expand === void 0) {
      expand = true;
    }

    clearTimeout(toggleTimeout);
    toggleTimeout = setTimeout(function () {
      if (expand) {
        expandEl.classList.add(expandedClass);
        closeEl.style.display = 'flex';
      } else {
        expandEl.classList.remove(expandedClass);
        closeEl.style.display = 'none';
      }
    }, 50);
  };

  closeEl.addEventListener('click', function () {
    var oneHourAway = new Date().getTime() + 1 * 60 * 60 * 1000;
    window.localStorage.setItem(dismissKey, oneHourAway + '');
    isVisible = false;
    updateContainer();
  });
  closeEl.addEventListener('mouseenter', function () {
    return toggleExpand();
  });
  closeEl.addEventListener('mouseleave', function () {
    return toggleExpand(false);
  });
  expandEl.addEventListener('mouseenter', function () {
    return toggleExpand();
  });
  expandEl.addEventListener('mouseleave', function () {
    return toggleExpand(false);
  });

  _router["default"].events.on('routeChangeComplete', function () {
    isVisible = window.next.isPrerendered;
    updateContainer();
  });

  updateContainer();
}

function createContainer(prefix) {
  var container = document.createElement('div');
  container.id = prefix + "container";
  container.innerHTML = "\n    <button id=\"" + prefix + "close\" title=\"Hide indicator for session\">\n      <span>\xD7</span>\n    </button>\n    <a href=\"https://nextjs.org/docs#automatic-static-optimization-indicator\" target=\"_blank\" rel=\"noreferrer\">\n      <div id=\"" + prefix + "icon-wrapper\">\n          <svg width=\"15\" height=\"20\" viewBox=\"0 0 60 80\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n          <path d=\"M36 3L30.74 41H8L36 3Z\" fill=\"black\"/>\n          <path d=\"M25 77L30.26 39H53L25 77Z\" fill=\"black\"/>\n          <path d=\"M13.5 33.5L53 39L47.5 46.5L7 41.25L13.5 33.5Z\" fill=\"black\"/>\n          </svg>\n          Prerendered Page\n      </div>\n    </a>\n  ";
  return container;
}

function createCss(prefix) {
  var css = document.createElement('style');
  css.textContent = "\n    #" + prefix + "container {\n      position: absolute;\n      display: none;\n      bottom: 10px;\n      right: 15px;\n    }\n\n    #" + prefix + "close {\n      top: -10px;\n      right: -10px;\n      border: none;\n      width: 18px;\n      height: 18px;\n      color: #333333;\n      font-size: 16px;\n      cursor: pointer;\n      display: none;\n      position: absolute;\n      background: #ffffff;\n      border-radius: 100%;\n      align-items: center;\n      flex-direction: column;\n      justify-content: center;\n    }\n\n    #" + prefix + "container a {\n      color: inherit;\n      text-decoration: none;\n      width: 15px;\n      height: 23px;\n      overflow: hidden;\n\n      border-radius: 3px;\n      background: #fff;\n      color: #000;\n      font: initial;\n      cursor: pointer;\n      letter-spacing: initial;\n      text-shadow: initial;\n      text-transform: initial;\n      visibility: initial;\n      font-size: 14px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\n\n      padding: 4px 2px;\n      align-items: center;\n      box-shadow: 0 11px 40px 0 rgba(0, 0, 0, 0.25), 0 2px 10px 0 rgba(0, 0, 0, 0.12);\n\n      display: flex;\n      transition: opacity 0.1s ease, bottom 0.1s ease, width 0.3s ease;\n      animation: " + prefix + "fade-in 0.1s ease-in-out;\n    }\n\n    #" + prefix + "icon-wrapper {\n      width: 140px;\n      height: 20px;\n      display: flex;\n      flex-shrink: 0;\n      align-items: center;\n      position: relative;\n    }\n\n    #" + prefix + "icon-wrapper svg {\n      flex-shrink: 0;\n      margin-right: 3px;\n    }\n\n    #" + prefix + "container a." + prefix + "expanded {\n      width: 135px;\n    }\n\n    #" + prefix + "container." + prefix + "visible {\n      display: flex;\n      bottom: 10px;\n      opacity: 1;\n    }\n\n    @keyframes " + prefix + "fade-in {\n      from {\n        bottom: 0px;\n        opacity: 0;\n      }\n      to {\n        bottom: 10px;\n        opacity: 1;\n      }\n    }\n  ";
  return css;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _hotDevClient = _interopRequireDefault(__webpack_require__(/*! ./error-overlay/hot-dev-client */ "./node_modules/next/dist/client/dev/error-overlay/hot-dev-client.js"));

var _default = function _default(_ref) {
  var assetPrefix = _ref.assetPrefix;
  var options = {
    path: assetPrefix + "/_next/webpack-hmr"
  };
  var devClient = (0, _hotDevClient["default"])(options);
  devClient.subscribeToHmrEvent(function (obj) {
    if (obj.action === 'reloadPage') {
      return window.location.reload();
    }

    if (obj.action === 'removedPage') {
      var _obj$data = _slicedToArray(obj.data, 1),
          page = _obj$data[0];

      if (page === window.next.router.pathname) {
        return window.location.reload();
      }

      return;
    }

    if (obj.action === 'addedPage') {
      var _obj$data2 = _slicedToArray(obj.data, 1),
          _page = _obj$data2[0];

      if (_page === window.next.router.pathname && typeof window.next.router.components[_page] === 'undefined') {
        return window.location.reload();
      }

      return;
    }

    throw new Error('Unexpected action ' + obj.action);
  });
  return devClient;
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/head-manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/head-manager.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = initHeadManager;
var DOMAttributeNames = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv'
};

function reactElementToDOM(_ref) {
  var type = _ref.type,
      props = _ref.props;
  var el = document.createElement(type);

  for (var p in props) {
    if (!props.hasOwnProperty(p)) continue;
    if (p === 'children' || p === 'dangerouslySetInnerHTML') continue; // we don't render undefined props to the DOM

    if (props[p] === undefined) continue;
    var attr = DOMAttributeNames[p] || p.toLowerCase();
    el.setAttribute(attr, props[p]);
  }

  var children = props.children,
      dangerouslySetInnerHTML = props.dangerouslySetInnerHTML;

  if (dangerouslySetInnerHTML) {
    el.innerHTML = dangerouslySetInnerHTML.__html || '';
  } else if (children) {
    el.textContent = typeof children === 'string' ? children : children.join('');
  }

  return el;
}

function updateElements(type, components) {
  var headEl = document.getElementsByTagName('head')[0];
  var headCountEl = headEl.querySelector('meta[name=next-head-count]');

  if (true) {
    if (!headCountEl) {
      console.error('Warning: next-head-count is missing. https://err.sh/next.js/next-head-count-missing');
      return;
    }
  }

  var headCount = Number(headCountEl.content);
  var oldTags = [];

  for (var i = 0, j = headCountEl.previousElementSibling; i < headCount; i++, j = j.previousElementSibling) {
    if (j.tagName.toLowerCase() === type) {
      oldTags.push(j);
    }
  }

  var newTags = components.map(reactElementToDOM).filter(function (newTag) {
    for (var k = 0, len = oldTags.length; k < len; k++) {
      var oldTag = oldTags[k];

      if (oldTag.isEqualNode(newTag)) {
        oldTags.splice(k, 1);
        return false;
      }
    }

    return true;
  });
  oldTags.forEach(function (t) {
    return t.parentNode.removeChild(t);
  });
  newTags.forEach(function (t) {
    return headEl.insertBefore(t, headCountEl);
  });
  headCountEl.content = (headCount - oldTags.length + newTags.length).toString();
}

function initHeadManager() {
  var updatePromise = null;
  return function (head) {
    var promise = updatePromise = Promise.resolve().then(function () {
      if (promise !== updatePromise) return;
      updatePromise = null;
      var tags = {};
      head.forEach(function (h) {
        var components = tags[h.type] || [];
        components.push(h);
        tags[h.type] = components;
      });
      var titleComponent = tags.title ? tags.title[0] : null;
      var title = '';

      if (titleComponent) {
        var children = titleComponent.props.children;
        title = typeof children === 'string' ? children : children.join('');
      }

      if (title !== document.title) document.title = title;
      ['meta', 'base', 'link', 'style', 'script'].forEach(function (type) {
        updateElements(type, tags[type] || []);
      });
    });
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _interopRequireWildcard3 = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.render = render;
exports.renderError = renderError;
exports["default"] = exports.emitter = exports.router = exports.version = void 0;

var _extends2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/extends */ "./node_modules/@babel/runtime/helpers/extends.js"));

var _interopRequireWildcard2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js"));

var _router = __webpack_require__(/*! next/router */ "./node_modules/next/dist/client/router.js");

var _querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js");

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _reactDom = _interopRequireDefault(__webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"));

var _headManagerContext = __webpack_require__(/*! ../next-server/lib/head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _isDynamic = __webpack_require__(/*! ../next-server/lib/router/utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var envConfig = _interopRequireWildcard3(__webpack_require__(/*! ../next-server/lib/runtime-config */ "./node_modules/next/dist/next-server/lib/runtime-config.js"));

var _utils = __webpack_require__(/*! ../next-server/lib/utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _headManager = _interopRequireDefault(__webpack_require__(/*! ./head-manager */ "./node_modules/next/dist/client/head-manager.js"));

var _pageLoader = _interopRequireDefault(__webpack_require__(/*! ./page-loader */ "./node_modules/next/dist/client/page-loader.js"));

var _performanceRelayer = _interopRequireDefault(__webpack_require__(/*! ./performance-relayer */ "./node_modules/next/dist/client/performance-relayer.js"));
/* global location */
/// <reference types="react-dom/experimental" />


if (!('finally' in Promise.prototype)) {
  // eslint-disable-next-line no-extend-native
  Promise.prototype["finally"] = __webpack_require__(/*! next/dist/build/polyfills/finally-polyfill.min */ "./node_modules/next/dist/build/polyfills/finally-polyfill.min.js");
}

var data = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);
window.__NEXT_DATA__ = data;
var version = "9.4.1";
exports.version = version;
var props = data.props,
    err = data.err,
    page = data.page,
    query = data.query,
    buildId = data.buildId,
    assetPrefix = data.assetPrefix,
    runtimeConfig = data.runtimeConfig,
    dynamicIds = data.dynamicIds,
    isFallback = data.isFallback;
var prefix = assetPrefix || ''; // With dynamic assetPrefix it's no longer possible to set assetPrefix at the build time
// So, this is how we do it in the client side at runtime

__webpack_require__.p = prefix + "/_next/"; //eslint-disable-line
// Initialize next/config with the environment configuration

envConfig.setConfig({
  serverRuntimeConfig: {},
  publicRuntimeConfig: runtimeConfig || {}
});
var asPath = (0, _utils.getURL)();
var pageLoader = new _pageLoader["default"](buildId, prefix);

var register = function register(_ref) {
  var _ref7 = _slicedToArray(_ref, 2),
      r = _ref7[0],
      f = _ref7[1];

  return pageLoader.registerPage(r, f);
};

if (window.__NEXT_P) {
  window.__NEXT_P.map(register);
}

window.__NEXT_P = [];
window.__NEXT_P.push = register;
var updateHead = (0, _headManager["default"])();
var appElement = document.getElementById('__next');
var lastAppProps;
var webpackHMR;
var router;
exports.router = router;
var ErrorComponent;
var Component;
var App, onPerfEntry;

var Container = /*#__PURE__*/function (_react$default$Compon) {
  _inherits(Container, _react$default$Compon);

  var _super = _createSuper(Container);

  function Container() {
    _classCallCheck(this, Container);

    return _super.apply(this, arguments);
  }

  _createClass(Container, [{
    key: "componentDidCatch",
    value: function componentDidCatch(err, info) {
      this.props.fn(err, info);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scrollToHash();

      if (false) {} // We need to replace the router state if:
      // - the page was (auto) exported and has a query string or search (hash)
      // - it was auto exported and is a dynamic route (to provide params)
      // - if it is a client-side skeleton (fallback render)


      if (router.isSsr && (isFallback || data.nextExport && ((0, _isDynamic.isDynamicRoute)(router.pathname) || location.search) || props && props.__N_SSG && location.search)) {
        // update query on mount for exported pages
        router.replace(router.pathname + '?' + (0, _querystring.stringify)((0, _extends2["default"])((0, _extends2["default"])({}, router.query), (0, _querystring.parse)(location.search.substr(1)))), asPath, {
          // WARNING: `_h` is an internal option for handing Next.js
          // client-side hydration. Your app should _never_ use this property.
          // It may change at any time without notice.
          _h: 1,
          // Fallback pages must trigger the data fetch, so the transition is
          // not shallow.
          // Other pages (strictly updating query) happens shallowly, as data
          // requirements would already be present.
          shallow: !isFallback
        });
      }

      if (undefined) {
        window.__NEXT_HYDRATED = true;

        if (window.__NEXT_HYDRATED_CB) {
          window.__NEXT_HYDRATED_CB();
        }
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.scrollToHash();
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash() {
      var _location = location,
          hash = _location.hash;
      hash = hash && hash.substring(1);
      if (!hash) return;
      var el = document.getElementById(hash);
      if (!el) return; // If we call scrollIntoView() in here without a setTimeout
      // it won't scroll properly.

      setTimeout(function () {
        return el.scrollIntoView();
      }, 0);
    }
  }, {
    key: "render",
    value: function render() {
      if (false) {}

      if (true) {
        var _require = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"),
            ReactDevOverlay = _require.ReactDevOverlay;

        return /*#__PURE__*/_react["default"].createElement(ReactDevOverlay, null, this.props.children);
      }
    }
  }]);

  return Container;
}(_react["default"].Component);

var emitter = (0, _mitt["default"])();
exports.emitter = emitter;

var _default = /*#__PURE__*/function () {
  var _default2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_temp) {
    var _ref8, passedWebpackHMR, _yield$pageLoader$loa, app, mod, initialErr, _yield$pageLoader$loa2, _require2, isValidElementType, _require3, getNodeError, renderCtx;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref8 = _temp === void 0 ? {} : _temp, passedWebpackHMR = _ref8.webpackHMR; // This makes sure this specific lines are removed in production

            if (true) {
              webpackHMR = passedWebpackHMR;
            }

            _context.next = 4;
            return pageLoader.loadPageScript('/_app');

          case 4:
            _yield$pageLoader$loa = _context.sent;
            app = _yield$pageLoader$loa.page;
            mod = _yield$pageLoader$loa.mod;
            App = app;

            if (mod && mod.reportWebVitals) {
              onPerfEntry = function onPerfEntry(_ref2) {
                var id = _ref2.id,
                    name = _ref2.name,
                    startTime = _ref2.startTime,
                    value = _ref2.value,
                    duration = _ref2.duration,
                    entryType = _ref2.entryType,
                    entries = _ref2.entries; // Combines timestamp with random number for unique ID

                var uniqueID = Date.now() + "-" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);
                var perfStartEntry;

                if (entries && entries.length) {
                  perfStartEntry = entries[0].startTime;
                }

                mod.reportWebVitals({
                  id: id || uniqueID,
                  name: name,
                  startTime: startTime || perfStartEntry,
                  value: value == null ? duration : value,
                  label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'
                });
              };
            }

            initialErr = err;
            _context.prev = 10;
            ;
            _context.next = 14;
            return pageLoader.loadPage(page);

          case 14:
            _yield$pageLoader$loa2 = _context.sent;
            Component = _yield$pageLoader$loa2.page;

            if (false) {}

            _require2 = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"), isValidElementType = _require2.isValidElementType;

            if (isValidElementType(Component)) {
              _context.next = 20;
              break;
            }

            throw new Error("The default export is not a React Component in page: \"" + page + "\"");

          case 20:
            _context.next = 25;
            break;

          case 22:
            _context.prev = 22;
            _context.t0 = _context["catch"](10);
            // This catches errors like throwing in the top level of a module
            initialErr = _context.t0;

          case 25:
            if (true) {
              _require3 = __webpack_require__(/*! @next/react-dev-overlay/lib/client */ "./node_modules/@next/react-dev-overlay/lib/client.js"), getNodeError = _require3.getNodeError; // Server-side runtime errors need to be re-thrown on the client-side so
              // that the overlay is rendered.

              if (initialErr) {
                if (initialErr === err) {
                  setTimeout(function () {
                    var error;

                    try {
                      // Generate a new error object. We `throw` it because some browsers
                      // will set the `stack` when thrown, and we want to ensure ours is
                      // not overridden when we re-throw it below.
                      throw new Error(initialErr.message);
                    } catch (e) {
                      error = e;
                    }

                    error.name = initialErr.name;
                    error.stack = initialErr.stack;
                    var node = getNodeError(error);
                    throw node;
                  });
                } // We replaced the server-side error with a client-side error, and should
                // no longer rewrite the stack trace to a Node error.
                else {
                  setTimeout(function () {
                    throw initialErr;
                  });
                }
              }
            }

            if (!window.__NEXT_PRELOADREADY) {
              _context.next = 29;
              break;
            }

            _context.next = 29;
            return window.__NEXT_PRELOADREADY(dynamicIds);

          case 29:
            exports.router = router = (0, _router.createRouter)(page, query, asPath, {
              initialProps: props,
              pageLoader: pageLoader,
              App: App,
              Component: Component,
              wrapApp: wrapApp,
              err: initialErr,
              isFallback: isFallback,
              subscription: function subscription(_ref3, App) {
                var Component = _ref3.Component,
                    props = _ref3.props,
                    err = _ref3.err;
                render({
                  App: App,
                  Component: Component,
                  props: props,
                  err: err
                });
              }
            }); // call init-client middleware

            if (false) {}

            renderCtx = {
              App: App,
              Component: Component,
              props: props,
              err: initialErr
            };

            if (true) {
              _context.next = 35;
              break;
            }

            render(renderCtx);
            return _context.abrupt("return", emitter);

          case 35:
            if (false) {}

            return _context.abrupt("return", {
              emitter: emitter,
              render: render,
              renderCtx: renderCtx
            });

          case 37:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[10, 22]]);
  }));

  function _default(_x) {
    return _default2.apply(this, arguments);
  }

  return _default;
}();

exports["default"] = _default;

function render(_x2) {
  return _render.apply(this, arguments);
} // This method handles all runtime and debug errors.
// 404 and 500 errors are special kind of errors
// and they are still handle via the main render method.


function _render() {
  _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(props) {
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!props.err) {
              _context2.next = 4;
              break;
            }

            _context2.next = 3;
            return renderError(props);

          case 3:
            return _context2.abrupt("return");

          case 4:
            _context2.prev = 4;
            _context2.next = 7;
            return doRender(props);

          case 7:
            _context2.next = 14;
            break;

          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](4);

            if (true) {
              // Ensure this error is displayed in the overlay in development
              setTimeout(function () {
                throw _context2.t0;
              });
            }

            _context2.next = 14;
            return renderError((0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
              err: _context2.t0
            }));

          case 14:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[4, 9]]);
  }));
  return _render.apply(this, arguments);
}

function renderError(props) {
  var App = props.App,
      err = props.err; // In development runtime errors are caught by our overlay
  // In production we catch runtime errors using componentDidCatch which will trigger renderError

  if (true) {
    // A Next.js rendering runtime error is always unrecoverable
    // FIXME: let's make this recoverable (error in GIP client-transition)
    webpackHMR.onUnrecoverableError(); // We need to render an empty <App> so that the `<ReactDevOverlay>` can
    // render itself.

    return doRender({
      App: function App() {
        return null;
      },
      props: {},
      Component: function Component() {
        return null;
      },
      err: null
    });
  }

  if (false) {} // Make sure we log the error to the console, otherwise users can't track down issues.


  console.error(err);
  return pageLoader.loadPage('/_error').then(function (_ref4) {
    var ErrorComponent = _ref4.page; // In production we do a normal render with the `ErrorComponent` as component.
    // If we've gotten here upon initial render, we can use the props from the server.
    // Otherwise, we need to call `getInitialProps` on `App` before mounting.

    var AppTree = wrapApp(App);
    var appCtx = {
      Component: ErrorComponent,
      AppTree: AppTree,
      router: router,
      ctx: {
        err: err,
        pathname: page,
        query: query,
        asPath: asPath,
        AppTree: AppTree
      }
    };
    return Promise.resolve(props.props ? props.props : (0, _utils.loadGetInitialProps)(App, appCtx)).then(function (initProps) {
      return doRender((0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
        err: err,
        Component: ErrorComponent,
        props: initProps
      }));
    });
  });
} // If hydrate does not exist, eg in preact.


var isInitialRender = typeof _reactDom["default"].hydrate === 'function';
var reactRoot = null;

function renderReactElement(reactEl, domEl) {
  if (false) { var opts; } else {
    // mark start of hydrate/render
    if (_utils.ST) {
      performance.mark('beforeRender');
    } // The check for `.hydrate` is there to support React alternatives like preact


    if (isInitialRender) {
      _reactDom["default"].hydrate(reactEl, domEl, markHydrateComplete);

      isInitialRender = false;

      if (onPerfEntry && _utils.ST) {
        (0, _performanceRelayer["default"])(onPerfEntry);
      }
    } else {
      _reactDom["default"].render(reactEl, domEl, markRenderComplete);
    }
  }
}

function markHydrateComplete() {
  if (!_utils.ST) return;
  performance.mark('afterHydrate'); // mark end of hydration

  performance.measure('Next.js-before-hydration', 'navigationStart', 'beforeRender');
  performance.measure('Next.js-hydration', 'beforeRender', 'afterHydrate');

  if (onPerfEntry) {
    performance.getEntriesByName('Next.js-hydration').forEach(onPerfEntry);
  }

  clearMarks();
}

function markRenderComplete() {
  if (!_utils.ST) return;
  performance.mark('afterRender'); // mark end of render

  var navStartEntries = performance.getEntriesByName('routeChange', 'mark');

  if (!navStartEntries.length) {
    return;
  }

  performance.measure('Next.js-route-change-to-render', navStartEntries[0].name, 'beforeRender');
  performance.measure('Next.js-render', 'beforeRender', 'afterRender');

  if (onPerfEntry) {
    performance.getEntriesByName('Next.js-render').forEach(onPerfEntry);
    performance.getEntriesByName('Next.js-route-change-to-render').forEach(onPerfEntry);
  }

  clearMarks();
  ['Next.js-route-change-to-render', 'Next.js-render'].forEach(function (measure) {
    return performance.clearMeasures(measure);
  });
}

function clearMarks() {
  ;
  ['beforeRender', 'afterHydrate', 'afterRender', 'routeChange'].forEach(function (mark) {
    return performance.clearMarks(mark);
  });
}

function AppContainer(_ref5) {
  var children = _ref5.children;
  return /*#__PURE__*/_react["default"].createElement(Container, {
    fn: function fn(error) {
      return renderError({
        App: App,
        err: error
      })["catch"](function (err) {
        return console.error('Error rendering page: ', err);
      });
    }
  }, /*#__PURE__*/_react["default"].createElement(_routerContext.RouterContext.Provider, {
    value: (0, _router.makePublicRouterInstance)(router)
  }, /*#__PURE__*/_react["default"].createElement(_headManagerContext.HeadManagerContext.Provider, {
    value: updateHead
  }, children)));
}

_c = AppContainer;

var wrapApp = function wrapApp(App) {
  return function (props) {
    var appProps = (0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
      Component: Component,
      err: err,
      router: router
    });
    return /*#__PURE__*/_react["default"].createElement(AppContainer, null, /*#__PURE__*/_react["default"].createElement(App, appProps));
  };
};

function doRender(_x3) {
  return _doRender.apply(this, arguments);
}

function _doRender() {
  _doRender = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref6) {
    var App, Component, props, err, _router2, pathname, _query, _asPath, AppTree, appCtx, appProps, elem;

    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            App = _ref6.App, Component = _ref6.Component, props = _ref6.props, err = _ref6.err; // Usual getInitialProps fetching is handled in next/router
            // this is for when ErrorComponent gets replaced by Component by HMR

            if (!(!props && Component && Component !== ErrorComponent && lastAppProps.Component === ErrorComponent)) {
              _context3.next = 8;
              break;
            }

            _router2 = router, pathname = _router2.pathname, _query = _router2.query, _asPath = _router2.asPath;
            AppTree = wrapApp(App);
            appCtx = {
              router: router,
              AppTree: AppTree,
              Component: ErrorComponent,
              ctx: {
                err: err,
                pathname: pathname,
                query: _query,
                asPath: _asPath,
                AppTree: AppTree
              }
            };
            _context3.next = 7;
            return (0, _utils.loadGetInitialProps)(App, appCtx);

          case 7:
            props = _context3.sent;

          case 8:
            Component = Component || lastAppProps.Component;
            props = props || lastAppProps.props;
            appProps = (0, _extends2["default"])((0, _extends2["default"])({}, props), {}, {
              Component: Component,
              err: err,
              router: router
            }); // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.

            lastAppProps = appProps;
            emitter.emit('before-reactdom-render', {
              Component: Component,
              ErrorComponent: ErrorComponent,
              appProps: appProps
            });
            elem = /*#__PURE__*/_react["default"].createElement(AppContainer, null, /*#__PURE__*/_react["default"].createElement(App, appProps)); // We catch runtime errors using componentDidCatch which will trigger renderError

            renderReactElement( false ? /*#__PURE__*/undefined : elem, appElement);
            emitter.emit('after-reactdom-render', {
              Component: Component,
              ErrorComponent: ErrorComponent,
              appProps: appProps
            });

          case 16:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _doRender.apply(this, arguments);
}

var _c;

$RefreshReg$(_c, "AppContainer");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/next-dev.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/client/next-dev.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var next = _interopRequireWildcard(__webpack_require__(/*! ./ */ "./node_modules/next/dist/client/index.js"));

var _eventSourcePolyfill = _interopRequireDefault(__webpack_require__(/*! ./dev/event-source-polyfill */ "./node_modules/next/dist/client/dev/event-source-polyfill.js"));

var _onDemandEntriesClient = _interopRequireDefault(__webpack_require__(/*! ./dev/on-demand-entries-client */ "./node_modules/next/dist/client/dev/on-demand-entries-client.js"));

var _webpackHotMiddlewareClient = _interopRequireDefault(__webpack_require__(/*! ./dev/webpack-hot-middleware-client */ "./node_modules/next/dist/client/dev/webpack-hot-middleware-client.js"));

var _devBuildWatcher = _interopRequireDefault(__webpack_require__(/*! ./dev/dev-build-watcher */ "./node_modules/next/dist/client/dev/dev-build-watcher.js"));

var _prerenderIndicator = _interopRequireDefault(__webpack_require__(/*! ./dev/prerender-indicator */ "./node_modules/next/dist/client/dev/prerender-indicator.js"));

var _fouc = __webpack_require__(/*! ./dev/fouc */ "./node_modules/next/dist/client/dev/fouc.js");
/* globals import('./dev/noop'); */
// Temporary workaround for the issue described here:
// https://github.com/zeit/next.js/issues/3775#issuecomment-407438123
// The runtimeChunk doesn't have dynamic import handling code when there hasn't been a dynamic import
// The runtimeChunk can't hot reload itself currently to correct it when adding pages using on-demand-entries
// eslint-disable-next-line no-unused-expressions


__webpack_require__.e(/*! import() */ 0).then(__webpack_require__.t.bind(null, /*! ./dev/noop */ "./node_modules/next/dist/client/dev/noop.js", 7));
; // Support EventSource on Internet Explorer 11

if (!window.EventSource) {
  window.EventSource = _eventSourcePolyfill["default"];
}

var _window = window,
    assetPrefix = _window.__NEXT_DATA__.assetPrefix;
var prefix = assetPrefix || '';
var webpackHMR = (0, _webpackHotMiddlewareClient["default"])({
  assetPrefix: prefix
});
window.next = next;
(0, next["default"])({
  webpackHMR: webpackHMR
}).then(function (_ref) {
  var emitter = _ref.emitter,
      renderCtx = _ref.renderCtx,
      render = _ref.render;
  (0, _onDemandEntriesClient["default"])({
    assetPrefix: prefix
  });
  if (true) (0, _devBuildWatcher["default"])();

  if ( true && // disable by default in electron
  !(typeof process !== 'undefined' && 'electron' in process.versions)) {
    (0, _prerenderIndicator["default"])();
  } // delay rendering until after styles have been applied in development


  (0, _fouc.displayContent)(function () {
    render(renderCtx);
  });
  var lastScroll;
  emitter.on('before-reactdom-render', function (_ref2) {
    var Component = _ref2.Component,
        ErrorComponent = _ref2.ErrorComponent; // Remember scroll when ErrorComponent is being rendered to later restore it

    if (!lastScroll && Component === ErrorComponent) {
      var _window2 = window,
          pageXOffset = _window2.pageXOffset,
          pageYOffset = _window2.pageYOffset;
      lastScroll = {
        x: pageXOffset,
        y: pageYOffset
      };
    }
  });
  emitter.on('after-reactdom-render', function (_ref3) {
    var Component = _ref3.Component,
        ErrorComponent = _ref3.ErrorComponent;

    if (lastScroll && Component !== ErrorComponent) {
      // Restore scroll after ErrorComponent was replaced with a page component by HMR
      var _lastScroll = lastScroll,
          x = _lastScroll.x,
          y = _lastScroll.y;
      window.scroll(x, y);
      lastScroll = null;
    }
  });
})["catch"](function (err) {
  console.error('Error was not caught', err);
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../process/browser.js */ "./node_modules/process/browser.js"), __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/page-loader.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/page-loader.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = void 0;

var _url = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../next-server/lib/mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _isDynamic = __webpack_require__(/*! ./../next-server/lib/router/utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _routeMatcher = __webpack_require__(/*! ./../next-server/lib/router/utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./../next-server/lib/router/utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

var _router = __webpack_require__(/*! ./../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

function hasRel(rel, link) {
  try {
    link = document.createElement('link');
    return link.relList.supports(rel);
  } catch (_unused) {}
}

var relPrefetch = hasRel('preload') && !hasRel('prefetch') ? // https://caniuse.com/#feat=link-rel-preload
// macOS and iOS (Safari does not support prefetch)
'preload' : // https://caniuse.com/#feat=link-rel-prefetch
// IE 11, Edge 12+, nearly all evergreen
'prefetch';
var hasNoModule = ('noModule' in document.createElement('script'));
/** @param {string} route */

function normalizeRoute(route) {
  if (route[0] !== '/') {
    throw new Error("Route name should start with a \"/\", got \"" + route + "\"");
  }

  route = route.replace(/\/index$/, '/');
  if (route === '/') return route;
  return route.replace(/\/$/, '');
}

function appendLink(href, rel, as) {
  return new Promise(function (res, rej, link) {
    link = document.createElement('link');
    link.crossOrigin = undefined;
    link.href = href;
    link.rel = rel;
    if (as) link.as = as;
    link.onload = res;
    link.onerror = rej;
    document.head.appendChild(link);
  });
}

var PageLoader = /*#__PURE__*/function () {
  function PageLoader(buildId, assetPrefix) {
    _classCallCheck(this, PageLoader);

    this.buildId = buildId;
    this.assetPrefix = assetPrefix;
    this.pageCache = {};
    this.pageRegisterEvents = (0, _mitt["default"])();
    this.loadingRoutes = {};

    if (false) {}
    /** @type {Promise<Set<string>>} */


    this.promisedSsgManifest = new Promise(function (resolve) {
      if (window.__SSG_MANIFEST) {
        resolve(window.__SSG_MANIFEST);
      } else {
        window.__SSG_MANIFEST_CB = function () {
          resolve(window.__SSG_MANIFEST);
        };
      }
    });
  } // Returns a promise for the dependencies for a particular route


  _createClass(PageLoader, [{
    key: "getDependencies",
    value: function getDependencies(route) {
      var _this = this;

      return this.promisedBuildManifest.then(function (man) {
        return man[route] && man[route].map(function (url) {
          return _this.assetPrefix + "/_next/" + encodeURI(url);
        }) || [];
      });
    }
    /**
    * @param {string} href the route href (file-system path)
    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes
    */

  }, {
    key: "getDataHref",
    value: function getDataHref(href, asPath) {
      var _this2 = this;

      var getHrefForSlug =
      /** @type string */
      function getHrefForSlug(path) {
        path = (0, _router.delBasePath)(path);
        return _this2.assetPrefix + "/_next/data/" + _this2.buildId + (path === '/' ? '/index' : path) + ".json";
      };

      var _ref2 = (0, _url.parse)(href, true),
          hrefPathname = _ref2.pathname,
          query = _ref2.query;

      var _ref3 = (0, _url.parse)(asPath),
          asPathname = _ref3.pathname;

      var route = normalizeRoute(hrefPathname);
      var isDynamic = (0, _isDynamic.isDynamicRoute)(route),
          interpolatedRoute;

      if (isDynamic) {
        var dynamicRegex = (0, _routeRegex.getRouteRegex)(route);
        var dynamicGroups = dynamicRegex.groups;
        var dynamicMatches = // Try to match the dynamic route against the asPath
        (0, _routeMatcher.getRouteMatcher)(dynamicRegex)(asPathname) || // Fall back to reading the values from the href
        // TODO: should this take priority; also need to change in the router.
        query;
        interpolatedRoute = route;

        if (!Object.keys(dynamicGroups).every(function (param) {
          var value = dynamicMatches[param];
          var repeat = dynamicGroups[param].repeat; // support single-level catch-all
          // TODO: more robust handling for user-error (passing `/`)

          if (repeat && !Array.isArray(value)) value = [value];
          return param in dynamicMatches && ( // Interpolate group into data URL if present
          interpolatedRoute = interpolatedRoute.replace("[" + (repeat ? '...' : '') + param + "]", repeat ? value.map(encodeURIComponent).join('/') : encodeURIComponent(value)));
        })) {
          interpolatedRoute = ''; // did not satisfy all requirements
          // n.b. We ignore this error because we handle warning for this case in
          // development in the `<Link>` component directly.
        }
      }

      return isDynamic ? interpolatedRoute && getHrefForSlug(interpolatedRoute) : getHrefForSlug(route);
    }
    /**
    * @param {string} href the route href (file-system path)
    * @param {string} asPath the URL as shown in browser (virtual path); used for dynamic routes
    */

  }, {
    key: "prefetchData",
    value: function prefetchData(href, asPath) {
      var _this3 = this;

      var _ref4 = (0, _url.parse)(href, true),
          hrefPathname = _ref4.pathname;

      var route = normalizeRoute(hrefPathname);
      return this.promisedSsgManifest.then(function (s, _dataHref) {
        return (// Check if the route requires a data file
          s.has(route) && ( // Try to generate data href, noop when falsy
          _dataHref = _this3.getDataHref(href, asPath)) && // noop when data has already been prefetched (dedupe)
          !document.querySelector("link[rel=\"" + relPrefetch + "\"][href^=\"" + _dataHref + "\"]") && // Inject the `<link rel=prefetch>` tag for above computed `href`.
          appendLink(_dataHref, relPrefetch, 'fetch')
        );
      });
    }
  }, {
    key: "loadPage",
    value: function loadPage(route) {
      return this.loadPageScript(route);
    }
  }, {
    key: "loadPageScript",
    value: function loadPageScript(route) {
      var _this4 = this;

      route = normalizeRoute(route);
      return new Promise(function (resolve, reject) {
        var fire = function fire(_ref) {
          var error = _ref.error,
              page = _ref.page,
              mod = _ref.mod;

          _this4.pageRegisterEvents.off(route, fire);

          delete _this4.loadingRoutes[route];

          if (error) {
            reject(error);
          } else {
            resolve({
              page: page,
              mod: mod
            });
          }
        }; // If there's a cached version of the page, let's use it.


        var cachedPage = _this4.pageCache[route];

        if (cachedPage) {
          var error = cachedPage.error,
              page = cachedPage.page,
              mod = cachedPage.mod;
          error ? reject(error) : resolve({
            page: page,
            mod: mod
          });
          return;
        } // Register a listener to get the page


        _this4.pageRegisterEvents.on(route, fire); // If the page is loading via SSR, we need to wait for it
        // rather downloading it again.


        if (document.querySelector("script[data-next-page=\"" + route + "\"]")) {
          return;
        }

        if (!_this4.loadingRoutes[route]) {
          _this4.loadingRoutes[route] = true;

          if (false) {} else {
            _this4.loadRoute(route);
          }
        }
      });
    }
  }, {
    key: "loadRoute",
    value: function loadRoute(route) {
      route = normalizeRoute(route);
      var scriptRoute = route === '/' ? '/index.js' : route + ".js";
      var url = this.assetPrefix + "/_next/static/" + encodeURIComponent(this.buildId) + "/pages" + encodeURI(scriptRoute);
      this.loadScript(url, route, true);
    }
  }, {
    key: "loadScript",
    value: function loadScript(url, route, isPage) {
      var _this5 = this;

      var script = document.createElement('script');

      if (false) {}

      script.crossOrigin = undefined;
      script.src = url;

      script.onerror = function () {
        var error = new Error("Error loading script " + url);
        error.code = 'PAGE_LOAD_ERROR';

        _this5.pageRegisterEvents.emit(route, {
          error: error
        });
      };

      document.body.appendChild(script);
    } // This method if called by the route code.

  }, {
    key: "registerPage",
    value: function registerPage(route, regFn) {
      var _this6 = this;

      var register = function register() {
        try {
          var mod = regFn();
          var pageData = {
            page: mod["default"] || mod,
            mod: mod
          };
          _this6.pageCache[route] = pageData;

          _this6.pageRegisterEvents.emit(route, pageData);
        } catch (error) {
          _this6.pageCache[route] = {
            error: error
          };

          _this6.pageRegisterEvents.emit(route, {
            error: error
          });
        }
      };

      if (true) {
        // Wait for webpack to become idle if it's not.
        // More info: https://github.com/zeit/next.js/pull/1511
        if ( true && module.hot.status() !== 'idle') {
          console.log("Waiting for webpack to become \"idle\" to initialize the page: \"" + route + "\"");

          var check = function check(status) {
            if (status === 'idle') {
              module.hot.removeStatusHandler(check);
              register();
            }
          };

          module.hot.status(check);
          return;
        }
      }

      register();
    }
    /**
    * @param {string} route
    * @param {boolean} [isDependency]
    */

  }, {
    key: "prefetch",
    value: function prefetch(route, isDependency) {
      var _this7 = this;

      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118
      // License: Apache 2.0
      var cn;

      if (cn = navigator.connection) {
        // Don't prefetch if using 2G or if Save-Data is enabled.
        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
      }
      /** @type {string} */


      var url;

      if (isDependency) {
        url = route;
      } else {
        route = normalizeRoute(route);
        var scriptRoute = (route === '/' ? '/index' : route) + ".js";

        if (false) {}

        url = this.assetPrefix + "/_next/static/" + encodeURIComponent(this.buildId) + "/pages" + encodeURI(scriptRoute);
      }

      return Promise.all(document.querySelector("link[rel=\"" + relPrefetch + "\"][href^=\"" + url + "\"], script[data-next-page=\"" + route + "\"]") ? [] : [appendLink(url, relPrefetch, url.match(/\.css$/) ? 'style' : 'script'),  false && false]).then( // do not return any data
      function () {}, // swallow prefetch errors
      function () {});
    }
  }]);

  return PageLoader;
}();

exports["default"] = PageLoader;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/performance-relayer.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/client/performance-relayer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = void 0;

var _webVitals = __webpack_require__(/*! web-vitals */ "./node_modules/web-vitals/dist/web-vitals.es5.min.js");

var _default = function _default(onPerfEntry) {
  (0, _webVitals.getCLS)(onPerfEntry);
  (0, _webVitals.getFID)(onPerfEntry);
  (0, _webVitals.getFCP)(onPerfEntry);
  (0, _webVitals.getLCP)(onPerfEntry);
  (0, _webVitals.getTTFB)(onPerfEntry);
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _construct = __webpack_require__(/*! @babel/runtime/helpers/construct */ "./node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on" + event.charAt(0).toUpperCase() + event.substring(1);
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          // tslint:disable-next-line:no-console
          console.error("Error when running the Router event: " + eventField); // tslint:disable-next-line:no-console

          console.error(err.message + "\n" + err.stack);
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports["default"] = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign({}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(" + name + ")";
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/compiled/strip-ansi/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/strip-ansi/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(__dirname, module) {module.exports = function (e, r) {
  "use strict";

  var t = {};

  function __webpack_require__(r) {
    if (t[r]) {
      return t[r].exports;
    }

    var n = t[r] = {
      i: r,
      l: false,
      exports: {}
    };
    e[r].call(n.exports, n, n.exports, __webpack_require__);
    n.l = true;
    return n.exports;
  }

  __webpack_require__.ab = __dirname + "/";

  function startup() {
    return __webpack_require__(855);
  }

  return startup();
}({
  849: function _(e) {
    "use strict";

    e.exports = function () {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$onlyFirst = _ref.onlyFirst,
          e = _ref$onlyFirst === void 0 ? false : _ref$onlyFirst;

      var r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(r, e ? undefined : "g");
    };
  },
  855: function _(e, r, t) {
    "use strict";

    var n = t(849);

    e.exports = function (e) {
      return typeof e === "string" ? e.replace(n(), "") : e;
    };
  }
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, "/", __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

exports.HeadManagerContext = React.createContext(null);

if (true) {
  exports.HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
/*
MIT License

Copyright (c) Jason Miller (https://jasonformat.com/)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

Object.defineProperty(exports, "__esModule", {
  value: true
});

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        // tslint:disable-next-line:no-bitwise
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

exports["default"] = mitt;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var React = __importStar(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

exports.RouterContext = React.createContext(null);

if (true) {
  exports.RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

var url_1 = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");

var mitt_1 = __importDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var utils_1 = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var is_dynamic_1 = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var route_matcher_1 = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var route_regex_1 = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

var basePath =  false || '';

function addBasePath(path) {
  return path.indexOf(basePath) !== 0 ? basePath + path : path;
}

exports.addBasePath = addBasePath;

function delBasePath(path) {
  return path.indexOf(basePath) === 0 ? path.substr(basePath.length) || '/' : path;
}

exports.delBasePath = delBasePath;

function toRoute(path) {
  return path.replace(/\/$/, '') || '/';
}

var prepareRoute = function prepareRoute(path) {
  return toRoute(!path || path === '/' ? '/index' : path);
};

function fetchNextData(pathname, query, isServerRender, cb) {
  var attempts = isServerRender ? 3 : 1;

  function getResponse() {
    return fetch(utils_1.formatWithValidation({
      pathname: addBasePath( // @ts-ignore __NEXT_DATA__
      "/_next/data/".concat(__NEXT_DATA__.buildId).concat(delBasePath(pathname), ".json")),
      query: query
    }), {
      // Cookies are required to be present for Next.js' SSG "Preview Mode".
      // Cookies may also be required for `getServerSideProps`.
      //
      // > `fetch` won’t send cookies, unless you set the credentials init
      // > option.
      // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
      //
      // > For maximum browser compatibility when it comes to sending &
      // > receiving cookies, always supply the `credentials: 'same-origin'`
      // > option instead of relying on the default.
      // https://github.com/github/fetch#caveats
      credentials: 'same-origin'
    }).then(function (res) {
      if (!res.ok) {
        if (--attempts > 0 && res.status >= 500) {
          return getResponse();
        }

        throw new Error("Failed to load static props");
      }

      return res.json();
    });
  }

  return getResponse().then(function (data) {
    return cb ? cb(data) : data;
  })["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      ;
      err.code = 'PAGE_LOAD_ERROR';
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  function Router(pathname, query, as, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback;

    _classCallCheck(this, Router);

    // Static Data Cache
    this.sdc = {};

    this.onPopState = function (e) {
      if (!e.state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var _pathname = _this.pathname,
            _query = _this.query;

        _this.changeState('replaceState', utils_1.formatWithValidation({
          pathname: _pathname,
          query: _query
        }), utils_1.getURL());

        return;
      } // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (e.state && _this.isSsr && e.state.as === _this.asPath && url_1.parse(e.state.url).pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(e.state)) {
        return;
      }

      var _e$state = e.state,
          url = _e$state.url,
          as = _e$state.as,
          options = _e$state.options;

      if (true) {
        if (typeof url === 'undefined' || typeof as === 'undefined') {
          console.warn('`popstate` event triggered but `event.state` did not have `url` or `as` https://err.sh/zeit/next.js/popstate-state-empty');
        }
      }

      _this.replace(url, as, options);
    };

    this._getStaticData = function (asPath) {
      var pathname = prepareRoute(url_1.parse(asPath).pathname);
      return  false ? undefined : fetchNextData(pathname, null, _this.isSsr, function (data) {
        return _this.sdc[pathname] = data;
      });
    };

    this._getServerData = function (asPath) {
      var _url_1$parse = url_1.parse(asPath, true),
          pathname = _url_1$parse.pathname,
          query = _url_1$parse.query;

      pathname = prepareRoute(pathname);
      return fetchNextData(pathname, query, _this.isSsr);
    }; // represents the current component key


    this.route = toRoute(pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = pathname;
    this.query = query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    this.asPath = // @ts-ignore this is temporarily global (attached to window)
    is_dynamic_1.isDynamicRoute(pathname) && __NEXT_DATA__.autoExport ? pathname : as;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (as.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', utils_1.formatWithValidation({
          pathname: pathname,
          query: query
        }), as);
      }

      window.addEventListener('popstate', this.onPopState);
    }
  } // @deprecated backwards compatibility even though it's a private method.


  _createClass(Router, [{
    key: "update",
    value: function update(route, mod) {
      var Component = mod["default"] || mod;
      var data = this.components[route];

      if (!data) {
        throw new Error("Cannot update unavailable route: ".concat(route));
      }

      var newData = Object.assign(Object.assign({}, data), {
        Component: Component,
        __N_SSG: mod.__N_SSG,
        __N_SSP: mod.__N_SSP
      });
      this.components[route] = newData; // pages/_app.js updated

      if (route === '/_app') {
        this.notify(this.components[this.route]);
        return;
      }

      if (route === this.route) {
        this.notify(newData);
      }
    }
  }, {
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
     * Go back in history
     */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
     * Performs a `pushState` with arguments
     * @param url of the route
     * @param as masks `url` for the browser
     * @param options object you can define `shallow` and other options
     */

  }, {
    key: "push",
    value: function push(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.change('pushState', url, as, options);
    }
    /**
     * Performs a `replaceState` with arguments
     * @param url of the route
     * @param as masks `url` for the browser
     * @param options object you can define `shallow` and other options
     */

  }, {
    key: "replace",
    value: function replace(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function change(method, _url, _as, options) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (!options._h) {
          _this2.isSsr = false;
        } // marking route changes as a navigation start entry


        if (utils_1.ST) {
          performance.mark('routeChange');
        } // If url and as provided as an object representation,
        // we'll format them into the string version here.


        var url = typeof _url === 'object' ? utils_1.formatWithValidation(_url) : _url;
        var as = typeof _as === 'object' ? utils_1.formatWithValidation(_as) : _as;
        url = addBasePath(url);
        as = addBasePath(as); // Add the ending slash to the paths. So, we can serve the
        // "<page>/index.html" directly for the SSR page.

        if (false) { var rewriteUrlForNextExport; }

        _this2.abortComponentLoad(as); // If the url change is only related to a hash change
        // We should not proceed. We should only change the state.
        // WARNING: `_h` is an internal option for handing Next.js client-side
        // hydration. Your app should _never_ use this property. It may change at
        // any time without notice.


        if (!options._h && _this2.onlyAHashChange(as)) {
          _this2.asPath = as;
          Router.events.emit('hashChangeStart', as);

          _this2.changeState(method, url, as, options);

          _this2.scrollToHash(as);

          Router.events.emit('hashChangeComplete', as);
          return resolve(true);
        }

        var _url_1$parse2 = url_1.parse(url, true),
            pathname = _url_1$parse2.pathname,
            query = _url_1$parse2.query,
            protocol = _url_1$parse2.protocol;

        if (!pathname || protocol) {
          if (true) {
            throw new Error("Invalid href passed to router: ".concat(url, " https://err.sh/zeit/next.js/invalid-href-passed"));
          }

          return resolve(false);
        } // If asked to change the current URL we should reload the current page
        // (not location.reload() but reload getInitialProps and other Next.js stuffs)
        // We also need to set the method = replaceState always
        // as this should not go into the history (That's how browsers work)
        // We should compare the new asPath to the current asPath, not the url


        if (!_this2.urlIsNew(as)) {
          method = 'replaceState';
        }

        var route = toRoute(pathname);
        var _options$shallow = options.shallow,
            shallow = _options$shallow === void 0 ? false : _options$shallow;

        if (is_dynamic_1.isDynamicRoute(route)) {
          var _url_1$parse3 = url_1.parse(as),
              asPathname = _url_1$parse3.pathname;

          var routeRegex = route_regex_1.getRouteRegex(route);
          var routeMatch = route_matcher_1.getRouteMatcher(routeRegex)(asPathname);

          if (!routeMatch) {
            var missingParams = Object.keys(routeRegex.groups).filter(function (param) {
              return !query[param];
            });

            if (missingParams.length > 0) {
              if (true) {
                console.warn("Mismatching `as` and `href` failed to manually provide " + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
              }

              return reject(new Error("The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ") + "Read more: https://err.sh/zeit/next.js/incompatible-href-as"));
            }
          } else {
            // Merge params into `query`, overwriting any specified in search
            Object.assign(query, routeMatch);
          }
        }

        Router.events.emit('routeChangeStart', as); // If shallow is true and the route exists in the router cache we reuse the previous result

        _this2.getRouteInfo(route, pathname, query, as, shallow).then(function (routeInfo) {
          var error = routeInfo.error;

          if (error && error.cancelled) {
            return resolve(false);
          }

          Router.events.emit('beforeHistoryChange', as);

          _this2.changeState(method, url, as, options);

          if (true) {
            var appComp = _this2.components['/_app'].Component;
            window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
          }

          _this2.set(route, pathname, query, as, routeInfo);

          if (error) {
            Router.events.emit('routeChangeError', error, as);
            throw error;
          }

          Router.events.emit('routeChangeComplete', as);
          return resolve(true);
        }, reject);
      });
    }
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || utils_1.getURL() !== as) {
        window.history[method]({
          url: url,
          as: as,
          options: options
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "getRouteInfo",
    value: function getRouteInfo(route, pathname, query, as) {
      var _this3 = this;

      var shallow = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var cachedRouteInfo = this.components[route]; // If there is a shallow route transition possible
      // If the route is already rendered on the screen.

      if (shallow && cachedRouteInfo && this.route === route) {
        return Promise.resolve(cachedRouteInfo);
      }

      var handleError = function handleError(err, loadErrorFail) {
        return new Promise(function (resolve) {
          if (err.code === 'PAGE_LOAD_ERROR' || loadErrorFail) {
            // If we can't load the page it could be one of following reasons
            //  1. Page doesn't exists
            //  2. Page does exist in a different zone
            //  3. Internal error while loading the page
            // So, doing a hard reload is the proper way to deal with this.
            window.location.href = as; // Changing the URL doesn't block executing the current code path.
            // So, we need to mark it as a cancelled error and stop the routing logic.

            err.cancelled = true; // @ts-ignore TODO: fix the control flow here

            return resolve({
              error: err
            });
          }

          if (err.cancelled) {
            // @ts-ignore TODO: fix the control flow here
            return resolve({
              error: err
            });
          }

          resolve(_this3.fetchComponent('/_error').then(function (res) {
            var Component = res.page;
            var routeInfo = {
              Component: Component,
              err: err
            };
            return new Promise(function (resolve) {
              _this3.getInitialProps(Component, {
                err: err,
                pathname: pathname,
                query: query
              }).then(function (props) {
                routeInfo.props = props;
                routeInfo.error = err;
                resolve(routeInfo);
              }, function (gipErr) {
                console.error('Error in error page `getInitialProps`: ', gipErr);
                routeInfo.error = err;
                routeInfo.props = {};
                resolve(routeInfo);
              });
            });
          })["catch"](function (err) {
            return handleError(err, true);
          }));
        });
      };

      return new Promise(function (resolve, reject) {
        if (cachedRouteInfo) {
          return resolve(cachedRouteInfo);
        }

        _this3.fetchComponent(route).then(function (res) {
          return resolve({
            Component: res.page,
            __N_SSG: res.mod.__N_SSG,
            __N_SSP: res.mod.__N_SSP
          });
        }, reject);
      }).then(function (routeInfo) {
        var Component = routeInfo.Component,
            __N_SSG = routeInfo.__N_SSG,
            __N_SSP = routeInfo.__N_SSP;

        if (true) {
          var _require = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"),
              isValidElementType = _require.isValidElementType;

          if (!isValidElementType(Component)) {
            throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));
          }
        }

        return _this3._getData(function () {
          return __N_SSG ? _this3._getStaticData(as) : __N_SSP ? _this3._getServerData(as) : _this3.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
          {
            pathname: pathname,
            query: query,
            asPath: as
          });
        }).then(function (props) {
          routeInfo.props = props;
          _this3.components[route] = routeInfo;
          return routeInfo;
        });
      })["catch"](handleError);
    }
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      this.notify(data);
    }
    /**
     * Callback to execute before replacing router state
     * @param cb callback to be executed
     */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value


      if (hash === '') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
    /**
     * Prefetch page code, you may wait for the data during page rendering.
     * This feature only works in production!
     * @param url the href of prefetched page
     * @param asPath the as path of the prefetched page
     */

  }, {
    key: "prefetch",
    value: function prefetch(url) {
      var _this4 = this;

      var asPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return new Promise(function (resolve, reject) {
        var _url_1$parse4 = url_1.parse(url),
            pathname = _url_1$parse4.pathname,
            protocol = _url_1$parse4.protocol;

        if (!pathname || protocol) {
          if (true) {
            throw new Error("Invalid href passed to router: ".concat(url, " https://err.sh/zeit/next.js/invalid-href-passed"));
          }

          return;
        } // Prefetch is not supported in development mode because it would trigger on-demand-entries


        if (true) {
          return;
        }

        var route = delBasePath(toRoute(pathname));
        Promise.all([_this4.pageLoader.prefetchData(url, delBasePath(asPath)), _this4.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]).then(function () {
          return resolve();
        }, reject);
      });
    }
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                route = delBasePath(route);
                _context.next = 5;
                return this.pageLoader.loadPage(route);

              case 5:
                componentResult = _context.sent;

                if (!cancelled) {
                  _context.next = 10;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 10:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context.abrupt("return", componentResult);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fetchComponent(_x) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this5 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this5.clc) {
          _this5.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return utils_1.loadGetInitialProps(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as) {
      if (this.clc) {
        var e = new Error('Route Cancelled');
        e.cancelled = true;
        Router.events.emit('routeChangeError', e, as);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data) {
      this.sub(data, this.components['/_app'].Component);
    }
  }], [{
    key: "_rewriteUrlForNextExport",
    value: function _rewriteUrlForNextExport(url) {
      if (false) { var rewriteUrlForNextExport; } else {
        return url;
      }
    }
  }]);

  return Router;
}();

exports["default"] = Router;
Router.events = mitt_1["default"]();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
}); // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

exports.isDynamicRoute = isDynamicRoute;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

exports.getRouteMatcher = getRouteMatcher;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
}); // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function getRouteRegex(normalizedRoute) {
  // Escape all characters that could be considered RegEx
  var escapedRoute = escapeRegex(normalizedRoute.replace(/\/$/, '') || '/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = escapedRoute.replace(/\/\\\[([^/]+?)\\\](?=\/|$)/g, function (_, $1) {
    var isCatchAll = /^(\\\.){3}/.test($1);
    groups[$1 // Un-escape key
    .replace(/\\([|\\{}()[\]^$+*?.-])/g, '$1').replace(/^\.{3}/, '') // eslint-disable-next-line no-sequences
    ] = {
      pos: groupIndex++,
      repeat: isCatchAll
    };
    return isCatchAll ? '/(.+?)' : '/([^/]+?)';
  });
  var namedParameterizedRoute; // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) {}

  return Object.assign({
    re: new RegExp('^' + parameterizedRoute + '(?:/)?$', 'i'),
    groups: groups
  }, namedParameterizedRoute ? {
    namedRegex: "^".concat(namedParameterizedRoute, "(?:/)?$")
  } : {});
}

exports.getRouteRegex = getRouteRegex;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/runtime-config.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/runtime-config.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
var runtimeConfig;

exports["default"] = function () {
  return runtimeConfig;
};

function setConfig(configValue) {
  runtimeConfig = configValue;
}

exports.setConfig = setConfig;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

Object.defineProperty(exports, "__esModule", {
  value: true
});

var url_1 = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");
/**
 * Utils
 */


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

exports.execOnce = execOnce;

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

exports.getLocationOrigin = getLocationOrigin;

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

exports.getURL = getURL;

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

exports.getDisplayName = getDisplayName;

function isResSent(res) {
  return res.finished || res.headersSent;
}

exports.isResSent = isResSent;

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _a, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_a = App.prototype) === null || _a === void 0 ? void 0 : _a.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/zeit/next.js/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/zeit/next.js/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

exports.loadGetInitialProps = loadGetInitialProps;
exports.urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];

function formatWithValidation(url, options) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (exports.urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return url_1.format(url, options);
}

exports.formatWithValidation = formatWithValidation;
exports.SP = typeof performance !== 'undefined';
exports.ST = exports.SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/platform/platform.js":
/*!*******************************************!*\
  !*** ./node_modules/platform/platform.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Platform.js <https://mths.be/platform>
 * Copyright 2014-2016 Benjamin Tan <https://demoneaux.github.io/>
 * Copyright 2011-2013 John-David Dalton <http://allyoucanleet.com/>
 * Available under MIT license <https://mths.be/mit>
 */
;(function() {
  'use strict';

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used as a reference to the global object. */
  var root = (objectTypes[typeof window] && window) || this;

  /** Backup possible global object. */
  var oldRoot = root;

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /**
   * Used as the maximum length of an array-like object.
   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
   * for more details.
   */
  var maxSafeInteger = Math.pow(2, 53) - 1;

  /** Regular expression to detect Opera. */
  var reOpera = /\bOpera/;

  /** Possible global object. */
  var thisBinding = this;

  /** Used for native method references. */
  var objectProto = Object.prototype;

  /** Used to check for own properties of an object. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to resolve the internal `[[Class]]` of values. */
  var toString = objectProto.toString;

  /*--------------------------------------------------------------------------*/

  /**
   * Capitalizes a string value.
   *
   * @private
   * @param {string} string The string to capitalize.
   * @returns {string} The capitalized string.
   */
  function capitalize(string) {
    string = String(string);
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  /**
   * A utility function to clean up the OS name.
   *
   * @private
   * @param {string} os The OS name to clean up.
   * @param {string} [pattern] A `RegExp` pattern matching the OS name.
   * @param {string} [label] A label for the OS.
   */
  function cleanupOS(os, pattern, label) {
    // Platform tokens are defined at:
    // http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    // http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
    var data = {
      '10.0': '10',
      '6.4':  '10 Technical Preview',
      '6.3':  '8.1',
      '6.2':  '8',
      '6.1':  'Server 2008 R2 / 7',
      '6.0':  'Server 2008 / Vista',
      '5.2':  'Server 2003 / XP 64-bit',
      '5.1':  'XP',
      '5.01': '2000 SP1',
      '5.0':  '2000',
      '4.0':  'NT',
      '4.90': 'ME'
    };
    // Detect Windows version from platform tokens.
    if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) &&
        (data = data[/[\d.]+$/.exec(os)])) {
      os = 'Windows ' + data;
    }
    // Correct character case and cleanup string.
    os = String(os);

    if (pattern && label) {
      os = os.replace(RegExp(pattern, 'i'), label);
    }

    os = format(
      os.replace(/ ce$/i, ' CE')
        .replace(/\bhpw/i, 'web')
        .replace(/\bMacintosh\b/, 'Mac OS')
        .replace(/_PowerPC\b/i, ' OS')
        .replace(/\b(OS X) [^ \d]+/i, '$1')
        .replace(/\bMac (OS X)\b/, '$1')
        .replace(/\/(\d)/, ' $1')
        .replace(/_/g, '.')
        .replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, '')
        .replace(/\bx86\.64\b/gi, 'x86_64')
        .replace(/\b(Windows Phone) OS\b/, '$1')
        .replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1')
        .split(' on ')[0]
    );

    return os;
  }

  /**
   * An iteration utility for arrays and objects.
   *
   * @private
   * @param {Array|Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   */
  function each(object, callback) {
    var index = -1,
        length = object ? object.length : 0;

    if (typeof length == 'number' && length > -1 && length <= maxSafeInteger) {
      while (++index < length) {
        callback(object[index], index, object);
      }
    } else {
      forOwn(object, callback);
    }
  }

  /**
   * Trim and conditionally capitalize string values.
   *
   * @private
   * @param {string} string The string to format.
   * @returns {string} The formatted string.
   */
  function format(string) {
    string = trim(string);
    return /^(?:webOS|i(?:OS|P))/.test(string)
      ? string
      : capitalize(string);
  }

  /**
   * Iterates over an object's own properties, executing the `callback` for each.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function executed per own property.
   */
  function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty.call(object, key)) {
        callback(object[key], key, object);
      }
    }
  }

  /**
   * Gets the internal `[[Class]]` of a value.
   *
   * @private
   * @param {*} value The value.
   * @returns {string} The `[[Class]]`.
   */
  function getClassOf(value) {
    return value == null
      ? capitalize(value)
      : toString.call(value).slice(8, -1);
  }

  /**
   * Host objects can return type values that are different from their actual
   * data type. The objects we are concerned with usually return non-primitive
   * types of "object", "function", or "unknown".
   *
   * @private
   * @param {*} object The owner of the property.
   * @param {string} property The property to check.
   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
   */
  function isHostType(object, property) {
    var type = object != null ? typeof object[property] : 'number';
    return !/^(?:boolean|number|string|undefined)$/.test(type) &&
      (type == 'object' ? !!object[property] : true);
  }

  /**
   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
   *
   * @private
   * @param {string} string The string to qualify.
   * @returns {string} The qualified string.
   */
  function qualify(string) {
    return String(string).replace(/([ -])(?!$)/g, '$1?');
  }

  /**
   * A bare-bones `Array#reduce` like utility function.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @returns {*} The accumulated result.
   */
  function reduce(array, callback) {
    var accumulator = null;
    each(array, function(value, index) {
      accumulator = callback(accumulator, value, index, array);
    });
    return accumulator;
  }

  /**
   * Removes leading and trailing whitespace from a string.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} The trimmed string.
   */
  function trim(string) {
    return String(string).replace(/^ +| +$/g, '');
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a new platform object.
   *
   * @memberOf platform
   * @param {Object|string} [ua=navigator.userAgent] The user agent string or
   *  context object.
   * @returns {Object} A platform object.
   */
  function parse(ua) {

    /** The environment context object. */
    var context = root;

    /** Used to flag when a custom context is provided. */
    var isCustomContext = ua && typeof ua == 'object' && getClassOf(ua) != 'String';

    // Juggle arguments.
    if (isCustomContext) {
      context = ua;
      ua = null;
    }

    /** Browser navigator object. */
    var nav = context.navigator || {};

    /** Browser user agent string. */
    var userAgent = nav.userAgent || '';

    ua || (ua = userAgent);

    /** Used to flag when `thisBinding` is the [ModuleScope]. */
    var isModuleScope = isCustomContext || thisBinding == oldRoot;

    /** Used to detect if browser is like Chrome. */
    var likeChrome = isCustomContext
      ? !!nav.likeChrome
      : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());

    /** Internal `[[Class]]` value shortcuts. */
    var objectClass = 'Object',
        airRuntimeClass = isCustomContext ? objectClass : 'ScriptBridgingProxyObject',
        enviroClass = isCustomContext ? objectClass : 'Environment',
        javaClass = (isCustomContext && context.java) ? 'JavaPackage' : getClassOf(context.java),
        phantomClass = isCustomContext ? objectClass : 'RuntimeObject';

    /** Detect Java environments. */
    var java = /\bJava/.test(javaClass) && context.java;

    /** Detect Rhino. */
    var rhino = java && getClassOf(context.environment) == enviroClass;

    /** A character to represent alpha. */
    var alpha = java ? 'a' : '\u03b1';

    /** A character to represent beta. */
    var beta = java ? 'b' : '\u03b2';

    /** Browser document object. */
    var doc = context.document || {};

    /**
     * Detect Opera browser (Presto-based).
     * http://www.howtocreate.co.uk/operaStuff/operaObject.html
     * http://dev.opera.com/articles/view/opera-mini-web-content-authoring-guidelines/#operamini
     */
    var opera = context.operamini || context.opera;

    /** Opera `[[Class]]`. */
    var operaClass = reOpera.test(operaClass = (isCustomContext && opera) ? opera['[[Class]]'] : getClassOf(opera))
      ? operaClass
      : (opera = null);

    /*------------------------------------------------------------------------*/

    /** Temporary variable used over the script's lifetime. */
    var data;

    /** The CPU architecture. */
    var arch = ua;

    /** Platform description array. */
    var description = [];

    /** Platform alpha/beta indicator. */
    var prerelease = null;

    /** A flag to indicate that environment features should be used to resolve the platform. */
    var useFeatures = ua == userAgent;

    /** The browser/environment version. */
    var version = useFeatures && opera && typeof opera.version == 'function' && opera.version();

    /** A flag to indicate if the OS ends with "/ Version" */
    var isSpecialCasedOS;

    /* Detectable layout engines (order is important). */
    var layout = getLayout([
      { 'label': 'EdgeHTML', 'pattern': 'Edge' },
      'Trident',
      { 'label': 'WebKit', 'pattern': 'AppleWebKit' },
      'iCab',
      'Presto',
      'NetFront',
      'Tasman',
      'KHTML',
      'Gecko'
    ]);

    /* Detectable browser names (order is important). */
    var name = getName([
      'Adobe AIR',
      'Arora',
      'Avant Browser',
      'Breach',
      'Camino',
      'Epiphany',
      'Fennec',
      'Flock',
      'Galeon',
      'GreenBrowser',
      'iCab',
      'Iceweasel',
      'K-Meleon',
      'Konqueror',
      'Lunascape',
      'Maxthon',
      { 'label': 'Microsoft Edge', 'pattern': 'Edge' },
      'Midori',
      'Nook Browser',
      'PaleMoon',
      'PhantomJS',
      'Raven',
      'Rekonq',
      'RockMelt',
      'SeaMonkey',
      { 'label': 'Silk', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Sleipnir',
      'SlimBrowser',
      { 'label': 'SRWare Iron', 'pattern': 'Iron' },
      'Sunrise',
      'Swiftfox',
      'WebPositive',
      'Opera Mini',
      { 'label': 'Opera Mini', 'pattern': 'OPiOS' },
      'Opera',
      { 'label': 'Opera', 'pattern': 'OPR' },
      'Chrome',
      { 'label': 'Chrome Mobile', 'pattern': '(?:CriOS|CrMo)' },
      { 'label': 'Firefox', 'pattern': '(?:Firefox|Minefield)' },
      { 'label': 'Firefox for iOS', 'pattern': 'FxiOS' },
      { 'label': 'IE', 'pattern': 'IEMobile' },
      { 'label': 'IE', 'pattern': 'MSIE' },
      'Safari'
    ]);

    /* Detectable products (order is important). */
    var product = getProduct([
      { 'label': 'BlackBerry', 'pattern': 'BB10' },
      'BlackBerry',
      { 'label': 'Galaxy S', 'pattern': 'GT-I9000' },
      { 'label': 'Galaxy S2', 'pattern': 'GT-I9100' },
      { 'label': 'Galaxy S3', 'pattern': 'GT-I9300' },
      { 'label': 'Galaxy S4', 'pattern': 'GT-I9500' },
      'Google TV',
      'Lumia',
      'iPad',
      'iPod',
      'iPhone',
      'Kindle',
      { 'label': 'Kindle Fire', 'pattern': '(?:Cloud9|Silk-Accelerated)' },
      'Nexus',
      'Nook',
      'PlayBook',
      'PlayStation 3',
      'PlayStation 4',
      'PlayStation Vita',
      'TouchPad',
      'Transformer',
      { 'label': 'Wii U', 'pattern': 'WiiU' },
      'Wii',
      'Xbox One',
      { 'label': 'Xbox 360', 'pattern': 'Xbox' },
      'Xoom'
    ]);

    /* Detectable manufacturers. */
    var manufacturer = getManufacturer({
      'Apple': { 'iPad': 1, 'iPhone': 1, 'iPod': 1 },
      'Archos': {},
      'Amazon': { 'Kindle': 1, 'Kindle Fire': 1 },
      'Asus': { 'Transformer': 1 },
      'Barnes & Noble': { 'Nook': 1 },
      'BlackBerry': { 'PlayBook': 1 },
      'Google': { 'Google TV': 1, 'Nexus': 1 },
      'HP': { 'TouchPad': 1 },
      'HTC': {},
      'LG': {},
      'Microsoft': { 'Xbox': 1, 'Xbox One': 1 },
      'Motorola': { 'Xoom': 1 },
      'Nintendo': { 'Wii U': 1,  'Wii': 1 },
      'Nokia': { 'Lumia': 1 },
      'Samsung': { 'Galaxy S': 1, 'Galaxy S2': 1, 'Galaxy S3': 1, 'Galaxy S4': 1 },
      'Sony': { 'PlayStation 4': 1, 'PlayStation 3': 1, 'PlayStation Vita': 1 }
    });

    /* Detectable operating systems (order is important). */
    var os = getOS([
      'Windows Phone',
      'Android',
      'CentOS',
      { 'label': 'Chrome OS', 'pattern': 'CrOS' },
      'Debian',
      'Fedora',
      'FreeBSD',
      'Gentoo',
      'Haiku',
      'Kubuntu',
      'Linux Mint',
      'OpenBSD',
      'Red Hat',
      'SuSE',
      'Ubuntu',
      'Xubuntu',
      'Cygwin',
      'Symbian OS',
      'hpwOS',
      'webOS ',
      'webOS',
      'Tablet OS',
      'Linux',
      'Mac OS X',
      'Macintosh',
      'Mac',
      'Windows 98;',
      'Windows '
    ]);

    /*------------------------------------------------------------------------*/

    /**
     * Picks the layout engine from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected layout engine.
     */
    function getLayout(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the manufacturer from an array of guesses.
     *
     * @private
     * @param {Array} guesses An object of guesses.
     * @returns {null|string} The detected manufacturer.
     */
    function getManufacturer(guesses) {
      return reduce(guesses, function(result, value, key) {
        // Lookup the manufacturer by product or scan the UA for the manufacturer.
        return result || (
          value[product] ||
          value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] ||
          RegExp('\\b' + qualify(key) + '(?:\\b|\\w*\\d)', 'i').exec(ua)
        ) && key;
      });
    }

    /**
     * Picks the browser name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected browser name.
     */
    function getName(guesses) {
      return reduce(guesses, function(result, guess) {
        return result || RegExp('\\b' + (
          guess.pattern || qualify(guess)
        ) + '\\b', 'i').exec(ua) && (guess.label || guess);
      });
    }

    /**
     * Picks the OS name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected OS name.
     */
    function getOS(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua)
            )) {
          result = cleanupOS(result, pattern, guess.label || guess);
        }
        return result;
      });
    }

    /**
     * Picks the product name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected product name.
     */
    function getProduct(guesses) {
      return reduce(guesses, function(result, guess) {
        var pattern = guess.pattern || qualify(guess);
        if (!result && (result =
              RegExp('\\b' + pattern + ' *\\d+[.\\w_]*', 'i').exec(ua) ||
              RegExp('\\b' + pattern + '(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)', 'i').exec(ua)
            )) {
          // Split by forward slash and append product version if needed.
          if ((result = String((guess.label && !RegExp(pattern, 'i').test(guess.label)) ? guess.label : result).split('/'))[1] && !/[\d.]+/.test(result[0])) {
            result[0] += ' ' + result[1];
          }
          // Correct character case and cleanup string.
          guess = guess.label || guess;
          result = format(result[0]
            .replace(RegExp(pattern, 'i'), guess)
            .replace(RegExp('; *(?:' + guess + '[_-])?', 'i'), ' ')
            .replace(RegExp('(' + guess + ')[-_.]?(\\w)', 'i'), '$1 $2'));
        }
        return result;
      });
    }

    /**
     * Resolves the version using an array of UA patterns.
     *
     * @private
     * @param {Array} patterns An array of UA patterns.
     * @returns {null|string} The detected version.
     */
    function getVersion(patterns) {
      return reduce(patterns, function(result, pattern) {
        return result || (RegExp(pattern +
          '(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)', 'i').exec(ua) || 0)[1] || null;
      });
    }

    /**
     * Returns `platform.description` when the platform object is coerced to a string.
     *
     * @name toString
     * @memberOf platform
     * @returns {string} Returns `platform.description` if available, else an empty string.
     */
    function toStringPlatform() {
      return this.description || '';
    }

    /*------------------------------------------------------------------------*/

    // Convert layout to an array so we can add extra details.
    layout && (layout = [layout]);

    // Detect product names that contain their manufacturer's name.
    if (manufacturer && !product) {
      product = getProduct([manufacturer]);
    }
    // Clean up Google TV.
    if ((data = /\bGoogle TV\b/.exec(product))) {
      product = data[0];
    }
    // Detect simulators.
    if (/\bSimulator\b/i.test(ua)) {
      product = (product ? product + ' ' : '') + 'Simulator';
    }
    // Detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS.
    if (name == 'Opera Mini' && /\bOPiOS\b/.test(ua)) {
      description.push('running in Turbo/Uncompressed mode');
    }
    // Detect IE Mobile 11.
    if (name == 'IE' && /\blike iPhone OS\b/.test(ua)) {
      data = parse(ua.replace(/like iPhone OS/, ''));
      manufacturer = data.manufacturer;
      product = data.product;
    }
    // Detect iOS.
    else if (/^iP/.test(product)) {
      name || (name = 'Safari');
      os = 'iOS' + ((data = / OS ([\d_]+)/i.exec(ua))
        ? ' ' + data[1].replace(/_/g, '.')
        : '');
    }
    // Detect Kubuntu.
    else if (name == 'Konqueror' && !/buntu/i.test(os)) {
      os = 'Kubuntu';
    }
    // Detect Android browsers.
    else if ((manufacturer && manufacturer != 'Google' &&
        ((/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua)) || /\bVita\b/.test(product))) ||
        (/\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua))) {
      name = 'Android Browser';
      os = /\bAndroid\b/.test(os) ? os : 'Android';
    }
    // Detect Silk desktop/accelerated modes.
    else if (name == 'Silk') {
      if (!/\bMobi/i.test(ua)) {
        os = 'Android';
        description.unshift('desktop mode');
      }
      if (/Accelerated *= *true/i.test(ua)) {
        description.unshift('accelerated');
      }
    }
    // Detect PaleMoon identifying as Firefox.
    else if (name == 'PaleMoon' && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
      description.push('identifying as Firefox ' + data[1]);
    }
    // Detect Firefox OS and products running Firefox.
    else if (name == 'Firefox' && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
      os || (os = 'Firefox OS');
      product || (product = data[1]);
    }
    // Detect false positives for Firefox/Safari.
    else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
      // Escape the `/` for Firefox 1.
      if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + '/') + 8))) {
        // Clear name of false positives.
        name = null;
      }
      // Reassign a generic name.
      if ((data = product || manufacturer || os) &&
          (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
        name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + ' Browser';
      }
    }
    // Detect non-Opera (Presto-based) versions (order is important).
    if (!version) {
      version = getVersion([
        '(?:Cloud9|CriOS|CrMo|Edge|FxiOS|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|Silk(?!/[\\d.]+$))',
        'Version',
        qualify(name),
        '(?:Firefox|Minefield|NetFront)'
      ]);
    }
    // Detect stubborn layout engines.
    if ((data =
          layout == 'iCab' && parseFloat(version) > 3 && 'WebKit' ||
          /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? 'Blink' : 'Presto') ||
          /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && 'WebKit' ||
          !layout && /\bMSIE\b/i.test(ua) && (os == 'Mac OS' ? 'Tasman' : 'Trident') ||
          layout == 'WebKit' && /\bPlayStation\b(?! Vita\b)/i.test(name) && 'NetFront'
        )) {
      layout = [data];
    }
    // Detect Windows Phone 7 desktop mode.
    if (name == 'IE' && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
      name += ' Mobile';
      os = 'Windows Phone ' + (/\+$/.test(data) ? data : data + '.x');
      description.unshift('desktop mode');
    }
    // Detect Windows Phone 8.x desktop mode.
    else if (/\bWPDesktop\b/i.test(ua)) {
      name = 'IE Mobile';
      os = 'Windows Phone 8.x';
      description.unshift('desktop mode');
      version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
    }
    // Detect IE 11.
    else if (name != 'IE' && layout == 'Trident' && (data = /\brv:([\d.]+)/.exec(ua))) {
      if (name) {
        description.push('identifying as ' + name + (version ? ' ' + version : ''));
      }
      name = 'IE';
      version = data[1];
    }
    // Leverage environment features.
    if (useFeatures) {
      // Detect server-side environments.
      // Rhino has a global function while others have a global object.
      if (isHostType(context, 'global')) {
        if (java) {
          data = java.lang.System;
          arch = data.getProperty('os.arch');
          os = os || data.getProperty('os.name') + ' ' + data.getProperty('os.version');
        }
        if (isModuleScope && isHostType(context, 'system') && (data = [context.system])[0]) {
          os || (os = data[0].os || null);
          try {
            data[1] = context.require('ringo/engine').version;
            version = data[1].join('.');
            name = 'RingoJS';
          } catch(e) {
            if (data[0].global.system == context.system) {
              name = 'Narwhal';
            }
          }
        }
        else if (
          typeof context.process == 'object' && !context.process.browser &&
          (data = context.process)
        ) {
          name = 'Node.js';
          arch = data.arch;
          os = data.platform;
          version = /[\d.]+/.exec(data.version)[0];
        }
        else if (rhino) {
          name = 'Rhino';
        }
      }
      // Detect Adobe AIR.
      else if (getClassOf((data = context.runtime)) == airRuntimeClass) {
        name = 'Adobe AIR';
        os = data.flash.system.Capabilities.os;
      }
      // Detect PhantomJS.
      else if (getClassOf((data = context.phantom)) == phantomClass) {
        name = 'PhantomJS';
        version = (data = data.version || null) && (data.major + '.' + data.minor + '.' + data.patch);
      }
      // Detect IE compatibility modes.
      else if (typeof doc.documentMode == 'number' && (data = /\bTrident\/(\d+)/i.exec(ua))) {
        // We're in compatibility mode when the Trident version + 4 doesn't
        // equal the document mode.
        version = [version, doc.documentMode];
        if ((data = +data[1] + 4) != version[1]) {
          description.push('IE ' + version[1] + ' mode');
          layout && (layout[1] = '');
          version[1] = data;
        }
        version = name == 'IE' ? String(version[1].toFixed(1)) : version[0];
      }
      os = os && format(os);
    }
    // Detect prerelease phases.
    if (version && (data =
          /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) ||
          /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ';' + (useFeatures && nav.appMinorVersion)) ||
          /\bMinefield\b/i.test(ua) && 'a'
        )) {
      prerelease = /b/i.test(data) ? 'beta' : 'alpha';
      version = version.replace(RegExp(data + '\\+?$'), '') +
        (prerelease == 'beta' ? beta : alpha) + (/\d+\+?/.exec(data) || '');
    }
    // Detect Firefox Mobile.
    if (name == 'Fennec' || name == 'Firefox' && /\b(?:Android|Firefox OS)\b/.test(os)) {
      name = 'Firefox Mobile';
    }
    // Obscure Maxthon's unreliable version.
    else if (name == 'Maxthon' && version) {
      version = version.replace(/\.[\d.]+/, '.x');
    }
    // Detect Xbox 360 and Xbox One.
    else if (/\bXbox\b/i.test(product)) {
      os = null;
      if (product == 'Xbox 360' && /\bIEMobile\b/.test(ua)) {
        description.unshift('mobile mode');
      }
    }
    // Add mobile postfix.
    else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) &&
        (os == 'Windows CE' || /Mobi/i.test(ua))) {
      name += ' Mobile';
    }
    // Detect IE platform preview.
    else if (name == 'IE' && useFeatures && context.external === null) {
      description.unshift('platform preview');
    }
    // Detect BlackBerry OS version.
    // http://docs.blackberry.com/en/developers/deliverables/18169/HTTP_headers_sent_by_BB_Browser_1234911_11.jsp
    else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data =
          (RegExp(product.replace(/ +/g, ' *') + '/([.\\d]+)', 'i').exec(ua) || 0)[1] ||
          version
        )) {
      data = [data, /BB10/.test(ua)];
      os = (data[1] ? (product = null, manufacturer = 'BlackBerry') : 'Device Software') + ' ' + data[0];
      version = null;
    }
    // Detect Opera identifying/masking itself as another browser.
    // http://www.opera.com/support/kb/view/843/
    else if (this != forOwn && product != 'Wii' && (
          (useFeatures && opera) ||
          (/Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua)) ||
          (name == 'Firefox' && /\bOS X (?:\d+\.){2,}/.test(os)) ||
          (name == 'IE' && (
            (os && !/^Win/.test(os) && version > 5.5) ||
            /\bWindows XP\b/.test(os) && version > 8 ||
            version == 8 && !/\bTrident\b/.test(ua)
          ))
        ) && !reOpera.test((data = parse.call(forOwn, ua.replace(reOpera, '') + ';'))) && data.name) {
      // When "identifying", the UA contains both Opera and the other browser's name.
      data = 'ing as ' + data.name + ((data = data.version) ? ' ' + data : '');
      if (reOpera.test(name)) {
        if (/\bIE\b/.test(data) && os == 'Mac OS') {
          os = null;
        }
        data = 'identify' + data;
      }
      // When "masking", the UA contains only the other browser's name.
      else {
        data = 'mask' + data;
        if (operaClass) {
          name = format(operaClass.replace(/([a-z])([A-Z])/g, '$1 $2'));
        } else {
          name = 'Opera';
        }
        if (/\bIE\b/.test(data)) {
          os = null;
        }
        if (!useFeatures) {
          version = null;
        }
      }
      layout = ['Presto'];
      description.push(data);
    }
    // Detect WebKit Nightly and approximate Chrome/Safari versions.
    if ((data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
      // Correct build number for numeric comparison.
      // (e.g. "532.5" becomes "532.05")
      data = [parseFloat(data.replace(/\.(\d)$/, '.0$1')), data];
      // Nightly builds are postfixed with a "+".
      if (name == 'Safari' && data[1].slice(-1) == '+') {
        name = 'WebKit Nightly';
        prerelease = 'alpha';
        version = data[1].slice(0, -1);
      }
      // Clear incorrect browser versions.
      else if (version == data[1] ||
          version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
        version = null;
      }
      // Use the full Chrome version when available.
      data[1] = (/\bChrome\/([\d.]+)/i.exec(ua) || 0)[1];
      // Detect Blink layout engine.
      if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == 'WebKit') {
        layout = ['Blink'];
      }
      // Detect JavaScriptCore.
      // http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
      if (!useFeatures || (!likeChrome && !data[1])) {
        layout && (layout[1] = 'like Safari');
        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? '4+' : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : '8');
      } else {
        layout && (layout[1] = 'like Chrome');
        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.10 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.30 ? 11 : data < 535.01 ? 12 : data < 535.02 ? '13+' : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.10 ? 19 : data < 537.01 ? 20 : data < 537.11 ? '21+' : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != 'Blink' ? '27' : '28');
      }
      // Add the postfix of ".x" or "+" for approximate versions.
      layout && (layout[1] += ' ' + (data += typeof data == 'number' ? '.x' : /[.+]/.test(data) ? '' : '+'));
      // Obscure version for some Safari 1-2 releases.
      if (name == 'Safari' && (!version || parseInt(version) > 45)) {
        version = data;
      }
    }
    // Detect Opera desktop modes.
    if (name == 'Opera' &&  (data = /\bzbov|zvav$/.exec(os))) {
      name += ' ';
      description.unshift('desktop mode');
      if (data == 'zvav') {
        name += 'Mini';
        version = null;
      } else {
        name += 'Mobile';
      }
      os = os.replace(RegExp(' *' + data + '$'), '');
    }
    // Detect Chrome desktop mode.
    else if (name == 'Safari' && /\bChrome\b/.exec(layout && layout[1])) {
      description.unshift('desktop mode');
      name = 'Chrome Mobile';
      version = null;

      if (/\bOS X\b/.test(os)) {
        manufacturer = 'Apple';
        os = 'iOS 4.3+';
      } else {
        os = null;
      }
    }
    // Strip incorrect OS versions.
    if (version && version.indexOf((data = /[\d.]+$/.exec(os))) == 0 &&
        ua.indexOf('/' + data + '-') > -1) {
      os = trim(os.replace(data, ''));
    }
    // Add layout engine.
    if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (
        /Browser|Lunascape|Maxthon/.test(name) ||
        name != 'Safari' && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) ||
        /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Sleipnir|Web)/.test(name) && layout[1])) {
      // Don't add layout details to description if they are falsey.
      (data = layout[layout.length - 1]) && description.push(data);
    }
    // Combine contextual information.
    if (description.length) {
      description = ['(' + description.join('; ') + ')'];
    }
    // Append manufacturer to description.
    if (manufacturer && product && product.indexOf(manufacturer) < 0) {
      description.push('on ' + manufacturer);
    }
    // Append product to description.
    if (product) {
      description.push((/^on /.test(description[description.length - 1]) ? '' : 'on ') + product);
    }
    // Parse the OS into an object.
    if (os) {
      data = / ([\d.+]+)$/.exec(os);
      isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == '/';
      os = {
        'architecture': 32,
        'family': (data && !isSpecialCasedOS) ? os.replace(data[0], '') : os,
        'version': data ? data[1] : null,
        'toString': function() {
          var version = this.version;
          return this.family + ((version && !isSpecialCasedOS) ? ' ' + version : '') + (this.architecture == 64 ? ' 64-bit' : '');
        }
      };
    }
    // Add browser/OS architecture.
    if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
      if (os) {
        os.architecture = 64;
        os.family = os.family.replace(RegExp(' *' + data), '');
      }
      if (
          name && (/\bWOW64\b/i.test(ua) ||
          (useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua)))
      ) {
        description.unshift('32-bit');
      }
    }
    // Chrome 39 and above on OS X is always 64-bit.
    else if (
        os && /^OS X/.test(os.family) &&
        name == 'Chrome' && parseFloat(version) >= 39
    ) {
      os.architecture = 64;
    }

    ua || (ua = null);

    /*------------------------------------------------------------------------*/

    /**
     * The platform object.
     *
     * @name platform
     * @type Object
     */
    var platform = {};

    /**
     * The platform description.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.description = ua;

    /**
     * The name of the browser's layout engine.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.layout = layout && layout[0];

    /**
     * The name of the product's manufacturer.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.manufacturer = manufacturer;

    /**
     * The name of the browser/environment.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.name = name;

    /**
     * The alpha/beta release indicator.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.prerelease = prerelease;

    /**
     * The name of the product hosting the browser.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.product = product;

    /**
     * The browser's user agent string.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.ua = ua;

    /**
     * The browser/environment version.
     *
     * @memberOf platform
     * @type string|null
     */
    platform.version = name && version;

    /**
     * The name of the operating system.
     *
     * @memberOf platform
     * @type Object
     */
    platform.os = os || {

      /**
       * The CPU architecture the OS is built for.
       *
       * @memberOf platform.os
       * @type number|null
       */
      'architecture': null,

      /**
       * The family of the OS.
       *
       * Common values include:
       * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
       * "Windows XP", "OS X", "Ubuntu", "Debian", "Fedora", "Red Hat", "SuSE",
       * "Android", "iOS" and "Windows Phone"
       *
       * @memberOf platform.os
       * @type string|null
       */
      'family': null,

      /**
       * The version of the OS.
       *
       * @memberOf platform.os
       * @type string|null
       */
      'version': null,

      /**
       * Returns the OS string.
       *
       * @memberOf platform.os
       * @returns {string} The OS string.
       */
      'toString': function() { return 'null'; }
    };

    platform.parse = parse;
    platform.toString = toStringPlatform;

    if (platform.version) {
      description.unshift(version);
    }
    if (platform.name) {
      description.unshift(name);
    }
    if (os && name && !(os == String(os).split(' ')[0] && (os == name.split(' ')[0] || product))) {
      description.push(product ? '(' + os + ')' : 'on ' + os);
    }
    if (description.length) {
      platform.description = description.join(' ');
    }
    return platform;
  }

  /*--------------------------------------------------------------------------*/

  // Export platform.
  var platform = parse();

  // Some AMD build optimizers, like r.js, check for condition patterns like the following:
  if (true) {
    // Expose platform on the global object to prevent errors when platform is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    root.platform = platform;

    // Define as an anonymous module so platform can be aliased through path mapping.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return platform;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else {}
}.call(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!***********************************************************************************************!*\
  !*** delegated ./node_modules/react-dom/index.js from dll-reference dll_2adc2403d89adc16ead0 ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(/*! dll-reference dll_2adc2403d89adc16ead0 */ "dll-reference dll_2adc2403d89adc16ead0"))("./node_modules/react-dom/index.js");

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react/index.js":
/*!*******************************************************************************************!*\
  !*** delegated ./node_modules/react/index.js from dll-reference dll_2adc2403d89adc16ead0 ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(/*! dll-reference dll_2adc2403d89adc16ead0 */ "dll-reference dll_2adc2403d89adc16ead0"))("./node_modules/react/index.js");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ "./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js ***!
  \***********************************************************************/
/*! exports provided: parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
var UNKNOWN_FUNCTION = '<unknown>';
/**
 * This parses the different stack traces and puts them into one format
 * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)
 */

function parse(stackString) {
  var lines = stackString.split('\n');
  return lines.reduce(function (stack, line) {
    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);

    if (parseResult) {
      stack.push(parseResult);
    }

    return stack;
  }, []);
}
var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;

function parseChrome(line) {
  var parts = chromeRe.exec(line);

  if (!parts) {
    return null;
  }

  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line

  var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line

  var submatch = chromeEvalRe.exec(parts[2]);

  if (isEval && submatch != null) {
    // throw out eval line/column and use top-most line/column number
    parts[2] = submatch[1]; // url

    parts[3] = submatch[2]; // line

    parts[4] = submatch[3]; // column
  }

  return {
    file: !isNative ? parts[2] : null,
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: isNative ? [parts[2]] : [],
    lineNumber: parts[3] ? +parts[3] : null,
    column: parts[4] ? +parts[4] : null
  };
}

var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;

function parseWinjs(line) {
  var parts = winjsRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}

var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;

function parseGecko(line) {
  var parts = geckoRe.exec(line);

  if (!parts) {
    return null;
  }

  var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
  var submatch = geckoEvalRe.exec(parts[3]);

  if (isEval && submatch != null) {
    // throw out eval line/column and use top-most line number
    parts[3] = submatch[1];
    parts[4] = submatch[2];
    parts[5] = null; // no column when eval
  }

  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: parts[2] ? parts[2].split(',') : [],
    lineNumber: parts[4] ? +parts[4] : null,
    column: parts[5] ? +parts[5] : null
  };
}

var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;

function parseJSC(line) {
  var parts = javaScriptCoreRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[4],
    column: parts[5] ? +parts[5] : null
  };
}

var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;

function parseNode(line) {
  var parts = nodeRe.exec(line);

  if (!parts) {
    return null;
  }

  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}




/***/ }),

/***/ "./node_modules/web-vitals/dist/web-vitals.es5.min.js":
/*!************************************************************!*\
  !*** ./node_modules/web-vitals/dist/web-vitals.es5.min.js ***!
  \************************************************************/
/*! exports provided: getCLS, getFCP, getFID, getLCP, getTTFB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCLS", function() { return p; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFCP", function() { return m; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFID", function() { return v; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLCP", function() { return g; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTTFB", function() { return h; });
var t,n,e=function(){return"".concat(Date.now(),"-").concat(Math.floor(8999999999999*Math.random())+1e12)},i=function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return{name:t,value:n,delta:0,entries:[],id:e(),isFinal:!1}},a=function(t,n){try{if(PerformanceObserver.supportedEntryTypes.includes(t)){var e=new PerformanceObserver((function(t){return t.getEntries().map(n)}));return e.observe({type:t,buffered:!0}),e}}catch(t){}},r=!1,o=!1,s=function(t){r=!t.persisted},u=function(){addEventListener("pagehide",s),addEventListener("unload",(function(){}))},c=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];o||(u(),o=!0),addEventListener("visibilitychange",(function(n){var e=n.timeStamp;"hidden"===document.visibilityState&&t({timeStamp:e,isUnloading:r})}),{capture:!0,once:n})},l=function(t,n,e,i){var a;return function(){e&&n.isFinal&&e.disconnect(),n.value>=0&&(i||n.isFinal||"hidden"===document.visibilityState)&&(n.delta=n.value-(a||0),(n.delta||n.isFinal||void 0===a)&&(t(n),a=n.value))}},p=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=i("CLS",0),r=function(t){t.hadRecentInput||(e.value+=t.value,e.entries.push(t),s())},o=a("layout-shift",r),s=l(t,e,o,n);c((function(t){var n=t.isUnloading;o&&o.takeRecords().map(r),n&&(e.isFinal=!0),s()}))},d=function(){return void 0===t&&(t="hidden"===document.visibilityState?0:1/0,c((function(n){var e=n.timeStamp;return t=e}),!0)),{get timeStamp(){return t}}},m=function(t){var n=i("FCP"),e=d(),r=a("paint",(function(t){"first-contentful-paint"===t.name&&t.startTime<e.timeStamp&&(n.value=t.startTime,n.isFinal=!0,n.entries.push(t),o())})),o=l(t,n,r)},v=function(t){var n=i("FID"),e=d(),r=function(t){t.startTime<e.timeStamp&&(n.value=t.processingStart-t.startTime,n.entries.push(t),n.isFinal=!0,s())},o=a("first-input",r),s=l(t,n,o);c((function(){o&&(o.takeRecords().map(r),o.disconnect())}),!0),o||window.perfMetrics&&window.perfMetrics.onFirstInputDelay&&window.perfMetrics.onFirstInputDelay((function(t,i){i.timeStamp<e.timeStamp&&(n.value=t,n.isFinal=!0,n.entries=[{entryType:"first-input",name:i.type,target:i.target,cancelable:i.cancelable,startTime:i.timeStamp,processingStart:i.timeStamp+t}],s())}))},f=function(){return n||(n=new Promise((function(t){return["scroll","keydown","pointerdown"].map((function(n){addEventListener(n,t,{once:!0,passive:!0,capture:!0})}))}))),n},g=function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],e=i("LCP"),r=d(),o=function(t){var n=t.startTime;n<r.timeStamp?(e.value=n,e.entries.push(t)):e.isFinal=!0,u()},s=a("largest-contentful-paint",o),u=l(t,e,s,n),p=function(){e.isFinal||(s&&s.takeRecords().map(o),e.isFinal=!0,u())};f().then(p),c(p,!0)},h=function(t){var n,e=i("TTFB");n=function(){try{var n=performance.getEntriesByType("navigation")[0]||function(){var t=performance.timing,n={entryType:"navigation",startTime:0};for(var e in t)"navigationStart"!==e&&"toJSON"!==e&&(n[e]=Math.max(t[e]-t.navigationStart,0));return n}();e.value=e.delta=n.responseStart,e.entries=[n],e.isFinal=!0,t(e)}catch(t){}},"complete"===document.readyState?setTimeout(n,0):addEventListener("pageshow",n)};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "dll-reference dll_2adc2403d89adc16ead0":
/*!*******************************************!*\
  !*** external "dll_2adc2403d89adc16ead0" ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = dll_2adc2403d89adc16ead0;

/***/ })

},[["./node_modules/next/dist/client/next-dev.js","static/runtime/webpack.js"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9FcnJvckJvdW5kYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvUmVhY3REZXZPdmVybGF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvYnVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Db2RlRnJhbWUvQ29kZUZyYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Db2RlRnJhbWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0NvZGVGcmFtZS9zdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0RpYWxvZy9EaWFsb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0RpYWxvZy9EaWFsb2dCb2R5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9EaWFsb2cvRGlhbG9nQ29udGVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL0RpYWxvZ0hlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvRGlhbG9nL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9EaWFsb2cvc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXIvTGVmdFJpZ2h0RGlhbG9nSGVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL0xlZnRSaWdodERpYWxvZ0hlYWRlci9zdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL092ZXJsYXkvT3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9ib2R5LWxvY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvT3ZlcmxheS9zdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL1NoYWRvd1BvcnRhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvVGVybWluYWwvVGVybWluYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL1Rlcm1pbmFsL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9UZXJtaW5hbC9zdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb21wb25lbnRzL1RvYXN0L1RvYXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29tcG9uZW50cy9Ub2FzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2NvbXBvbmVudHMvVG9hc3Qvc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29udGFpbmVyL0J1aWxkRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9jb250YWluZXIvRXJyb3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvY29udGFpbmVyL1J1bnRpbWVFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2hlbHBlcnMvbm9kZVN0YWNrRnJhbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvaGVscGVycy9ub29wLXRlbXBsYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvaGVscGVycy9wYXJzZVN0YWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvaGVscGVycy9zdGFjay1mcmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2ludGVybmFsL2hvb2tzL3VzZS1vbi1jbGljay1vdXRzaWRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvc3R5bGVzL0Jhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BuZXh0L3JlYWN0LWRldi1vdmVybGF5L2xpYi9pbnRlcm5hbC9zdHlsZXMvQ29tcG9uZW50U3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvaW50ZXJuYWwvc3R5bGVzL0Nzc1Jlc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbm9kZV9tb2R1bGVzL3N0cmlwLWFuc2kvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvZWxlbWVudC9kaXNhYmxlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9lbGVtZW50L2ZvY3VzLnN2Zy1mb3JlaWduLW9iamVjdC1oYWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2dldC9wYXJlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2dldC9zaGFkb3ctaG9zdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy9hY3RpdmUtZWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy9kaXNhYmxlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy9mb2N1cy1yZWxldmFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy9mb2N1c2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvaXMvaXMudXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy9uYXRpdmUtZGlzYWJsZWQtc3VwcG9ydGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL2lzL29ubHktdGFiYmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvaXMvdGFiYmFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvaXMvdmFsaWQtYXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy92YWxpZC10YWJpbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9pcy92aXNpYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL21haW50YWluL2Rpc2FibGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL21haW50YWluL3RhYi1mb2N1cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9tYXAva2V5Y29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9vYnNlcnZlL3NoYWRvdy1tdXRhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvcXVlcnkvZm9jdXNhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L2ZvY3VzYWJsZS5xdWljay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS9mb2N1c2FibGUuc3RyaWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3F1ZXJ5L3NoYWRvdy1ob3N0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS90YWJiYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS90YWJzZXF1ZW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS90YWJzZXF1ZW5jZS5zb3J0LWFyZWEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvcXVlcnkvdGFic2VxdWVuY2Uuc29ydC1zaGFkb3dlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9xdWVyeS90YWJzZXF1ZW5jZS5zb3J0LXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3NlbGVjdG9yL2ZvY3VzYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9jc3Mtc2hhZG93LXBpZXJjaW5nLWRlZXAtY29tYmluYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9kZXRlY3QtZm9jdXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtYXJlYS1pbWctdGFiaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtYXJlYS10YWJpbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1hcmVhLXdpdGhvdXQtaHJlZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1hdWRpby13aXRob3V0LWNvbnRyb2xzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWJyb2tlbi1pbWFnZS1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtY2hpbGRyZW4tb2YtZm9jdXNhYmxlLWZsZXhib3guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtZmllbGRzZXQtZGlzYWJsZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtZmllbGRzZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtZmxleGJveC1jb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtZm9ybS1kaXNhYmxlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1pbWctaXNtYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtaW1nLXVzZW1hcC10YWJpbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1pbi1oaWRkZW4taWZyYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWluLXplcm8tZGltZW5zaW9uLW9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1pbnZhbGlkLXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLWxhYmVsLXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLW9iamVjdC1zdmctaGlkZGVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLW9iamVjdC1zdmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtb2JqZWN0LXN3Zi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1yZWRpcmVjdC1pbWctdXNlbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXJlZGlyZWN0LWxlZ2VuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zY3JvbGwtYm9keS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zY3JvbGwtY29udGFpbmVyLXdpdGhvdXQtb3ZlcmZsb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc2Nyb2xsLWNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zdW1tYXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXN2Zy1mb2N1c2FibGUtYXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXN2Zy1mb3JlaWdub2JqZWN0LXRhYmluZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXN2Zy1pbi1pZnJhbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc3ZnLW5lZ2F0aXZlLXRhYmluZGV4LWF0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9mb2N1cy1zdmctdGFiaW5kZXgtYXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXN2Zy11c2UtdGFiaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtc3ZnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL2ZvY3VzLXRhYmluZGV4LXRyYWlsaW5nLWNoYXJhY3RlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvZm9jdXMtdmlkZW8td2l0aG91dC1jb250cm9scy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9oZWxwZXIvc3ZnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL21lZGlhL2dpZi5pbnZhbGlkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL21lZGlhL2dpZi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9tZWRpYS9tcDMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvc3VwcG9ydHMvbWVkaWEvbXA0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3N1cHBvcnRzL21lZGlhL3N2Zy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9zdXBwb3J0cy1jYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy9zdXBwb3J0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy9zdXBwb3J0cy90YWJzZXF1ZW5jZS1hcmVhLWF0LWltZy1wb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2FycmF5LWZpbmQtaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9jb21wYXJlLXBvc2l0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvY29udGV4dC10by1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvZWxlbWVudC1tYXRjaGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvZ2V0LWNvbnRlbnQtZG9jdW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9nZXQtZG9jdW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9nZXQtZnJhbWUtZWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL2dldC13aW5kb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9pbWFnZS1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9sb2dnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9tZXJnZS1kb20tb3JkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9ub2RlLWFycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvcGxhdGZvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC9zZWxlY3QtaW4tc2hhZG93cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy91dGlsL3NvcnQtZG9tLW9yZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvdGFiaW5kZXgtdmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvdXRpbC90b2dnbGUtYXR0cmlidXRlLXZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3V0aWwvdG9nZ2xlLWF0dHJpYnV0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWxseS5qcy92ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbGx5LmpzL3doZW4va2V5LmJpbmRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FsbHkuanMvd2hlbi9rZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Fuc2VyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLmVzY2FwZS9jc3MuZXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uYXRpdmUtdXJsL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvZmluYWxseS1wb2x5ZmlsbC5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvdW5mZXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZGV2LWJ1aWxkLXdhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L2Vycm9yLW92ZXJsYXkvZXZlbnRzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L2Vycm9yLW92ZXJsYXkvZm9ybWF0LXdlYnBhY2stbWVzc2FnZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L2Vycm9yLW92ZXJsYXkvaG90LWRldi1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZGV2L2V2ZW50LXNvdXJjZS1wb2x5ZmlsbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvZm91Yy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvb24tZGVtYW5kLWVudHJpZXMtY2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2Rldi9vbi1kZW1hbmQtZW50cmllcy11dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvcHJlcmVuZGVyLWluZGljYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9kZXYvd2VicGFjay1ob3QtbWlkZGxld2FyZS1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaGVhZC1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L25leHQtZGV2LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3BhZ2UtbG9hZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3BlcmZvcm1hbmNlLXJlbGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvcm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3dpdGgtcm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc3RyaXAtYW5zaS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L25leHQtc2VydmVyL2xpYi9taXR0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLW1hdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLXJlZ2V4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3J1bnRpbWUtY29uZmlnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvbmV4dC1zZXJ2ZXIvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wbGF0Zm9ybS9wbGF0Zm9ybS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMgZnJvbSBkbGwtcmVmZXJlbmNlIGRsbF8yYWRjMjQwM2Q4OWFkYzE2ZWFkMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBkbGxfMmFkYzI0MDNkODlhZGMxNmVhZDAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RhY2t0cmFjZS1wYXJzZXIvZGlzdC9zdGFjay10cmFjZS1wYXJzZXIuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93ZWItdml0YWxzL2Rpc3Qvd2ViLXZpdGFscy5lczUubWluLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJkbGxfMmFkYzI0MDNkODlhZGMxNmVhZDBcIiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwib25seUZpcnN0IiwicGF0dGVybiIsImpvaW4iLCJSZWdFeHAiLCJ1bmRlZmluZWQiLCJhbnNpUmVnZXgiLCJyZXF1aXJlIiwic3RyaW5nIiwicmVwbGFjZSIsIl9fZXNNb2R1bGUiLCJpbml0aWFsaXplQnVpbGRXYXRjaGVyIiwiX2V2ZW50c291cmNlIiwic2hhZG93SG9zdCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImlkIiwic3R5bGUiLCJwb3NpdGlvbiIsImJvdHRvbSIsInJpZ2h0Iiwid2lkdGgiLCJoZWlnaHQiLCJ6SW5kZXgiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJzaGFkb3dSb290IiwicHJlZml4IiwiYXR0YWNoU2hhZG93IiwibW9kZSIsImNvbnRhaW5lciIsImNyZWF0ZUNvbnRhaW5lciIsImNzcyIsImNyZWF0ZUNzcyIsImlzVmlzaWJsZSIsImlzQnVpbGRpbmciLCJ0aW1lb3V0SWQiLCJldnRTb3VyY2UiLCJnZXRFdmVudFNvdXJjZVdyYXBwZXIiLCJwYXRoIiwiYWRkTWVzc2FnZUxpc3RlbmVyIiwiZXZlbnQiLCJkYXRhIiwiaGFuZGxlTWVzc2FnZSIsIl91bnVzZWQiLCJvYmoiLCJKU09OIiwicGFyc2UiLCJhY3Rpb24iLCJjbGVhclRpbWVvdXQiLCJ1cGRhdGVDb250YWluZXIiLCJzZXRUaW1lb3V0IiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwiaW5uZXJIVE1MIiwidGV4dENvbnRlbnQiLCJldmVudENhbGxiYWNrcyIsIkV2ZW50U291cmNlV3JhcHBlciIsIm9wdGlvbnMiLCJzb3VyY2UiLCJsYXN0QWN0aXZpdHkiLCJEYXRlIiwibGlzdGVuZXJzIiwidGltZW91dCIsImluaXQiLCJ0aW1lciIsInNldEludGVydmFsIiwiaGFuZGxlRGlzY29ubmVjdCIsIndpbmRvdyIsIkV2ZW50U291cmNlIiwib25vcGVuIiwiaGFuZGxlT25saW5lIiwib25lcnJvciIsIm9ubWVzc2FnZSIsImxvZyIsImNvbnNvbGUiLCJpIiwibGVuZ3RoIiwiaW5kZXhPZiIsImZvckVhY2giLCJjYiIsImNsZWFySW50ZXJ2YWwiLCJjbG9zZSIsImZuIiwicHVzaCIsIm9uZGVtYW5kIiwiZnJpZW5kbHlTeW50YXhFcnJvckxhYmVsIiwiaXNMaWtlbHlBU3ludGF4RXJyb3IiLCJtZXNzYWdlIiwiZm9ybWF0TWVzc2FnZSIsImxpbmVzIiwic3BsaXQiLCJmaWx0ZXIiLCJsaW5lIiwidGVzdCIsIm1hcCIsInBhcnNpbmdFcnJvciIsImV4ZWMiLCJlcnJvckxpbmUiLCJlcnJvckNvbHVtbiIsImVycm9yTWVzc2FnZSIsInRyaW0iLCJzcGxpY2UiLCJtYXRjaCIsImluZGV4IiwiYXJyIiwiZm9ybWF0V2VicGFja01lc3NhZ2VzIiwianNvbiIsImZvcm1hdHRlZEVycm9ycyIsImVycm9ycyIsImZvcm1hdHRlZFdhcm5pbmdzIiwid2FybmluZ3MiLCJyZXN1bHQiLCJzb21lIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiY29ubmVjdCIsIkRldk92ZXJsYXkiLCJfc3RyaXBBbnNpIiwiX2Zvcm1hdFdlYnBhY2tNZXNzYWdlcyIsImhhZFJ1bnRpbWVFcnJvciIsImN1c3RvbUhtckV2ZW50SGFuZGxlciIsInJlZ2lzdGVyIiwicHJvY2Vzc01lc3NhZ2UiLCJleCIsIndhcm4iLCJzdWJzY3JpYmVUb0htckV2ZW50IiwiaGFuZGxlciIsIm9uVW5yZWNvdmVyYWJsZUVycm9yIiwiaXNGaXJzdENvbXBpbGF0aW9uIiwibW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCIsImhhc0NvbXBpbGVFcnJvcnMiLCJjbGVhck91dGRhdGVkRXJyb3JzIiwiY2xlYXIiLCJoYW5kbGVTdWNjZXNzIiwiaXNIb3RVcGRhdGUiLCJ0cnlBcHBseVVwZGF0ZXMiLCJvblN1Y2Nlc3NmdWxIb3RVcGRhdGUiLCJoYXNVcGRhdGVzIiwib25GYXN0UmVmcmVzaCIsImhhbmRsZVdhcm5pbmdzIiwicHJpbnRXYXJuaW5ncyIsImZvcm1hdHRlZCIsImhhbmRsZUVycm9ycyIsIm9uQnVpbGRFcnJvciIsImVycm9yIiwicHJvY2VzcyIsInNlbGYiLCJfX05FWFRfSE1SX0NCIiwib25CdWlsZE9rIiwib25SZWZyZXNoIiwiaGFuZGxlQXZhaWxhYmxlSGFzaCIsImhhc2giLCJlIiwiaGFzRXJyb3JzIiwiQm9vbGVhbiIsImhhc1dhcm5pbmdzIiwiaXNVcGRhdGVBdmFpbGFibGUiLCJfX3dlYnBhY2tfaGFzaF9fIiwiY2FuQXBwbHlVcGRhdGVzIiwiaG90Iiwic3RhdHVzIiwiYWZ0ZXJBcHBseVVwZGF0ZXMiLCJyZW1vdmVTdGF0dXNIYW5kbGVyIiwiYWRkU3RhdHVzSGFuZGxlciIsIm9uSG90VXBkYXRlU3VjY2VzcyIsImhhbmRsZUFwcGx5VXBkYXRlcyIsImVyciIsInVwZGF0ZWRNb2R1bGVzIiwibG9jYXRpb24iLCJyZWxvYWQiLCJjaGVjayIsInRoZW4iLCJfdW5mZXRjaCIsIlJlc3BvbnNlIiwiVGV4dERlY29kZXIiLCJUZXh0RW5jb2RlciIsIkFib3J0Q29udHJvbGxlciIsInNpZ25hbCIsImFib3J0IiwiVGV4dERlY29kZXJQb2x5ZmlsbCIsImJpdHNOZWVkZWQiLCJjb2RlUG9pbnQiLCJwcm90b3R5cGUiLCJkZWNvZGUiLCJvY3RldHMiLCJ2YWxpZCIsInNoaWZ0Iiwib2N0ZXRzQ291bnQiLCJFcnJvciIsIlJFUExBQ0VSIiwib2N0ZXQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJzdXBwb3J0c1N0cmVhbU9wdGlvbiIsImVuY29kZSIsInN0cmVhbSIsImsiLCJYSFJXcmFwcGVyIiwieGhyIiwid2l0aENyZWRlbnRpYWxzIiwicmVzcG9uc2VUeXBlIiwicmVhZHlTdGF0ZSIsInN0YXR1c1RleHQiLCJyZXNwb25zZVRleHQiLCJvbnByb2dyZXNzIiwib25yZWFkeXN0YXRlY2hhbmdlIiwiX2NvbnRlbnRUeXBlIiwiX3hociIsIl9zZW5kVGltZW91dCIsIl9hYm9ydCIsIm9wZW4iLCJtZXRob2QiLCJ1cmwiLCJ0aGF0Iiwic3RhdGUiLCJzaWxlbnQiLCJvbmxvYWQiLCJvbmFib3J0Iiwib25TdGFydCIsImNvbnRlbnRUeXBlIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJvblByb2dyZXNzIiwib25GaW5pc2giLCJvblJlYWR5U3RhdGVDaGFuZ2UiLCJvblRpbWVvdXQiLCJYTUxIdHRwUmVxdWVzdCIsIm5hbWUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwidmFsdWUiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJzZW5kIiwiZXJyb3IxIiwidG9Mb3dlckNhc2UiLCJjIiwiY2hhckNvZGVBdCIsIkhlYWRlcnNQb2x5ZmlsbCIsImFsbCIsIk9iamVjdCIsImNyZWF0ZSIsImFycmF5IiwicGFydHMiLCJfbWFwIiwiZ2V0IiwiWEhSVHJhbnNwb3J0Iiwib25TdGFydENhbGxiYWNrIiwib25Qcm9ncmVzc0NhbGxiYWNrIiwib25GaW5pc2hDYWxsYmFjayIsImhlYWRlcnMiLCJvZmZzZXQiLCJjaHVuayIsInNsaWNlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiSGVhZGVyc1dyYXBwZXIiLCJfaGVhZGVycyIsIkZldGNoVHJhbnNwb3J0IiwiY29udHJvbGxlciIsInRleHREZWNvZGVyIiwiY3JlZGVudGlhbHMiLCJjYWNoZSIsInJlc3BvbnNlIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiY2FuY2VsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWFkTmV4dENodW5rIiwicmVhZCIsImRvbmUiLCJFdmVudFRhcmdldCIsIl9saXN0ZW5lcnMiLCJ0aHJvd0Vycm9yIiwiZGlzcGF0Y2hFdmVudCIsInRhcmdldCIsInR5cGVMaXN0ZW5lcnMiLCJ0eXBlIiwibGlzdGVuZXIiLCJoYW5kbGVFdmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJmb3VuZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmaWx0ZXJlZCIsIkV2ZW50IiwiTWVzc2FnZUV2ZW50IiwibGFzdEV2ZW50SWQiLCJDb25uZWN0aW9uRXZlbnQiLCJXQUlUSU5HIiwiQ09OTkVDVElORyIsIk9QRU4iLCJDTE9TRUQiLCJBRlRFUl9DUiIsIkZJRUxEX1NUQVJUIiwiRklFTEQiLCJWQUxVRV9TVEFSVCIsIlZBTFVFIiwiY29udGVudFR5cGVSZWdFeHAiLCJNSU5JTVVNX0RVUkFUSU9OIiwiTUFYSU1VTV9EVVJBVElPTiIsInBhcnNlRHVyYXRpb24iLCJkZWYiLCJuIiwicGFyc2VJbnQiLCJjbGFtcER1cmF0aW9uIiwiTWF0aCIsIm1pbiIsIm1heCIsImZpcmUiLCJmIiwiRXZlbnRTb3VyY2VQb2x5ZmlsbCIsIl9jbG9zZSIsInN0YXJ0IiwiaXNGZXRjaFN1cHBvcnRlZCIsImVzIiwiaW5pdGlhbFJldHJ5IiwiaGVhcnRiZWF0VGltZW91dCIsInJldHJ5Iiwid2FzQWN0aXZpdHkiLCJzdHJpbmdpZnkiLCJDdXJyZW50VHJhbnNwb3J0IiwiVHJhbnNwb3J0IiwidHJhbnNwb3J0IiwiY2FuY2VsRnVuY3Rpb24iLCJjdXJyZW50U3RhdGUiLCJkYXRhQnVmZmVyIiwibGFzdEV2ZW50SWRCdWZmZXIiLCJldmVudFR5cGVCdWZmZXIiLCJ0ZXh0QnVmZmVyIiwiZmllbGRTdGFydCIsInZhbHVlU3RhcnQiLCJ0ZXh0Q2h1bmsiLCJmaWVsZCIsInJlcXVlc3RVUkwiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXF1ZXN0SGVhZGVycyIsIl9kZWZhdWx0IiwiZGlzcGxheUNvbnRlbnQiLCJjYWxsYmFjayIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIngiLCJxdWVyeVNlbGVjdG9yQWxsIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiX3JvdXRlciIsIl9vbkRlbWFuZEVudHJpZXNVdGlscyIsIl9yZWYiLCJhc3NldFByZWZpeCIsInJlYWR5IiwiZXZlbnRzIiwib24iLCJzZXR1cFBpbmciLCJiaW5kIiwicGF0aG5hbWUiLCJjdXJyZW50UGFnZSIsInZpc2liaWxpdHlTdGF0ZSIsImNsb3NlUGluZyIsInBhdGhuYW1lRm4iLCJwYXlsb2FkIiwiaW52YWxpZCIsImhyZWYiLCJwYWdlUmVzIiwidHJhbnNpdGlvbiIsImV4cGFuZEVsIiwicXVlcnlTZWxlY3RvciIsImNsb3NlRWwiLCJkaXNtaXNzS2V5IiwiZGlzbWlzc1VudGlsIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImRpc21pc3NlZCIsImdldFRpbWUiLCJfX05FWFRfREFUQV9fIiwibmV4dEV4cG9ydCIsImV4cGFuZGVkQ2xhc3MiLCJ0b2dnbGVUaW1lb3V0IiwidG9nZ2xlRXhwYW5kIiwiZXhwYW5kIiwiZGlzcGxheSIsIm9uZUhvdXJBd2F5Iiwic2V0SXRlbSIsIm5leHQiLCJpc1ByZXJlbmRlcmVkIiwiX2hvdERldkNsaWVudCIsImRldkNsaWVudCIsInBhZ2UiLCJyb3V0ZXIiLCJfcGFnZSIsImNvbXBvbmVudHMiLCJpbml0SGVhZE1hbmFnZXIiLCJET01BdHRyaWJ1dGVOYW1lcyIsImFjY2VwdENoYXJzZXQiLCJjbGFzc05hbWUiLCJodG1sRm9yIiwiaHR0cEVxdWl2IiwicmVhY3RFbGVtZW50VG9ET00iLCJwcm9wcyIsImVsIiwicCIsImF0dHIiLCJzZXRBdHRyaWJ1dGUiLCJjaGlsZHJlbiIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwidXBkYXRlRWxlbWVudHMiLCJoZWFkRWwiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImhlYWRDb3VudEVsIiwiaGVhZENvdW50IiwiTnVtYmVyIiwiY29udGVudCIsIm9sZFRhZ3MiLCJqIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsInRhZ05hbWUiLCJuZXdUYWdzIiwibmV3VGFnIiwibGVuIiwib2xkVGFnIiwiaXNFcXVhbE5vZGUiLCJ0IiwiaW5zZXJ0QmVmb3JlIiwidG9TdHJpbmciLCJ1cGRhdGVQcm9taXNlIiwiaGVhZCIsInByb21pc2UiLCJ0YWdzIiwiaCIsInRpdGxlQ29tcG9uZW50IiwidGl0bGUiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDMiLCJyZW5kZXIiLCJyZW5kZXJFcnJvciIsImVtaXR0ZXIiLCJ2ZXJzaW9uIiwiX2V4dGVuZHMyIiwiX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQyIiwiX3F1ZXJ5c3RyaW5nIiwiX3JlYWN0IiwiX3JlYWN0RG9tIiwiX2hlYWRNYW5hZ2VyQ29udGV4dCIsIl9taXR0IiwiX3JvdXRlckNvbnRleHQiLCJfaXNEeW5hbWljIiwiZW52Q29uZmlnIiwiX3V0aWxzIiwiX2hlYWRNYW5hZ2VyIiwiX3BhZ2VMb2FkZXIiLCJfcGVyZm9ybWFuY2VSZWxheWVyIiwiZ2V0RWxlbWVudEJ5SWQiLCJxdWVyeSIsImJ1aWxkSWQiLCJydW50aW1lQ29uZmlnIiwiZHluYW1pY0lkcyIsImlzRmFsbGJhY2siLCJfX3dlYnBhY2tfcHVibGljX3BhdGhfXyIsInNldENvbmZpZyIsInNlcnZlclJ1bnRpbWVDb25maWciLCJwdWJsaWNSdW50aW1lQ29uZmlnIiwiYXNQYXRoIiwiZ2V0VVJMIiwicGFnZUxvYWRlciIsInIiLCJyZWdpc3RlclBhZ2UiLCJfX05FWFRfUCIsInVwZGF0ZUhlYWQiLCJhcHBFbGVtZW50IiwibGFzdEFwcFByb3BzIiwid2VicGFja0hNUiIsIkVycm9yQ29tcG9uZW50IiwiQ29tcG9uZW50IiwiQXBwIiwib25QZXJmRW50cnkiLCJDb250YWluZXIiLCJpbmZvIiwic2Nyb2xsVG9IYXNoIiwiaXNTc3IiLCJpc0R5bmFtaWNSb3V0ZSIsInNlYXJjaCIsIl9fTl9TU0ciLCJzdWJzdHIiLCJfaCIsInNoYWxsb3ciLCJfX05FWFRfSFlEUkFURUQiLCJfX05FWFRfSFlEUkFURURfQ0IiLCJzdWJzdHJpbmciLCJzY3JvbGxJbnRvVmlldyIsIlJlYWN0RGV2T3ZlcmxheSIsIl90ZW1wIiwicGFzc2VkV2VicGFja0hNUiIsImxvYWRQYWdlU2NyaXB0IiwiYXBwIiwibW9kIiwicmVwb3J0V2ViVml0YWxzIiwiX3JlZjIiLCJzdGFydFRpbWUiLCJkdXJhdGlvbiIsImVudHJ5VHlwZSIsImVudHJpZXMiLCJ1bmlxdWVJRCIsIm5vdyIsImZsb29yIiwicmFuZG9tIiwicGVyZlN0YXJ0RW50cnkiLCJsYWJlbCIsImluaXRpYWxFcnIiLCJsb2FkUGFnZSIsImlzVmFsaWRFbGVtZW50VHlwZSIsImdldE5vZGVFcnJvciIsInN0YWNrIiwibm9kZSIsIl9fTkVYVF9QUkVMT0FEUkVBRFkiLCJjcmVhdGVSb3V0ZXIiLCJpbml0aWFsUHJvcHMiLCJ3cmFwQXBwIiwic3Vic2NyaXB0aW9uIiwiX3JlZjMiLCJyZW5kZXJDdHgiLCJkb1JlbmRlciIsIl9yZWY0IiwiQXBwVHJlZSIsImFwcEN0eCIsImN0eCIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJpbml0UHJvcHMiLCJpc0luaXRpYWxSZW5kZXIiLCJoeWRyYXRlIiwicmVhY3RSb290IiwicmVuZGVyUmVhY3RFbGVtZW50IiwicmVhY3RFbCIsImRvbUVsIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJtYXJrSHlkcmF0ZUNvbXBsZXRlIiwibWFya1JlbmRlckNvbXBsZXRlIiwibWVhc3VyZSIsImdldEVudHJpZXNCeU5hbWUiLCJjbGVhck1hcmtzIiwibmF2U3RhcnRFbnRyaWVzIiwiY2xlYXJNZWFzdXJlcyIsIkFwcENvbnRhaW5lciIsIl9yZWY1IiwiUm91dGVyQ29udGV4dCIsIlByb3ZpZGVyIiwibWFrZVB1YmxpY1JvdXRlckluc3RhbmNlIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiYXBwUHJvcHMiLCJfcmVmNiIsIl9xdWVyeSIsIl9hc1BhdGgiLCJlbWl0IiwiZWxlbSIsIl9ldmVudFNvdXJjZVBvbHlmaWxsIiwiX29uRGVtYW5kRW50cmllc0NsaWVudCIsIl93ZWJwYWNrSG90TWlkZGxld2FyZUNsaWVudCIsIl9kZXZCdWlsZFdhdGNoZXIiLCJfcHJlcmVuZGVySW5kaWNhdG9yIiwiX2ZvdWMiLCJ2ZXJzaW9ucyIsImxhc3RTY3JvbGwiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwieSIsInNjcm9sbCIsIl91cmwiLCJfcm91dGVNYXRjaGVyIiwiX3JvdXRlUmVnZXgiLCJoYXNSZWwiLCJyZWwiLCJsaW5rIiwicmVsTGlzdCIsInN1cHBvcnRzIiwicmVsUHJlZmV0Y2giLCJoYXNOb01vZHVsZSIsIm5vcm1hbGl6ZVJvdXRlIiwicm91dGUiLCJhcHBlbmRMaW5rIiwiYXMiLCJyZXMiLCJyZWoiLCJjcm9zc09yaWdpbiIsIlBhZ2VMb2FkZXIiLCJwYWdlQ2FjaGUiLCJwYWdlUmVnaXN0ZXJFdmVudHMiLCJsb2FkaW5nUm91dGVzIiwicHJvbWlzZWRTc2dNYW5pZmVzdCIsIl9fU1NHX01BTklGRVNUIiwiX19TU0dfTUFOSUZFU1RfQ0IiLCJwcm9taXNlZEJ1aWxkTWFuaWZlc3QiLCJtYW4iLCJlbmNvZGVVUkkiLCJnZXRIcmVmRm9yU2x1ZyIsImRlbEJhc2VQYXRoIiwiaHJlZlBhdGhuYW1lIiwiYXNQYXRobmFtZSIsImlzRHluYW1pYyIsImludGVycG9sYXRlZFJvdXRlIiwiZHluYW1pY1JlZ2V4IiwiZ2V0Um91dGVSZWdleCIsImR5bmFtaWNHcm91cHMiLCJncm91cHMiLCJkeW5hbWljTWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsImtleXMiLCJldmVyeSIsInBhcmFtIiwicmVwZWF0IiwiQXJyYXkiLCJpc0FycmF5IiwicyIsIl9kYXRhSHJlZiIsImhhcyIsImdldERhdGFIcmVmIiwib2ZmIiwiY2FjaGVkUGFnZSIsImxvYWRSb3V0ZSIsInNjcmlwdFJvdXRlIiwibG9hZFNjcmlwdCIsImlzUGFnZSIsInNjcmlwdCIsInNyYyIsImNvZGUiLCJyZWdGbiIsInBhZ2VEYXRhIiwiaXNEZXBlbmRlbmN5IiwiY24iLCJuYXZpZ2F0b3IiLCJjb25uZWN0aW9uIiwic2F2ZURhdGEiLCJlZmZlY3RpdmVUeXBlIiwiX3dlYlZpdGFscyIsImdldENMUyIsImdldEZJRCIsImdldEZDUCIsImdldExDUCIsImdldFRURkIiLCJ1c2VSb3V0ZXIiLCJ3aXRoUm91dGVyIiwiX3JvdXRlcjIiLCJSb3V0ZXIiLCJOZXh0Um91dGVyIiwiX3dpdGhSb3V0ZXIiLCJzaW5nbGV0b25Sb3V0ZXIiLCJyZWFkeUNhbGxiYWNrcyIsInVybFByb3BlcnR5RmllbGRzIiwicm91dGVyRXZlbnRzIiwiY29yZU1ldGhvZEZpZWxkcyIsImRlZmluZVByb3BlcnR5IiwiZ2V0Um91dGVyIiwiYXJndW1lbnRzIiwiZXZlbnRGaWVsZCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiX3NpbmdsZXRvblJvdXRlciIsInVzZUNvbnRleHQiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJpbnN0YW5jZSIsInByb3BlcnR5IiwiYXNzaWduIiwiQ29tcG9zZWRDb21wb25lbnQiLCJXaXRoUm91dGVyV3JhcHBlciIsImdldEluaXRpYWxQcm9wcyIsIm9yaWdHZXRJbml0aWFsUHJvcHMiLCJkaXNwbGF5TmFtZSIsIl9fd2VicGFja19yZXF1aXJlX18iLCJsIiwiYWIiLCJfX2Rpcm5hbWUiLCJzdGFydHVwIiwiX19pbXBvcnRTdGFyIiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwibWl0dCIsImV2dHMiLCJfX2ltcG9ydERlZmF1bHQiLCJ1cmxfMSIsIm1pdHRfMSIsInV0aWxzXzEiLCJpc19keW5hbWljXzEiLCJyb3V0ZV9tYXRjaGVyXzEiLCJyb3V0ZV9yZWdleF8xIiwiYmFzZVBhdGgiLCJhZGRCYXNlUGF0aCIsInRvUm91dGUiLCJwcmVwYXJlUm91dGUiLCJmZXRjaE5leHREYXRhIiwiaXNTZXJ2ZXJSZW5kZXIiLCJhdHRlbXB0cyIsImdldFJlc3BvbnNlIiwiZmV0Y2giLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsIm9rIiwic2RjIiwib25Qb3BTdGF0ZSIsImNoYW5nZVN0YXRlIiwiX2JwcyIsIl9nZXRTdGF0aWNEYXRhIiwiX2dldFNlcnZlckRhdGEiLCJfX05fU1NQIiwiYXV0b0V4cG9ydCIsInN1YiIsImNsYyIsIl93cmFwQXBwIiwibmV3RGF0YSIsIm5vdGlmeSIsImhpc3RvcnkiLCJiYWNrIiwiY2hhbmdlIiwiX2FzIiwiYWJvcnRDb21wb25lbnRMb2FkIiwib25seUFIYXNoQ2hhbmdlIiwicHJvdG9jb2wiLCJ1cmxJc05ldyIsInJvdXRlUmVnZXgiLCJyb3V0ZU1hdGNoIiwibWlzc2luZ1BhcmFtcyIsImdldFJvdXRlSW5mbyIsInJvdXRlSW5mbyIsImNhbmNlbGxlZCIsImFwcENvbXAiLCJzZXQiLCJjYWNoZWRSb3V0ZUluZm8iLCJoYW5kbGVFcnJvciIsImxvYWRFcnJvckZhaWwiLCJmZXRjaENvbXBvbmVudCIsImdpcEVyciIsIl9nZXREYXRhIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsIm5ld1VybE5vSGFzaCIsIm5ld0hhc2giLCJzY3JvbGxUbyIsImlkRWwiLCJuYW1lRWwiLCJnZXRFbGVtZW50c0J5TmFtZSIsInByZWZldGNoRGF0YSIsInByaW9yaXR5IiwiY29tcG9uZW50UmVzdWx0IiwiVEVTVF9ST1VURSIsInJlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiXyIsInBhcmFtcyIsInNsdWdOYW1lIiwiZyIsIm0iLCJwb3MiLCJlbnRyeSIsImVzY2FwZVJlZ2V4Iiwic3RyIiwibm9ybWFsaXplZFJvdXRlIiwiZXNjYXBlZFJvdXRlIiwiZ3JvdXBJbmRleCIsInBhcmFtZXRlcml6ZWRSb3V0ZSIsIiQxIiwiaXNDYXRjaEFsbCIsIm5hbWVkUGFyYW1ldGVyaXplZFJvdXRlIiwibmFtZWRSZWdleCIsImNvbmZpZ1ZhbHVlIiwiZXhlY09uY2UiLCJ1c2VkIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJob3N0bmFtZSIsInBvcnQiLCJvcmlnaW4iLCJnZXREaXNwbGF5TmFtZSIsImlzUmVzU2VudCIsImZpbmlzaGVkIiwiaGVhZGVyc1NlbnQiLCJfYSIsInBhZ2VQcm9wcyIsInVybE9iamVjdEtleXMiLCJrZXkiLCJmb3JtYXQiLCJTUCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUM7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBOztBQUVBLGlDOzs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0M7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNB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QUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG1CQUFtQjtBQUNuRTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSw4QkFBOEIsZUFBZTtBQUM3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBMEU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsb0dBQUM7QUFDTjtBQUNBO0FBQ0EsT0FBTyxFQVNKO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ2pvQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7OztBQ3ZMdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RUFBZ0UsNEJBQTRCLG9DQUFvQyw4RkFBOEYsU0FBUyxHQUFHLGdFQUFnRSxXQUFXLGtGQUF1Sjs7Ozs7Ozs7Ozs7O0FDQTFxRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JCQSwwQyIsImZpbGUiOiJzdGF0aWMvcnVudGltZS9tYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5OyIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7IiwiZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkOyIsImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcblxuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hc3luY1RvR2VuZXJhdG9yOyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NsYXNzQ2FsbENoZWNrOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG52YXIgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gcmVxdWlyZShcIi4vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0XCIpO1xuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gUmVmbGVjdC5jb25zdHJ1Y3Q7XG4gIH0gZWxzZSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0ID0gZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gICAgICB2YXIgYSA9IFtudWxsXTtcbiAgICAgIGEucHVzaC5hcHBseShhLCBhcmdzKTtcbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IEZ1bmN0aW9uLmJpbmQuYXBwbHkoUGFyZW50LCBhKTtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xuICAgICAgaWYgKENsYXNzKSBzZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF9jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY29uc3RydWN0OyIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY3JlYXRlQ2xhc3M7IiwiZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9leHRlbmRzOyIsImZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZjsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbmhlcml0czsiLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0OyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7XG4gIGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDtcbiAgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcblxuICBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKSB7XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9O1xuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7XG4gIGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBfdHlwZW9mKG9iaikgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKCk7XG5cbiAgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChvYmopO1xuICB9XG5cbiAgdmFyIG5ld09iaiA9IHt9O1xuICB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDtcblxuICAgICAgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3T2JqW2tleV0gPSBvYmpba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqO1xuXG4gIGlmIChjYWNoZSkge1xuICAgIGNhY2hlLnNldChvYmosIG5ld09iaik7XG4gIH1cblxuICByZXR1cm4gbmV3T2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkOyIsImZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0OyIsImZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaXRlcmFibGVUb0FycmF5TGltaXQ7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVSZXN0OyIsInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkXCIpO1xuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH1cblxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuOyIsImZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuXG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NldFByb3RvdHlwZU9mOyIsInZhciBhcnJheVdpdGhIb2xlcyA9IHJlcXVpcmUoXCIuL2FycmF5V2l0aEhvbGVzXCIpO1xuXG52YXIgaXRlcmFibGVUb0FycmF5TGltaXQgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdFwiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVJlc3QgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVJlc3RcIik7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3NsaWNlZFRvQXJyYXk7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBCdXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vaW50ZXJuYWwvYnVzXCIpKTtcbnZhciBwYXJzZVN0YWNrXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9oZWxwZXJzL3BhcnNlU3RhY2tcIik7XG52YXIgaXNSZWdpc3RlcmVkID0gZmFsc2U7XG52YXIgc3RhY2tUcmFjZUxpbWl0ID0gdW5kZWZpbmVkO1xuZnVuY3Rpb24gb25VbmhhbmRsZWRFcnJvcihldikge1xuICAgIHZhciBlcnJvciA9IGV2ID09PSBudWxsIHx8IGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldi5lcnJvcjtcbiAgICBpZiAoIWVycm9yIHx8ICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgfHwgdHlwZW9mIGVycm9yLnN0YWNrICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBIG5vbi1lcnJvciB3YXMgdGhyb3duLCB3ZSBkb24ndCBoYXZlIGFueXRoaW5nIHRvIHNob3cuIDotKFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBlID0gZXJyb3I7XG4gICAgQnVzLmVtaXQoe1xuICAgICAgICB0eXBlOiBCdXMuVFlQRV9VTkhBTkRMRURfRVJST1IsXG4gICAgICAgIHJlYXNvbjogZXJyb3IsXG4gICAgICAgIGZyYW1lczogcGFyc2VTdGFja18xLnBhcnNlU3RhY2soZS5zdGFjaylcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG9uVW5oYW5kbGVkUmVqZWN0aW9uKGV2KSB7XG4gICAgdmFyIHJlYXNvbiA9IGV2ID09PSBudWxsIHx8IGV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldi5yZWFzb247XG4gICAgaWYgKCFyZWFzb24gfHxcbiAgICAgICAgIShyZWFzb24gaW5zdGFuY2VvZiBFcnJvcikgfHxcbiAgICAgICAgdHlwZW9mIHJlYXNvbi5zdGFjayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQSBub24tZXJyb3Igd2FzIHRocm93biwgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzaG93LiA6LShcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZSA9IHJlYXNvbjtcbiAgICBCdXMuZW1pdCh7XG4gICAgICAgIHR5cGU6IEJ1cy5UWVBFX1VOSEFORExFRF9SRUpFQ1RJT04sXG4gICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICBmcmFtZXM6IHBhcnNlU3RhY2tfMS5wYXJzZVN0YWNrKGUuc3RhY2spXG4gICAgfSk7XG59XG5mdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgICBpZiAoaXNSZWdpc3RlcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNSZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgICB2YXIgbGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gICAgICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IDUwO1xuICAgICAgICBzdGFja1RyYWNlTGltaXQgPSBsaW1pdDtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7IH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvblVuaGFuZGxlZEVycm9yKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgb25VbmhhbmRsZWRSZWplY3Rpb24pO1xufVxuZXhwb3J0cy5yZWdpc3RlciA9IHJlZ2lzdGVyO1xuZnVuY3Rpb24gdW5yZWdpc3RlcigpIHtcbiAgICBpZiAoIWlzUmVnaXN0ZXJlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzUmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgIGlmIChzdGFja1RyYWNlTGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc3RhY2tUcmFjZUxpbWl0O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgIHN0YWNrVHJhY2VMaW1pdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25VbmhhbmRsZWRFcnJvcik7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIG9uVW5oYW5kbGVkUmVqZWN0aW9uKTtcbn1cbmV4cG9ydHMudW5yZWdpc3RlciA9IHVucmVnaXN0ZXI7XG5mdW5jdGlvbiBvbkJ1aWxkT2soKSB7XG4gICAgQnVzLmVtaXQoeyB0eXBlOiBCdXMuVFlQRV9CVUlMRF9PSyB9KTtcbn1cbmV4cG9ydHMub25CdWlsZE9rID0gb25CdWlsZE9rO1xuZnVuY3Rpb24gb25CdWlsZEVycm9yKG1lc3NhZ2UpIHtcbiAgICBCdXMuZW1pdCh7IHR5cGU6IEJ1cy5UWVBFX0JVSUxEX0VSUk9SLCBtZXNzYWdlOiBtZXNzYWdlIH0pO1xufVxuZXhwb3J0cy5vbkJ1aWxkRXJyb3IgPSBvbkJ1aWxkRXJyb3I7XG5mdW5jdGlvbiBvblJlZnJlc2goKSB7XG4gICAgQnVzLmVtaXQoeyB0eXBlOiBCdXMuVFlQRV9SRUZGUkVTSCB9KTtcbn1cbmV4cG9ydHMub25SZWZyZXNoID0gb25SZWZyZXNoO1xudmFyIG5vZGVTdGFja0ZyYW1lc18xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvaGVscGVycy9ub2RlU3RhY2tGcmFtZXNcIik7XG5leHBvcnRzLmdldE5vZGVFcnJvciA9IG5vZGVTdGFja0ZyYW1lc18xLmdldE5vZGVFcnJvcjtcbnZhciBSZWFjdERldk92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL1JlYWN0RGV2T3ZlcmxheVwiKTtcbmV4cG9ydHMuUmVhY3REZXZPdmVybGF5ID0gUmVhY3REZXZPdmVybGF5XzFbXCJkZWZhdWx0XCJdO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgcmVhY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIEVycm9yQm91bmRhcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVycm9yQm91bmRhcnksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXJyb3JCb3VuZGFyeSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVycm9yQm91bmRhcnkucHJvdG90eXBlLmNvbXBvbmVudERpZENhdGNoID0gZnVuY3Rpb24gKGVycm9yLCBcbiAgICAvLyBMb29zZWx5IHR5cGVkIGJlY2F1c2UgaXQgZGVwZW5kcyBvbiB0aGUgUmVhY3QgdmVyc2lvbiBhbmQgd2FzXG4gICAgLy8gYWNjaWRlbnRhbGx5IGV4Y2x1ZGVkIGluIHNvbWUgdmVyc2lvbnMuXG4gICAgZXJyb3JJbmZvKSB7XG4gICAgICAgIHRoaXMucHJvcHMub25FcnJvcihlcnJvciwgKGVycm9ySW5mbyA9PT0gbnVsbCB8fCBlcnJvckluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9ySW5mby5jb21wb25lbnRTdGFjaykgfHwgbnVsbCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBlcnJvcjogZXJyb3IgfSk7XG4gICAgfTtcbiAgICBFcnJvckJvdW5kYXJ5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yXG4gICAgICAgICAgICA/IC8vIFRoZSBjb21wb25lbnQgaGFzIHRvIGJlIHVubW91bnRlZCBvciBlbHNlIGl0IHdvdWxkIGNvbnRpbnVlIHRvIGVycm9yXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH07XG4gICAgcmV0dXJuIEVycm9yQm91bmRhcnk7XG59KHJlYWN0XzFbXCJkZWZhdWx0XCJdLlB1cmVDb21wb25lbnQpKTtcbmV4cG9ydHMuRXJyb3JCb3VuZGFyeSA9IEVycm9yQm91bmRhcnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWQgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIEJ1cyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9idXNcIikpO1xudmFyIFNoYWRvd1BvcnRhbF8xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9TaGFkb3dQb3J0YWxcIik7XG52YXIgRXJyb3JzXzEgPSByZXF1aXJlKFwiLi9jb250YWluZXIvRXJyb3JzXCIpO1xudmFyIEJ1aWxkRXJyb3JfMSA9IHJlcXVpcmUoXCIuL2NvbnRhaW5lci9CdWlsZEVycm9yXCIpO1xudmFyIEVycm9yQm91bmRhcnlfMSA9IHJlcXVpcmUoXCIuL0Vycm9yQm91bmRhcnlcIik7XG52YXIgQmFzZV8xID0gcmVxdWlyZShcIi4vc3R5bGVzL0Jhc2VcIik7XG52YXIgQ29tcG9uZW50U3R5bGVzXzEgPSByZXF1aXJlKFwiLi9zdHlsZXMvQ29tcG9uZW50U3R5bGVzXCIpO1xudmFyIENzc1Jlc2V0XzEgPSByZXF1aXJlKFwiLi9zdHlsZXMvQ3NzUmVzZXRcIik7XG5mdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBldikge1xuICAgIHN3aXRjaCAoZXYudHlwZSkge1xuICAgICAgICBjYXNlIEJ1cy5UWVBFX0JVSUxEX09LOiB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlKSwgeyBidWlsZEVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgQnVzLlRZUEVfQlVJTERfRVJST1I6IHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc3RhdGUpLCB7IGJ1aWxkRXJyb3I6IGV2Lm1lc3NhZ2UgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBCdXMuVFlQRV9SRUZGUkVTSDoge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0ZSksIHsgYnVpbGRFcnJvcjogbnVsbCwgZXJyb3JzOiBbXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEJ1cy5UWVBFX1VOSEFORExFRF9FUlJPUjpcbiAgICAgICAgY2FzZSBCdXMuVFlQRV9VTkhBTkRMRURfUkVKRUNUSU9OOiB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlKSwgeyBuZXh0SWQ6IHN0YXRlLm5leHRJZCArIDEsIGVycm9yczogX19zcHJlYWQoc3RhdGUuZXJyb3JzLCBbeyBpZDogc3RhdGUubmV4dElkLCBldmVudDogZXYgfV0pIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgIHZhciBfMSA9IGV2O1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gUmVhY3REZXZPdmVybGF5KF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVJlZHVjZXIocmVkdWNlciwgeyBuZXh0SWQ6IDEsIGJ1aWxkRXJyb3I6IG51bGwsIGVycm9yczogW10gfSksIDIpLCBzdGF0ZSA9IF9iWzBdLCBkaXNwYXRjaCA9IF9iWzFdO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIEJ1cy5vbihkaXNwYXRjaCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBCdXMub2ZmKGRpc3BhdGNoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbZGlzcGF0Y2hdKTtcbiAgICB2YXIgb25Db21wb25lbnRFcnJvciA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlcnJvciwgY29tcG9uZW50U3RhY2spIHtcbiAgICAgICAgLy8gVE9ETzogc3BlY2lhbCBoYW5kbGluZ1xuICAgIH0sIFtdKTtcbiAgICB2YXIgaGFzQnVpbGRFcnJvciA9IHN0YXRlLmJ1aWxkRXJyb3IgIT0gbnVsbDtcbiAgICB2YXIgaGFzUnVudGltZUVycm9ycyA9IEJvb2xlYW4oc3RhdGUuZXJyb3JzLmxlbmd0aCk7XG4gICAgdmFyIGlzTW91bnRlZCA9IGhhc0J1aWxkRXJyb3IgfHwgaGFzUnVudGltZUVycm9ycztcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRXJyb3JCb3VuZGFyeV8xLkVycm9yQm91bmRhcnksIHsgb25FcnJvcjogb25Db21wb25lbnRFcnJvciB9LCBjaGlsZHJlbiAhPT0gbnVsbCAmJiBjaGlsZHJlbiAhPT0gdm9pZCAwID8gY2hpbGRyZW4gOiBudWxsKSxcbiAgICAgICAgaXNNb3VudGVkID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoU2hhZG93UG9ydGFsXzEuU2hhZG93UG9ydGFsLCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDc3NSZXNldF8xLkNzc1Jlc2V0LCBudWxsKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFzZV8xLkJhc2UsIG51bGwpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnRTdHlsZXNfMS5Db21wb25lbnRTdHlsZXMsIG51bGwpLFxuICAgICAgICAgICAgaGFzQnVpbGRFcnJvciA/IChSZWFjdC5jcmVhdGVFbGVtZW50KEJ1aWxkRXJyb3JfMS5CdWlsZEVycm9yLCB7IG1lc3NhZ2U6IHN0YXRlLmJ1aWxkRXJyb3IgfSkpIDogaGFzUnVudGltZUVycm9ycyA/IChSZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yc18xLkVycm9ycywgeyBlcnJvcnM6IHN0YXRlLmVycm9ycyB9KSkgOiAodW5kZWZpbmVkKSkpIDogKHVuZGVmaW5lZCkpKTtcbn1cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUmVhY3REZXZPdmVybGF5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuVFlQRV9CVUlMRF9PSyA9ICdidWlsZC1vayc7XG5leHBvcnRzLlRZUEVfQlVJTERfRVJST1IgPSAnYnVpbGQtZXJyb3InO1xuZXhwb3J0cy5UWVBFX1JFRkZSRVNIID0gJ2Zhc3QtcmVmcmVzaCc7XG5leHBvcnRzLlRZUEVfVU5IQU5ETEVEX0VSUk9SID0gJ3VuaGFuZGxlZC1lcnJvcic7XG5leHBvcnRzLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWQtcmVqZWN0aW9uJztcbnZhciBoYW5kbGVycyA9IG5ldyBTZXQoKTtcbnZhciBxdWV1ZSA9IFtdO1xuZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgLy8gRHJhaW5pbmcgc2hvdWxkIG5ldmVyIGhhcHBlbiBzeW5jaHJvbm91c2x5IGluIGNhc2UgbXVsdGlwbGUgaGFuZGxlcnMgYXJlXG4gICAgLy8gcmVnaXN0ZXJlZC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXYgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gaGFuZGxlcihldik7IH0pO1xuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgIC8vIFVudGlsIHdlIGFyZSBvdXQgb2YgZXZlbnRzOlxuICAgICAgICBCb29sZWFuKHF1ZXVlLmxlbmd0aCkgJiZcbiAgICAgICAgICAgIC8vIE9yLCBpZiBhbGwgaGFuZGxlcnMgcmVtb3ZlZCB0aGVtc2VsdmVzIGFzIGEgcmVzdWx0IG9mIGhhbmRsaW5nIHRoZVxuICAgICAgICAgICAgLy8gZXZlbnQocylcbiAgICAgICAgICAgIEJvb2xlYW4oaGFuZGxlcnMuc2l6ZSkpIHtcbiAgICAgICAgICAgIF9sb29wXzEoKTtcbiAgICAgICAgfVxuICAgIH0sIDEpO1xufVxuZnVuY3Rpb24gZW1pdChldikge1xuICAgIHF1ZXVlLnB1c2goT2JqZWN0LmZyZWV6ZShfX2Fzc2lnbih7fSwgZXYpKSk7XG4gICAgZHJhaW4oKTtcbn1cbmV4cG9ydHMuZW1pdCA9IGVtaXQ7XG5mdW5jdGlvbiBvbihmbikge1xuICAgIGlmIChoYW5kbGVycy5oYXMoZm4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaGFuZGxlcnMuYWRkKGZuKTtcbiAgICBkcmFpbigpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5vbiA9IG9uO1xuZnVuY3Rpb24gb2ZmKGZuKSB7XG4gICAgaWYgKGhhbmRsZXJzLmhhcyhmbikpIHtcbiAgICAgICAgaGFuZGxlcnNbXCJkZWxldGVcIl0oZm4pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5vZmYgPSBvZmY7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIGFuc2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFuc2VyXCIpKTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIHN0cmlwX2Fuc2lfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwic3RyaXAtYW5zaVwiKSk7XG52YXIgc3RhY2tfZnJhbWVfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL3N0YWNrLWZyYW1lXCIpO1xuZXhwb3J0cy5Db2RlRnJhbWUgPSBmdW5jdGlvbiBDb2RlRnJhbWUoX2EpIHtcbiAgICB2YXIgc3RhY2tGcmFtZSA9IF9hLnN0YWNrRnJhbWUsIGNvZGVGcmFtZSA9IF9hLmNvZGVGcmFtZTtcbiAgICAvLyBTdHJpcCBsZWFkaW5nIHNwYWNlcyBvdXQgb2YgdGhlIGNvZGUgZnJhbWU6XG4gICAgdmFyIGZvcm1hdHRlZEZyYW1lID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGNvZGVGcmFtZS5zcGxpdCgvXFxyP1xcbi9nKTtcbiAgICAgICAgdmFyIHByZWZpeExlbmd0aCA9IGxpbmVzXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChsaW5lKSB7IHJldHVybiAvXj4/ICtcXGQrICtcXHwgKCAqKS8uZXhlYyhzdHJpcF9hbnNpXzFbXCJkZWZhdWx0XCJdKGxpbmUpKTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYucG9wKCk7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChjLCBuKSB7IHJldHVybiAoaXNOYU4oYykgPyBuLmxlbmd0aCA6IE1hdGgubWluKGMsIG4ubGVuZ3RoKSk7IH0sIE5hTik7XG4gICAgICAgIGlmIChwcmVmaXhMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgcF8xID0gJyAnLnJlcGVhdChwcmVmaXhMZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobGluZSwgYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB+KGEgPSBsaW5lLmluZGV4T2YoJ3wnKSlcbiAgICAgICAgICAgICAgICAgICAgPyBsaW5lLnN1YnN0cmluZygwLCBhKSArIGxpbmUuc3Vic3RyaW5nKGEpLnJlcGxhY2UocF8xLCAnJylcbiAgICAgICAgICAgICAgICAgICAgOiBsaW5lO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH0sIFtjb2RlRnJhbWVdKTtcbiAgICB2YXIgZGVjb2RlZCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYW5zZXJfMVtcImRlZmF1bHRcIl0uYW5zaVRvSnNvbihmb3JtYXR0ZWRGcmFtZSwge1xuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIHVzZV9jbGFzc2VzOiB0cnVlLFxuICAgICAgICAgICAgcmVtb3ZlX2VtcHR5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0sIFtmb3JtYXR0ZWRGcmFtZV0pO1xuICAgIHZhciBvcGVuID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzdGFja0ZyYW1lKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKGtleSwgKChfYSA9IHN0YWNrRnJhbWVba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZmV0Y2goXCIvX19uZXh0anNfbGF1bmNoLWVkaXRvcj9cIiArIHBhcmFtcy50b1N0cmluZygpKS50aGVuKGZ1bmN0aW9uICgpIHsgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwb3J0IGVycm9yXG4gICAgICAgIH0pO1xuICAgIH0sIFtzdGFja0ZyYW1lXSk7XG4gICAgLy8gVE9ETzogbWFrZSB0aGUgY2FyZXQgYWJzb2x1dGVcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWNvZGVmcmFtZVwiOiB0cnVlIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHsgcm9sZTogXCJsaW5rXCIsIG9uQ2xpY2s6IG9wZW4sIHRhYkluZGV4OiAxLCB0aXRsZTogXCJDbGljayB0byBvcGVuIGluIHlvdXIgZWRpdG9yXCIgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgc3RhY2tfZnJhbWVfMS5nZXRGcmFtZVNvdXJjZShzdGFja0ZyYW1lKSxcbiAgICAgICAgICAgICAgICBcIiBAIFwiLFxuICAgICAgICAgICAgICAgIHN0YWNrRnJhbWUubWV0aG9kTmFtZSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgZmlsbDogXCJub25lXCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTE4IDEzdjZhMiAyIDAgMCAxLTIgMkg1YTIgMiAwIDAgMS0yLTJWOGEyIDIgMCAwIDEgMi0yaDZcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicG9seWxpbmVcIiwgeyBwb2ludHM6IFwiMTUgMyAyMSAzIDIxIDlcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7IHgxOiBcIjEwXCIsIHkxOiBcIjE0XCIsIHgyOiBcIjIxXCIsIHkyOiBcIjNcIiB9KSkpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaHJcIiwgbnVsbCksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgbnVsbCwgZGVjb2RlZC5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsga2V5OiBcImZyYW1lLVwiICsgaW5kZXgsIHN0eWxlOiBfX2Fzc2lnbih7IGNvbG9yOiBlbnRyeS5mZyA/IFwidmFyKC0tY29sb3ItXCIgKyBlbnRyeS5mZyArIFwiKVwiIDogdW5kZWZpbmVkIH0sIChlbnRyeS5kZWNvcmF0aW9uID09PSAnYm9sZCdcbiAgICAgICAgICAgICAgICA/IHsgZm9udFdlaWdodDogODAwIH1cbiAgICAgICAgICAgICAgICA6IGVudHJ5LmRlY29yYXRpb24gPT09ICdpdGFsaWMnXG4gICAgICAgICAgICAgICAgICAgID8geyBmb250U3R5bGU6ICdpdGFsaWMnIH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpKSB9LCBlbnRyeS5jb250ZW50KSk7IH0pKSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBDb2RlRnJhbWVfMSA9IHJlcXVpcmUoXCIuL0NvZGVGcmFtZVwiKTtcbmV4cG9ydHMuQ29kZUZyYW1lID0gQ29kZUZyYW1lXzEuQ29kZUZyYW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xudmFyIHN0eWxlcyA9IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXTo6c2VsZWN0aW9uLFxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKjo6c2VsZWN0aW9uIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1zZWxlY3Rpb24pO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gKiB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IGhyIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcblxcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci13aWR0aDogMDtcXG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMXB4O1xcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LWJsYWNrKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gcCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBwOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBwID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogMWVtO1xcbiAgICBtYXJnaW4tbGVmdDogMC41cmVtO1xcbiAgfVxcblwiXSwgW1wiXFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSB7XFxuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJnKTtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktZmcpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV06OnNlbGVjdGlvbixcXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdICoge1xcbiAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+ICoge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpXFxuICAgICAgY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNvZGVmcmFtZV0gPiBociB7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogMDtcXG5cXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItd2lkdGg6IDA7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDFweDtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLWJyaWdodC1ibGFjayk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtY29kZWZyYW1lXSA+IHAge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gcDpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jb2RlZnJhbWVdID4gcCA+IHN2ZyB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IDFlbTtcXG4gICAgbWFyZ2luLWxlZnQ6IDAuNXJlbTtcXG4gIH1cXG5cIl0pKSk7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgdXNlX29uX2NsaWNrX291dHNpZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9ob29rcy91c2Utb24tY2xpY2stb3V0c2lkZVwiKTtcbnZhciBEaWFsb2cgPSBmdW5jdGlvbiBEaWFsb2coX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgdHlwZSA9IF9hLnR5cGUsIG9uQ2xvc2UgPSBfYS5vbkNsb3NlLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJ0eXBlXCIsIFwib25DbG9zZVwiXSk7XG4gICAgdmFyIF9iID0gX19yZWFkKFJlYWN0LnVzZVN0YXRlKG51bGwpLCAyKSwgZGlhbG9nID0gX2JbMF0sIHNldERpYWxvZyA9IF9iWzFdO1xuICAgIHZhciBvbkRpYWxvZyA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHNldERpYWxvZyhub2RlKTtcbiAgICB9LCBbXSk7XG4gICAgdXNlX29uX2NsaWNrX291dHNpZGVfMS51c2VPbkNsaWNrT3V0c2lkZShkaWFsb2csIG9uQ2xvc2UpO1xuICAgIC8vIE1ha2UgSFRNTEVsZW1lbnRzIHdpdGggYHJvbGU9bGlua2AgYWNjZXNzaWJsZSB0byBiZSB0cmlnZ2VyZWQgYnkgdGhlXG4gICAgLy8ga2V5Ym9hcmQsIGkuZS4gW0VudGVyXS5cbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZGlhbG9nID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm9vdCA9IGRpYWxvZy5nZXRSb290Tm9kZSgpO1xuICAgICAgICAvLyBBbHdheXMgdHJ1ZSwgYnV0IHdlIGRvIHRoaXMgZm9yIFR5cGVTY3JpcHQ6XG4gICAgICAgIGlmICghKHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFkb3dSb290ID0gcm9vdDtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlcihlKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBzaGFkb3dSb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgJiZcbiAgICAgICAgICAgICAgICBlbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgZWwuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdsaW5rJykge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGVsLmNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2hhZG93Um9vdC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaGFkb3dSb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTsgfTtcbiAgICB9LCBbZGlhbG9nXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBvbkRpYWxvZywgXCJkYXRhLW5leHRqcy1kaWFsb2dcIjogdHJ1ZSwgdGFiSW5kZXg6IC0xLCByb2xlOiBcImRpYWxvZ1wiLCBcImFyaWEtbGFiZWxsZWRieVwiOiBwcm9wc1snYXJpYS1sYWJlbGxlZGJ5J10sIFwiYXJpYS1kZXNjcmliZWRieVwiOiBwcm9wc1snYXJpYS1kZXNjcmliZWRieSddLCBcImFyaWEtbW9kYWxcIjogXCJ0cnVlXCIgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lclwiOiB0cnVlLCBjbGFzc05hbWU6IFwiYmFubmVyLVwiICsgdHlwZSB9KSxcbiAgICAgICAgY2hpbGRyZW4pKTtcbn07XG5leHBvcnRzLkRpYWxvZyA9IERpYWxvZztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIERpYWxvZ0JvZHkgPSBmdW5jdGlvbiBEaWFsb2dCb2R5KF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWRpYWxvZy1ib2R5XCI6IHRydWUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGNoaWxkcmVuKSk7XG59O1xuZXhwb3J0cy5EaWFsb2dCb2R5ID0gRGlhbG9nQm9keTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIERpYWxvZ0NvbnRlbnQgPSBmdW5jdGlvbiBEaWFsb2dDb250ZW50KF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XCI6IHRydWUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGNoaWxkcmVuKSk7XG59O1xuZXhwb3J0cy5EaWFsb2dDb250ZW50ID0gRGlhbG9nQ29udGVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIERpYWxvZ0hlYWRlciA9IGZ1bmN0aW9uIERpYWxvZ0hlYWRlcihfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWU7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1kaWFsb2ctaGVhZGVyXCI6IHRydWUsIGNsYXNzTmFtZTogY2xhc3NOYW1lIH0sIGNoaWxkcmVuKSk7XG59O1xuZXhwb3J0cy5EaWFsb2dIZWFkZXIgPSBEaWFsb2dIZWFkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgRGlhbG9nXzEgPSByZXF1aXJlKFwiLi9EaWFsb2dcIik7XG5leHBvcnRzLkRpYWxvZyA9IERpYWxvZ18xLkRpYWxvZztcbnZhciBEaWFsb2dCb2R5XzEgPSByZXF1aXJlKFwiLi9EaWFsb2dCb2R5XCIpO1xuZXhwb3J0cy5EaWFsb2dCb2R5ID0gRGlhbG9nQm9keV8xLkRpYWxvZ0JvZHk7XG52YXIgRGlhbG9nQ29udGVudF8xID0gcmVxdWlyZShcIi4vRGlhbG9nQ29udGVudFwiKTtcbmV4cG9ydHMuRGlhbG9nQ29udGVudCA9IERpYWxvZ0NvbnRlbnRfMS5EaWFsb2dDb250ZW50O1xudmFyIERpYWxvZ0hlYWRlcl8xID0gcmVxdWlyZShcIi4vRGlhbG9nSGVhZGVyXCIpO1xuZXhwb3J0cy5EaWFsb2dIZWFkZXIgPSBEaWFsb2dIZWFkZXJfMS5EaWFsb2dIZWFkZXI7XG52YXIgc3R5bGVzXzEgPSByZXF1aXJlKFwiLi9zdHlsZXNcIik7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlc18xLnN0eWxlcztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbnZhciBzdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgICBvdXRsaW5lOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXApO1xcbiAgICBib3gtc2hhZG93OiAwIHZhcigtLXNpemUtZ2FwLWhhbGYpIHZhcigtLXNpemUtZ2FwLWRvdWJsZSlcXG4gICAgICByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMCUgLSAzLjVyZW0pO1xcbiAgICBvdmVyZmxvdy15OiBoaWRkZW47XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogNTc2cHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogNTQwcHg7XFxuICAgICAgYm94LXNoYWRvdzogMCB2YXIoLS1zaXplLWdhcCkgdmFyKC0tc2l6ZS1nYXAtcXVhZCkgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgQG1lZGlhIChtaW4td2lkdGg6IDc2OHB4KSB7XFxuICAgIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgICBtYXgtd2lkdGg6IDcyMHB4O1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogOTkycHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogOTYwcHg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFubmVyXS5iYW5uZXItd2FybmluZyB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS15ZWxsb3cpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci1lcnJvciB7XFxuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdOjphZnRlciB7XFxuICAgIHotaW5kZXg6IDI7XFxuICAgIGNvbnRlbnQ6ICcnO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICAvKiBiYW5uZXIgd2lkdGg6ICovXFxuICAgIGJvcmRlci10b3Atd2lkdGg6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAwO1xcbiAgICBib3JkZXItdG9wLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLWJvdHRvbS1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci10b3AtY29sb3I6IGluaGVyaXQ7XFxuICAgIGJvcmRlci1ib3R0b20tY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1jb250ZW50XSB7XFxuICAgIG92ZXJmbG93LXk6IGF1dG87XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICAvKiBjYWxjKHBhZGRpbmcgKyBiYW5uZXIgd2lkdGggb2Zmc2V0KSAqL1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSlcXG4gICAgICB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1oZWFkZXJdIHtcXG4gICAgZmxleC1zaHJpbms6IDA7XFxuICAgIG1hcmdpbi1ib3R0b206IHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdID4gW2RhdGEtbmV4dGpzLWRpYWxvZy1ib2R5XSB7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgZmxleDogMSAxIGF1dG87XFxuICB9XFxuXCJdLCBbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ddIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIG1hcmdpbi1yaWdodDogYXV0bztcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICAgIG91dGxpbmU6IG5vbmU7XFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGJveC1zaGFkb3c6IDAgdmFyKC0tc2l6ZS1nYXAtaGFsZikgdmFyKC0tc2l6ZS1nYXAtZG91YmxlKVxcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICAgIG1heC1oZWlnaHQ6IGNhbGMoMTAwJSAtIDMuNXJlbSk7XFxuICAgIG92ZXJmbG93LXk6IGhpZGRlbjtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA1NzZweCkge1xcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgICAgbWF4LXdpZHRoOiA1NDBweDtcXG4gICAgICBib3gtc2hhZG93OiAwIHZhcigtLXNpemUtZ2FwKSB2YXIoLS1zaXplLWdhcC1xdWFkKSByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcXG4gICAgW2RhdGEtbmV4dGpzLWRpYWxvZ10ge1xcbiAgICAgIG1heC13aWR0aDogNzIwcHg7XFxuICAgIH1cXG4gIH1cXG5cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA5OTJweCkge1xcbiAgICBbZGF0YS1uZXh0anMtZGlhbG9nXSB7XFxuICAgICAgbWF4LXdpZHRoOiA5NjBweDtcXG4gICAgfVxcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYW5uZXJdLmJhbm5lci13YXJuaW5nIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXllbGxvdyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl0uYmFubmVyLWVycm9yIHtcXG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhbm5lcl06OmFmdGVyIHtcXG4gICAgei1pbmRleDogMjtcXG4gICAgY29udGVudDogJyc7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIC8qIGJhbm5lciB3aWR0aDogKi9cXG4gICAgYm9yZGVyLXRvcC13aWR0aDogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJvcmRlci1ib3R0b20td2lkdGg6IDA7XFxuICAgIGJvcmRlci10b3Atc3R5bGU6IHNvbGlkO1xcbiAgICBib3JkZXItYm90dG9tLXN0eWxlOiBzb2xpZDtcXG4gICAgYm9yZGVyLXRvcC1jb2xvcjogaW5oZXJpdDtcXG4gICAgYm9yZGVyLWJvdHRvbS1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWNvbnRlbnRdIHtcXG4gICAgb3ZlcmZsb3cteTogYXV0bztcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIC8qIGNhbGMocGFkZGluZyArIGJhbm5lciB3aWR0aCBvZmZzZXQpICovXFxuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIHZhcigtLXNpemUtZ2FwLWRvdWJsZSk7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctY29udGVudF0gPiBbZGF0YS1uZXh0anMtZGlhbG9nLWhlYWRlcl0ge1xcbiAgICBmbGV4LXNocmluazogMDtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctY29udGVudF0gPiBbZGF0YS1uZXh0anMtZGlhbG9nLWJvZHldIHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBmbGV4OiAxIDEgYXV0bztcXG4gIH1cXG5cIl0pKSk7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgTGVmdFJpZ2h0RGlhbG9nSGVhZGVyID0gZnVuY3Rpb24gTGVmdFJpZ2h0RGlhbG9nSGVhZGVyKF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgcHJldmlvdXMgPSBfYS5wcmV2aW91cywgbmV4dCA9IF9hLm5leHQsIGNsb3NlID0gX2EuY2xvc2U7XG4gICAgdmFyIGJ1dHRvbkxlZnQgPSBSZWFjdC51c2VSZWYoKTtcbiAgICB2YXIgYnV0dG9uUmlnaHQgPSBSZWFjdC51c2VSZWYoKTtcbiAgICB2YXIgYnV0dG9uQ2xvc2UgPSBSZWFjdC51c2VSZWYoKTtcbiAgICB2YXIgX2IgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUobnVsbCksIDIpLCBuYXYgPSBfYlswXSwgc2V0TmF2ID0gX2JbMV07XG4gICAgdmFyIG9uTmF2ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHNldE5hdihlbCk7XG4gICAgfSwgW10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb290ID0gbmF2LmdldFJvb3ROb2RlKCk7XG4gICAgICAgIHZhciBkID0gc2VsZi5kb2N1bWVudDtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlcihlKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdBcnJvd0xlZnQnKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uTGVmdC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkxlZnQuY3VycmVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2aW91cyAmJiBwcmV2aW91cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZS5rZXkgPT09ICdBcnJvd1JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1dHRvblJpZ2h0LmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uUmlnaHQuY3VycmVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ICYmIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gcm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoYSAmJiBhICE9PSBidXR0b25DbG9zZS5jdXJyZW50ICYmIGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcbiAgICAgICAgaWYgKHJvb3QgIT09IGQpIHtcbiAgICAgICAgICAgIGQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChyb290ICE9PSBkKSB7XG4gICAgICAgICAgICAgICAgZC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW2Nsb3NlLCBuYXYsIG5leHQsIHByZXZpb3VzXSk7XG4gICAgLy8gVW5sb2NrIGZvY3VzIGZvciBicm93c2VycyBsaWtlIEZpcmVmb3gsIHRoYXQgYnJlYWsgYWxsIHVzZXIgZm9jdXMgaWYgdGhlXG4gICAgLy8gY3VycmVudGx5IGZvY3VzZWQgaXRlbSBiZWNvbWVzIGRpc2FibGVkLlxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuYXYgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb290ID0gbmF2LmdldFJvb3ROb2RlKCk7XG4gICAgICAgIC8vIEFsd2F5cyB0cnVlLCBidXQgd2UgZG8gdGhpcyBmb3IgVHlwZVNjcmlwdDpcbiAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgICAgICB2YXIgYSA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IGJ1dHRvbkxlZnQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b25MZWZ0LmN1cnJlbnQuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChhID09PSBidXR0b25SaWdodC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvblJpZ2h0LmN1cnJlbnQuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtuYXYsIG5leHQsIHByZXZpb3VzXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodFwiOiB0cnVlLCBjbGFzc05hbWU6IGNsYXNzTmFtZSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibmF2XCIsIHsgcmVmOiBvbk5hdiB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHJlZjogYnV0dG9uTGVmdCwgdHlwZTogXCJidXR0b25cIiwgZGlzYWJsZWQ6IHByZXZpb3VzID09IG51bGwgPyB0cnVlIDogdW5kZWZpbmVkLCBcImFyaWEtZGlzYWJsZWRcIjogcHJldmlvdXMgPT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IHByZXZpb3VzICE9PSBudWxsICYmIHByZXZpb3VzICE9PSB2b2lkIDAgPyBwcmV2aW91cyA6IHVuZGVmaW5lZCB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB2aWV3Qm94OiBcIjAgMCAxNCAxNFwiLCBmaWxsOiBcIm5vbmVcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTYuOTk5OTYgMS4xNjY2NkwxLjE2NjYzIDYuOTk5OTlMNi45OTk5NiAxMi44MzMzTTEyLjgzMzMgNi45OTk5OUgxLjk5OTk2SDEyLjgzMzNaXCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSkpKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyByZWY6IGJ1dHRvblJpZ2h0LCB0eXBlOiBcImJ1dHRvblwiLCBkaXNhYmxlZDogbmV4dCA9PSBudWxsID8gdHJ1ZSA6IHVuZGVmaW5lZCwgXCJhcmlhLWRpc2FibGVkXCI6IG5leHQgPT0gbnVsbCA/IHRydWUgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IG5leHQgIT09IG51bGwgJiYgbmV4dCAhPT0gdm9pZCAwID8gbmV4dCA6IHVuZGVmaW5lZCB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB2aWV3Qm94OiBcIjAgMCAxNCAxNFwiLCBmaWxsOiBcIm5vbmVcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTYuOTk5OTYgMS4xNjY2NkwxMi44MzMzIDYuOTk5OTlMNi45OTk5NiAxMi44MzMzTTEuMTY2NjMgNi45OTk5OUgxMkgxLjE2NjYzWlwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0pKSksXG4gICAgICAgICAgICBcIlxcdTAwQTBcIixcbiAgICAgICAgICAgIGNoaWxkcmVuKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHJlZjogYnV0dG9uQ2xvc2UsIHR5cGU6IFwiYnV0dG9uXCIsIG9uQ2xpY2s6IGNsb3NlLCBcImFyaWEtbGFiZWxcIjogXCJDbG9zZVwiIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgd2lkdGg6IFwiMjRcIiwgaGVpZ2h0OiBcIjI0XCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwibm9uZVwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTggNkw2IDE4XCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNiA2TDE4IDE4XCIsIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiLCBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSkpKSkpKTtcbn07XG5leHBvcnRzLkxlZnRSaWdodERpYWxvZ0hlYWRlciA9IExlZnRSaWdodERpYWxvZ0hlYWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBMZWZ0UmlnaHREaWFsb2dIZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0xlZnRSaWdodERpYWxvZ0hlYWRlclwiKTtcbmV4cG9ydHMuTGVmdFJpZ2h0RGlhbG9nSGVhZGVyID0gTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEuTGVmdFJpZ2h0RGlhbG9nSGVhZGVyO1xudmFyIHN0eWxlc18xID0gcmVxdWlyZShcIi4vc3R5bGVzXCIpO1xuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXNfMS5zdHlsZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gICAgcmV0dXJuIGNvb2tlZDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XG52YXIgc3R5bGVzID0gbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbiB7XFxuICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG5cXG4gICAgd2lkdGg6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zaXplLWdhcC1kb3VibGUpICsgdmFyKC0tc2l6ZS1nYXApKTtcXG4gICAgZm9udC1zaXplOiAwO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMSk7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hbnNpLXJlZCk7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAwLjI1cyBlYXNlO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbiA+IHN2ZyB7XFxuICAgIHdpZHRoOiBhdXRvO1xcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMik7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmRpc2FibGVkIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDg1LCA4NSwgMC4xKTtcXG4gICAgY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuNCk7XFxuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gbmF2ID4gYnV0dG9uOmZpcnN0LW9mLXR5cGUge1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKSAwIDAgdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIG1hcmdpbi1yaWdodDogMXB4O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpsYXN0LW9mLXR5cGUge1xcbiAgICBib3JkZXItcmFkaXVzOiAwIHZhcigtLXNpemUtZ2FwLWhhbGYpIHZhcigtLXNpemUtZ2FwLWhhbGYpIDA7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWxlZnQtcmlnaHRdID4gYnV0dG9uOmxhc3Qtb2YtdHlwZSB7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgcGFkZGluZzogMDtcXG5cXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgIGFwcGVhcmFuY2U6IG5vbmU7XFxuXFxuICAgIG9wYWNpdHk6IDAuNDtcXG4gICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjI1cyBlYXNlO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IGJ1dHRvbjpsYXN0LW9mLXR5cGU6aG92ZXIge1xcbiAgICBvcGFjaXR5OiAwLjc7XFxuICB9XFxuXCJdLCBbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0ge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24ge1xcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXFxuICAgIHdpZHRoOiBjYWxjKHZhcigtLXNpemUtZ2FwLWRvdWJsZSkgKyB2YXIoLS1zaXplLWdhcCkpO1xcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICAgIGZvbnQtc2l6ZTogMDtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjEpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b24gPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjIpO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpkaXNhYmxlZCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCA4NSwgODUsIDAuMSk7XFxuICAgIGNvbG9yOiByZ2JhKDI1NSwgODUsIDg1LCAwLjQpO1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IG5hdiA+IGJ1dHRvbjpmaXJzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZikgMCAwIHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDFweDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBuYXYgPiBidXR0b246bGFzdC1vZi10eXBlIHtcXG4gICAgYm9yZGVyLXJhZGl1czogMCB2YXIoLS1zaXplLWdhcC1oYWxmKSB2YXIoLS1zaXplLWdhcC1oYWxmKSAwO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1sZWZ0LXJpZ2h0XSA+IGJ1dHRvbjpsYXN0LW9mLXR5cGUge1xcbiAgICBib3JkZXI6IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuXFxuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICBhcHBlYXJhbmNlOiBub25lO1xcblxcbiAgICBvcGFjaXR5OiAwLjQ7XFxuICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4yNXMgZWFzZTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctbGVmdC1yaWdodF0gPiBidXR0b246bGFzdC1vZi10eXBlOmhvdmVyIHtcXG4gICAgb3BhY2l0eTogMC43O1xcbiAgfVxcblwiXSkpKTtcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgZGlzYWJsZWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYWxseS5qcy9tYWludGFpbi9kaXNhYmxlZFwiKSk7XG52YXIgdGFiX2ZvY3VzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFsbHkuanMvbWFpbnRhaW4vdGFiLWZvY3VzXCIpKTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIGJvZHlfbG9ja2VyXzEgPSByZXF1aXJlKFwiLi9ib2R5LWxvY2tlclwiKTtcbnZhciBPdmVybGF5ID0gZnVuY3Rpb24gT3ZlcmxheShfYSkge1xuICAgIHZhciBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGZpeGVkID0gX2EuZml4ZWQ7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYm9keV9sb2NrZXJfMS5sb2NrKCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBib2R5X2xvY2tlcl8xLnVubG9jaygpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgX2IgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUobnVsbCksIDIpLCBvdmVybGF5ID0gX2JbMF0sIHNldE92ZXJsYXkgPSBfYlsxXTtcbiAgICB2YXIgb25PdmVybGF5ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHNldE92ZXJsYXkoZWwpO1xuICAgIH0sIFtdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAob3ZlcmxheSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhbmRsZTEgPSBkaXNhYmxlZF8xW1wiZGVmYXVsdFwiXSh7IGZpbHRlcjogb3ZlcmxheSB9KTtcbiAgICAgICAgdmFyIGhhbmRsZTIgPSB0YWJfZm9jdXNfMVtcImRlZmF1bHRcIl0oeyBjb250ZXh0OiBvdmVybGF5IH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaGFuZGxlMS5kaXNlbmdhZ2UoKTtcbiAgICAgICAgICAgIGhhbmRsZTIuZGlzZW5nYWdlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW292ZXJsYXldKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImRhdGEtbmV4dGpzLWRpYWxvZy1vdmVybGF5XCI6IHRydWUsIGNsYXNzTmFtZTogY2xhc3NOYW1lLCByZWY6IG9uT3ZlcmxheSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3BcIjogdHJ1ZSwgXCJkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3AtZml4ZWRcIjogZml4ZWQgPyB0cnVlIDogdW5kZWZpbmVkIH0pLFxuICAgICAgICBjaGlsZHJlbikpO1xufTtcbmV4cG9ydHMuT3ZlcmxheSA9IE92ZXJsYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgcHJldmlvdXNCb2R5UGFkZGluZ1JpZ2h0O1xudmFyIHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZztcbnZhciBhY3RpdmVMb2NrcyA9IDA7XG5mdW5jdGlvbiBsb2NrKCkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoYWN0aXZlTG9ja3MrKyA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2Nyb2xsQmFyR2FwID0gd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIGlmIChzY3JvbGxCYXJHYXAgPiAwKSB7XG4gICAgICAgICAgICBwcmV2aW91c0JvZHlQYWRkaW5nUmlnaHQgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodDtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0ID0gc2Nyb2xsQmFyR2FwICsgXCJweFwiO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzQm9keU92ZXJmbG93U2V0dGluZyA9IGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9jayA9IGxvY2s7XG5mdW5jdGlvbiB1bmxvY2soKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhY3RpdmVMb2NrcyA9PT0gMCB8fCAtLWFjdGl2ZUxvY2tzICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHByZXZpb3VzQm9keVBhZGRpbmdSaWdodDtcbiAgICAgICAgICAgIHByZXZpb3VzQm9keVBhZGRpbmdSaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlvdXNCb2R5T3ZlcmZsb3dTZXR0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmc7XG4gICAgICAgICAgICBwcmV2aW91c0JvZHlPdmVyZmxvd1NldHRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMudW5sb2NrID0gdW5sb2NrO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIE92ZXJsYXlfMSA9IHJlcXVpcmUoXCIuL092ZXJsYXlcIik7XG5leHBvcnRzLk92ZXJsYXkgPSBPdmVybGF5XzEuT3ZlcmxheTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbnZhciBzdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLW92ZXJsYXldIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICB6LWluZGV4OiA5MDAwO1xcblxcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIHBhZGRpbmc6IDEwdmggMTVweCAwO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcF0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxNywgMTcsIDE3LCAwLjIpO1xcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xcbiAgICB6LWluZGV4OiAtMTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctYmFja2Ryb3AtZml4ZWRdIHtcXG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcXG4gICAgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IGJsdXIoOHB4KTtcXG4gICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDhweCk7XFxuICB9XFxuXCJdLCBbXCJcXG4gIFtkYXRhLW5leHRqcy1kaWFsb2ctb3ZlcmxheV0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIHotaW5kZXg6IDkwMDA7XFxuXFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgcGFkZGluZzogMTB2aCAxNXB4IDA7XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtZGlhbG9nLWJhY2tkcm9wXSB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDE3LCAxNywgMTcsIDAuMik7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBhbGw7XFxuICAgIHotaW5kZXg6IC0xO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWRpYWxvZy1iYWNrZHJvcC1maXhlZF0ge1xcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xcbiAgICAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogYmx1cig4cHgpO1xcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoOHB4KTtcXG4gIH1cXG5cIl0pKSk7XG5leHBvcnRzLnN0eWxlcyA9IHN0eWxlcztcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgcmVhY3RfZG9tXzEgPSByZXF1aXJlKFwicmVhY3QtZG9tXCIpO1xuZXhwb3J0cy5TaGFkb3dQb3J0YWwgPSBmdW5jdGlvbiBQb3J0YWwoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICB2YXIgbW91bnROb2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBwb3J0YWxOb2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBzaGFkb3dOb2RlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZSgpLCAyKSwgZm9yY2VVcGRhdGUgPSBfYlsxXTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IG1vdW50Tm9kZS5jdXJyZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIHBvcnRhbE5vZGUuY3VycmVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbmV4dGpzLXBvcnRhbCcpO1xuICAgICAgICBzaGFkb3dOb2RlLmN1cnJlbnQgPSBwb3J0YWxOb2RlLmN1cnJlbnQuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICBvd25lckRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocG9ydGFsTm9kZS5jdXJyZW50KTtcbiAgICAgICAgZm9yY2VVcGRhdGUoe30pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHBvcnRhbE5vZGUuY3VycmVudCAmJiBwb3J0YWxOb2RlLmN1cnJlbnQub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHBvcnRhbE5vZGUuY3VycmVudC5vd25lckRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocG9ydGFsTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHNoYWRvd05vZGUuY3VycmVudCA/IChyZWFjdF9kb21fMS5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHNoYWRvd05vZGUuY3VycmVudCkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgcmVmOiBtb3VudE5vZGUgfSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgYW5zZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYW5zZXJcIikpO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5leHBvcnRzLlRlcm1pbmFsID0gZnVuY3Rpb24gVGVybWluYWwoX2EpIHtcbiAgICB2YXIgY29udGVudCA9IF9hLmNvbnRlbnQ7XG4gICAgdmFyIGRlY29kZWQgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFuc2VyXzFbXCJkZWZhdWx0XCJdLmFuc2lUb0pzb24oY29udGVudCwge1xuICAgICAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgICAgIHVzZV9jbGFzc2VzOiB0cnVlLFxuICAgICAgICAgICAgcmVtb3ZlX2VtcHR5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0sIFtjb250ZW50XSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJkYXRhLW5leHRqcy10ZXJtaW5hbFwiOiB0cnVlIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgbnVsbCwgZGVjb2RlZC5tYXAoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsga2V5OiBcInRlcm1pbmFsLWVudHJ5LVwiICsgaW5kZXgsIHN0eWxlOiBfX2Fzc2lnbih7IGNvbG9yOiBlbnRyeS5mZyA/IFwidmFyKC0tY29sb3ItXCIgKyBlbnRyeS5mZyArIFwiKVwiIDogdW5kZWZpbmVkIH0sIChlbnRyeS5kZWNvcmF0aW9uID09PSAnYm9sZCdcbiAgICAgICAgICAgICAgICA/IHsgZm9udFdlaWdodDogODAwIH1cbiAgICAgICAgICAgICAgICA6IGVudHJ5LmRlY29yYXRpb24gPT09ICdpdGFsaWMnXG4gICAgICAgICAgICAgICAgICAgID8geyBmb250U3R5bGU6ICdpdGFsaWMnIH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpKSB9LCBlbnRyeS5jb250ZW50KSk7IH0pKSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBUZXJtaW5hbF8xID0gcmVxdWlyZShcIi4vVGVybWluYWxcIik7XG5leHBvcnRzLlRlcm1pbmFsID0gVGVybWluYWxfMS5UZXJtaW5hbDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbnZhciBzdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdOjpzZWxlY3Rpb24sXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gPiAqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xcbiAgfVxcblwiXSwgW1wiXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdIHtcXG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tc2l6ZS1nYXAtaGFsZik7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYmcpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1mZyk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdOjpzZWxlY3Rpb24sXFxuICBbZGF0YS1uZXh0anMtdGVybWluYWxdICo6OnNlbGVjdGlvbiB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktc2VsZWN0aW9uKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gKiB7XFxuICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gPiAqIHtcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNpemUtZ2FwKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKVxcbiAgICAgIGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy10ZXJtaW5hbF0gcHJlIHtcXG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xcbiAgfVxcblwiXSkpKTtcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbmV4cG9ydHMuVG9hc3QgPSBmdW5jdGlvbiBUb2FzdChfYSkge1xuICAgIHZhciBvbkNsaWNrID0gX2Eub25DbGljaywgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtdG9hc3RcIjogdHJ1ZSwgb25DbGljazogb25DbGljaywgY2xhc3NOYW1lOiBjbGFzc05hbWUgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtdG9hc3Qtd3JhcHBlclwiOiB0cnVlIH0sIGNoaWxkcmVuKSkpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBzdHlsZXNfMSA9IHJlcXVpcmUoXCIuL3N0eWxlc1wiKTtcbmV4cG9ydHMuc3R5bGVzID0gc3R5bGVzXzEuc3R5bGVzO1xudmFyIFRvYXN0XzEgPSByZXF1aXJlKFwiLi9Ub2FzdFwiKTtcbmV4cG9ydHMuVG9hc3QgPSBUb2FzdF8xLlRvYXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xudmFyIHN0eWxlcyA9IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIFtkYXRhLW5leHRqcy10b2FzdF0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgbWF4LXdpZHRoOiA0MjBweDtcXG4gICAgei1pbmRleDogOTAwMDtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA0NDBweCkge1xcbiAgICBbZGF0YS1uZXh0anMtdG9hc3RdIHtcXG4gICAgICBtYXgtd2lkdGg6IDkwdnc7XFxuICAgICAgbGVmdDogNXZ3O1xcbiAgICB9XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtdG9hc3Qtd3JhcHBlcl0ge1xcbiAgICBwYWRkaW5nOiAxcmVtO1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICBib3gtc2hhZG93OiAwcHggdmFyKC0tc2l6ZS1nYXAtZG91YmxlKSB2YXIoLS1zaXplLWdhcC1xdWFkKVxcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICB9XFxuXCJdLCBbXCJcXG4gIFtkYXRhLW5leHRqcy10b2FzdF0ge1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gICAgbWF4LXdpZHRoOiA0MjBweDtcXG4gICAgei1pbmRleDogOTAwMDtcXG4gIH1cXG5cXG4gIEBtZWRpYSAobWF4LXdpZHRoOiA0NDBweCkge1xcbiAgICBbZGF0YS1uZXh0anMtdG9hc3RdIHtcXG4gICAgICBtYXgtd2lkdGg6IDkwdnc7XFxuICAgICAgbGVmdDogNXZ3O1xcbiAgICB9XFxuICB9XFxuXFxuICBbZGF0YS1uZXh0anMtdG9hc3Qtd3JhcHBlcl0ge1xcbiAgICBwYWRkaW5nOiAxcmVtO1xcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1zaXplLWdhcC1oYWxmKTtcXG4gICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlKTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICBib3gtc2hhZG93OiAwcHggdmFyKC0tc2l6ZS1nYXAtZG91YmxlKSB2YXIoLS1zaXplLWdhcC1xdWFkKVxcbiAgICAgIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICB9XFxuXCJdKSkpO1xuZXhwb3J0cy5zdHlsZXMgPSBzdHlsZXM7XG52YXIgdGVtcGxhdGVPYmplY3RfMTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBEaWFsb2dfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0RpYWxvZ1wiKTtcbnZhciBPdmVybGF5XzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9PdmVybGF5XCIpO1xudmFyIFRlcm1pbmFsXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9UZXJtaW5hbFwiKTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZXhwb3J0cy5CdWlsZEVycm9yID0gZnVuY3Rpb24gQnVpbGRFcnJvcihfYSkge1xuICAgIHZhciBtZXNzYWdlID0gX2EubWVzc2FnZTtcbiAgICB2YXIgbm9vcCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHsgfSwgW10pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChPdmVybGF5XzEuT3ZlcmxheSwgeyBmaXhlZDogdHJ1ZSB9LFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZywgeyB0eXBlOiBcImVycm9yXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IFwibmV4dGpzX19jb250YWluZXJfYnVpbGRfZXJyb3JfbGFiZWxcIiwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IFwibmV4dGpzX19jb250YWluZXJfYnVpbGRfZXJyb3JfZGVzY1wiLCBvbkNsb3NlOiBub29wIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0NvbnRlbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaWFsb2dfMS5EaWFsb2dIZWFkZXIsIHsgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg0XCIsIHsgaWQ6IFwibmV4dGpzX19jb250YWluZXJfYnVpbGRfZXJyb3JfbGFiZWxcIiB9LCBcIkZhaWxlZCB0byBjb21waWxlXCIpKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0JvZHksIHsgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItYm9keVwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoVGVybWluYWxfMS5UZXJtaW5hbCwgeyBjb250ZW50OiBtZXNzYWdlIH0pLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9vdGVyXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicFwiLCB7IGlkOiBcIm5leHRqc19fY29udGFpbmVyX2J1aWxkX2Vycm9yX2Rlc2NcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzbWFsbFwiLCBudWxsLCBcIlRoaXMgZXJyb3Igb2NjdXJlZCBkdXJpbmcgdGhlIGJ1aWxkIHByb2Nlc3MgYW5kIGNhbiBvbmx5IGJlIGRpc21pc3NlZCBieSBmaXhpbmcgdGhlIGVycm9yLlwiKSkpKSkpKSk7XG59O1xuZXhwb3J0cy5zdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1oZWFkZXIgPiBoNCB7XFxuICAgIGxpbmUtaGVpZ2h0OiAxLjU7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogMDtcXG4gIH1cXG5cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHtcXG4gICAgbWFyZ2luLXRvcDogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItYm9keSBmb290ZXIgcCB7XFxuICAgIG1hcmdpbjogMDtcXG4gIH1cXG5cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgc21hbGwge1xcbiAgICBjb2xvcjogIzc1NzU3NTtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgLm5leHRqcy1jb250YWluZXItYnVpbGQtZXJyb3ItaGVhZGVyID4gaDQge1xcbiAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IGZvb3RlciB7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWJ1aWxkLWVycm9yLWJvZHkgZm9vdGVyIHAge1xcbiAgICBtYXJnaW46IDA7XFxuICB9XFxuXFxuICAubmV4dGpzLWNvbnRhaW5lci1idWlsZC1lcnJvci1ib2R5IHNtYWxsIHtcXG4gICAgY29sb3I6ICM3NTc1NzU7XFxuICB9XFxuXCJdKSkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gICAgcmV0dXJuIGNvb2tlZDtcbn07XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBidXNfMSA9IHJlcXVpcmUoXCIuLi9idXNcIik7XG52YXIgRGlhbG9nXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9EaWFsb2dcIik7XG52YXIgTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9MZWZ0UmlnaHREaWFsb2dIZWFkZXJcIik7XG52YXIgT3ZlcmxheV8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvT3ZlcmxheVwiKTtcbnZhciBUb2FzdF8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvVG9hc3RcIik7XG52YXIgbm9kZVN0YWNrRnJhbWVzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub2RlU3RhY2tGcmFtZXNcIik7XG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbnZhciBzdGFja19mcmFtZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvc3RhY2stZnJhbWVcIik7XG52YXIgUnVudGltZUVycm9yXzEgPSByZXF1aXJlKFwiLi9SdW50aW1lRXJyb3JcIik7XG5mdW5jdGlvbiBnZXRFcnJvclNpZ25hdHVyZShldikge1xuICAgIHZhciBldmVudCA9IGV2LmV2ZW50O1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgICBjYXNlIGJ1c18xLlRZUEVfVU5IQU5ETEVEX0VSUk9SOlxuICAgICAgICBjYXNlIGJ1c18xLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTjoge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LnJlYXNvbi5uYW1lICsgXCI6OlwiICsgZXZlbnQucmVhc29uLm1lc3NhZ2UgKyBcIjo6XCIgKyBldmVudC5yZWFzb24uc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgXyA9IGV2ZW50O1xuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGdldEVycm9yQnlUeXBlKGV2KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQsIGV2ZW50LCBfYSwgX2IsIF87XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlkID0gZXYuaWQsIGV2ZW50ID0gZXYuZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgIF9hID0gZXZlbnQudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBidXNfMS5UWVBFX1VOSEFORExFRF9FUlJPUjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGJ1c18xLlRZUEVfVU5IQU5ETEVEX1JFSkVDVElPTjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bnRpbWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXZlbnQucmVhc29uXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0YWNrX2ZyYW1lXzEuZ2V0T3JpZ2luYWxTdGFja0ZyYW1lcyhldmVudC5mcmFtZXMpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCAoX2IuZnJhbWVzID0gX2Muc2VudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX2IpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gNDtcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIF8gPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0eXBlIHN5c3RlbSBpbnZhcmlhbnQgdmlvbGF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5FcnJvcnMgPSBmdW5jdGlvbiBFcnJvcnMoX2EpIHtcbiAgICB2YXIgZXJyb3JzID0gX2EuZXJyb3JzO1xuICAgIHZhciBfYiA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZSh7fSksIDIpLCBsb29rdXBzID0gX2JbMF0sIHNldExvb2t1cHMgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSBfX3JlYWQoUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWFkeSA9IFtdO1xuICAgICAgICB2YXIgbmV4dCA9IG51bGw7XG4gICAgICAgIC8vIEVuc3VyZSBlcnJvcnMgYXJlIGRpc3BsYXllZCBpbiB0aGUgb3JkZXIgdGhleSBvY2N1cnJlZCBpbjpcbiAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZXJyb3JzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIHZhciBlID0gZXJyb3JzW2lkeF07XG4gICAgICAgICAgICB2YXIgaWQgPSBlLmlkO1xuICAgICAgICAgICAgaWYgKGlkIGluIGxvb2t1cHMpIHtcbiAgICAgICAgICAgICAgICByZWFkeS5wdXNoKGxvb2t1cHNbaWRdKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGUgZXJyb3JzXG4gICAgICAgICAgICBpZiAoaWR4ID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2ID0gZXJyb3JzW2lkeCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChnZXRFcnJvclNpZ25hdHVyZShwcmV2KSA9PT0gZ2V0RXJyb3JTaWduYXR1cmUoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3JlYWR5LCBuZXh0XTtcbiAgICB9LCBbZXJyb3JzLCBsb29rdXBzXSksIDIpLCByZWFkeUVycm9ycyA9IF9jWzBdLCBuZXh0RXJyb3IgPSBfY1sxXTtcbiAgICB2YXIgaXNMb2FkaW5nID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZWFkeUVycm9ycy5sZW5ndGggPCAxICYmIEJvb2xlYW4oZXJyb3JzLmxlbmd0aCk7XG4gICAgfSwgW2Vycm9ycy5sZW5ndGgsIHJlYWR5RXJyb3JzLmxlbmd0aF0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChuZXh0RXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGdldEVycm9yQnlUeXBlKG5leHRFcnJvcikudGhlbihmdW5jdGlvbiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGNhcmUgaWYgdGhlIGRlc2lyZWQgZXJyb3IgY2hhbmdlZCB3aGlsZSB3ZSB3ZXJlIHJlc29sdmluZyxcbiAgICAgICAgICAgIC8vIHRodXMgd2UncmUgbm90IHRyYWNraW5nIGl0IHVzaW5nIGEgcmVmLiBPbmNlIHRoZSB3b3JrIGhhcyBiZWVuIGRvbmUsXG4gICAgICAgICAgICAvLyB3ZSdsbCBzdG9yZSBpdC5cbiAgICAgICAgICAgIHNldExvb2t1cHMoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbSksIChfYSA9IHt9LCBfYVtyZXNvbHZlZC5pZF0gPSByZXNvbHZlZCwgX2EpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlIHRoaXMsIHRob3VnaCBhbiBlZGdlIGNhc2VcbiAgICAgICAgfSk7XG4gICAgfSwgW25leHRFcnJvcl0pO1xuICAgIHZhciBfZCA9IF9fcmVhZChSZWFjdC51c2VTdGF0ZShmYWxzZSksIDIpLCBpc01pbmltaXplZCA9IF9kWzBdLCBzZXRNaW5pbWl6ZWQgPSBfZFsxXTtcbiAgICB2YXIgX2UgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUoMCksIDIpLCBhY3RpdmVJZHggPSBfZVswXSwgc2V0QWN0aXZlSW5kZXggPSBfZVsxXTtcbiAgICB2YXIgcHJldmlvdXMgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoZSkge1xuICAgICAgICBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgc2V0QWN0aXZlSW5kZXgoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIE1hdGgubWF4KDAsIHYgLSAxKTsgfSk7XG4gICAgfSwgW10pO1xuICAgIHZhciBuZXh0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldEFjdGl2ZUluZGV4KGZ1bmN0aW9uICh2KSB7IHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbihyZWFkeUVycm9ycy5sZW5ndGggLSAxLCB2ICsgMSkpOyB9KTtcbiAgICB9LCBbcmVhZHlFcnJvcnMubGVuZ3RoXSk7XG4gICAgdmFyIGFjdGl2ZUVycm9yID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHJlYWR5RXJyb3JzW2FjdGl2ZUlkeF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7IH0sIFthY3RpdmVJZHgsIHJlYWR5RXJyb3JzXSk7XG4gICAgLy8gUmVzZXQgY29tcG9uZW50IHN0YXRlIHdoZW4gdGhlcmUgYXJlIG5vIGVycm9ycyB0byBiZSBkaXNwbGF5ZWQuXG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgbGV0cyBoYW5kbGUgaXQuXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBzZXRMb29rdXBzKHt9KTtcbiAgICAgICAgICAgIHNldE1pbmltaXplZChmYWxzZSk7XG4gICAgICAgICAgICBzZXRBY3RpdmVJbmRleCgwKTtcbiAgICAgICAgfVxuICAgIH0sIFtlcnJvcnMubGVuZ3RoXSk7XG4gICAgdmFyIG1pbmltaXplID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNldE1pbmltaXplZCh0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHJlb3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXRNaW5pbWl6ZWQoZmFsc2UpO1xuICAgIH0sIFtdKTtcbiAgICAvLyBUaGlzIGNvbXBvbmVudCBzaG91bGRuJ3QgYmUgcmVuZGVyZWQgd2l0aCBubyBlcnJvcnMsIGJ1dCBpZiBpdCBpcywgbGV0J3NcbiAgICAvLyBoYW5kbGUgaXQgZ3JhY2VmdWxseSBieSByZW5kZXJpbmcgbm90aGluZy5cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChpc0xvYWRpbmcpIHtcbiAgICAgICAgLy8gVE9ETzogYmV0dGVyIGxvYWRpbmcgc3RhdGVcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoT3ZlcmxheV8xLk92ZXJsYXksIG51bGwpO1xuICAgIH1cbiAgICBpZiAoaXNNaW5pbWl6ZWQpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFRvYXN0XzEuVG9hc3QsIHsgY2xhc3NOYW1lOiBcIm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50XCIsIG9uQ2xpY2s6IHJlb3BlbiB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJuZXh0anMtdG9hc3QtZXJyb3JzXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgd2lkdGg6IFwiMjRcIiwgaGVpZ2h0OiBcIjI0XCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwgeyBjeDogXCIxMlwiLCBjeTogXCIxMlwiLCByOiBcIjEwXCIgfSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lXCIsIHsgeDE6IFwiMTJcIiwgeTE6IFwiOFwiLCB4MjogXCIxMlwiLCB5MjogXCIxMlwiIH0pLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwibGluZVwiLCB7IHgxOiBcIjEyXCIsIHkxOiBcIjE2XCIsIHgyOiBcIjEyLjAxXCIsIHkyOiBcIjE2XCIgfSkpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlYWR5RXJyb3JzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgXCIgZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhZHlFcnJvcnMubGVuZ3RoID4gMSA/ICdzJyA6ICcnKSkpKTtcbiAgICB9XG4gICAgdmFyIGlzU2VydmVyRXJyb3IgPSBub2RlU3RhY2tGcmFtZXNfMS5pc05vZGVFcnJvcihhY3RpdmVFcnJvci5lcnJvcik7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE92ZXJsYXlfMS5PdmVybGF5LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZywgeyB0eXBlOiBcImVycm9yXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IFwibmV4dGpzX19jb250YWluZXJfZXJyb3JzX2xhYmVsXCIsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBcIm5leHRqc19fY29udGFpbmVyX2Vycm9yc19kZXNjXCIsIG9uQ2xvc2U6IG1pbmltaXplIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KERpYWxvZ18xLkRpYWxvZ0NvbnRlbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChEaWFsb2dfMS5EaWFsb2dIZWFkZXIsIHsgY2xhc3NOYW1lOiBcIm5leHRqcy1jb250YWluZXItZXJyb3JzLWhlYWRlclwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGVmdFJpZ2h0RGlhbG9nSGVhZGVyXzEuTGVmdFJpZ2h0RGlhbG9nSGVhZGVyLCB7IHByZXZpb3VzOiBhY3RpdmVJZHggPiAwID8gcHJldmlvdXMgOiBudWxsLCBuZXh0OiBhY3RpdmVJZHggPCByZWFkeUVycm9ycy5sZW5ndGggLSAxID8gbmV4dCA6IG51bGwsIGNsb3NlOiBtaW5pbWl6ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNtYWxsXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgYWN0aXZlSWR4ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgb2ZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnICcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgbnVsbCwgcmVhZHlFcnJvcnMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiB1bmhhbmRsZWQgZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkeUVycm9ycy5sZW5ndGggPCAyID8gJycgOiAncycpKSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImgxXCIsIHsgaWQ6IFwibmV4dGpzX19jb250YWluZXJfZXJyb3JzX2xhYmVsXCIgfSwgaXNTZXJ2ZXJFcnJvciA/ICdTZXJ2ZXIgRXJyb3InIDogJ1VuaGFuZGxlZCBSdW50aW1lIEVycm9yJyksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHsgaWQ6IFwibmV4dGpzX19jb250YWluZXJfZXJyb3JzX2Rlc2NcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRXJyb3IuZXJyb3IubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiOiBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVycm9yLmVycm9yLm1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlckVycm9yID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzbWFsbFwiLCBudWxsLCBcIlRoaXMgZXJyb3IgaGFwcGVuZWQgd2hpbGUgZ2VuZXJhdGluZyB0aGUgcGFnZS4gQW55IGNvbnNvbGUgbG9ncyB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgdGVybWluYWwgd2luZG93LlwiKSkpIDogKHVuZGVmaW5lZCkpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGlhbG9nXzEuRGlhbG9nQm9keSwgeyBjbGFzc05hbWU6IFwibmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keVwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUnVudGltZUVycm9yXzEuUnVudGltZUVycm9yLCB7IGtleTogYWN0aXZlRXJyb3IuaWQudG9TdHJpbmcoKSwgZXJyb3I6IGFjdGl2ZUVycm9yIH0pKSkpKSk7XG59O1xuZXhwb3J0cy5zdHlsZXMgPSBub29wX3RlbXBsYXRlXzEubm9vcCh0ZW1wbGF0ZU9iamVjdF8xIHx8ICh0ZW1wbGF0ZU9iamVjdF8xID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gaDEge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1iaWcpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTEpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwgPiBzcGFuIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBwIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZyk7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gZGl2ID4gc21hbGwge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgfVxcblxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWJvZHkgPiBoNTpub3QoOmZpcnN0LWNoaWxkKSB7XFxuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keSA+IGg1IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcblxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50IHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50OmhvdmVyIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycyA+IHN2ZyB7XFxuICAgIG1hcmdpbi1yaWdodDogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcblwiXSwgW1wiXFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gaDEge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1iaWcpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwLWhhbGYpKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwge1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTEpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgc21hbGwgPiBzcGFuIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gIH1cXG4gIC5uZXh0anMtY29udGFpbmVyLWVycm9ycy1oZWFkZXIgPiBwIHtcXG4gICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZyk7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYW5zaS1yZWQpO1xcbiAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtaGVhZGVyID4gZGl2ID4gc21hbGwge1xcbiAgICBtYXJnaW46IDA7XFxuICAgIG1hcmdpbi10b3A6IHZhcigtLXNpemUtZ2FwLWhhbGYpO1xcbiAgfVxcblxcbiAgLm5leHRqcy1jb250YWluZXItZXJyb3JzLWJvZHkgPiBoNTpub3QoOmZpcnN0LWNoaWxkKSB7XFxuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc2l6ZS1nYXAtZG91YmxlKSArIHZhcigtLXNpemUtZ2FwKSk7XFxuICB9XFxuICAubmV4dGpzLWNvbnRhaW5lci1lcnJvcnMtYm9keSA+IGg1IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcblxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50IHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4ycyBlYXNlO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMtcGFyZW50OmhvdmVyIHtcXG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjEpO1xcbiAgfVxcbiAgLm5leHRqcy10b2FzdC1lcnJvcnMge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XFxuICB9XFxuICAubmV4dGpzLXRvYXN0LWVycm9ycyA+IHN2ZyB7XFxuICAgIG1hcmdpbi1yaWdodDogdmFyKC0tc2l6ZS1nYXApO1xcbiAgfVxcblwiXSkpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIENvZGVGcmFtZV8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvQ29kZUZyYW1lXCIpO1xudmFyIG5vb3BfdGVtcGxhdGVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL25vb3AtdGVtcGxhdGVcIik7XG52YXIgc3RhY2tfZnJhbWVfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3N0YWNrLWZyYW1lXCIpO1xudmFyIENhbGxTdGFja0ZyYW1lID0gZnVuY3Rpb24gQ2FsbFN0YWNrRnJhbWUoX2EpIHtcbiAgICAvLyBUT0RPOiBhYmlsaXR5IHRvIGV4cGFuZCByZXNvbHZlZCBmcmFtZXNcbiAgICAvLyBUT0RPOiByZW5kZXIgZXJyb3Igb3IgZXh0ZXJuYWwgaW5kaWNhdG9yXG4gICAgdmFyIGZyYW1lID0gX2EuZnJhbWU7XG4gICAgdmFyIF9iO1xuICAgIHZhciBmID0gKF9iID0gZnJhbWUub3JpZ2luYWxTdGFja0ZyYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmcmFtZS5zb3VyY2VTdGFja0ZyYW1lO1xuICAgIHZhciBoYXNTb3VyY2UgPSBCb29sZWFuKGZyYW1lLm9yaWdpbmFsQ29kZUZyYW1lKTtcbiAgICB2YXIgb3BlbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWhhc1NvdXJjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGYpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoa2V5LCAoKF9hID0gZltrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJykudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5mZXRjaChcIi9fX25leHRqc19sYXVuY2gtZWRpdG9yP1wiICsgcGFyYW1zLnRvU3RyaW5nKCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiByZXBvcnQgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgfSwgW2hhc1NvdXJjZSwgZl0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZVwiOiB0cnVlIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJoNlwiLCB7IFwiZGF0YS1uZXh0anMtZnJhbWUtZXhwYW5kZWRcIjogQm9vbGVhbihmcmFtZS5leHBhbmRlZCkgfSwgZi5tZXRob2ROYW1lKSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiZGF0YS1oYXMtc291cmNlXCI6IGhhc1NvdXJjZSA/ICd0cnVlJyA6IHVuZGVmaW5lZCwgdGFiSW5kZXg6IGhhc1NvdXJjZSA/IDEwIDogdW5kZWZpbmVkLCByb2xlOiBoYXNTb3VyY2UgPyAnbGluaycgOiB1bmRlZmluZWQsIG9uQ2xpY2s6IG9wZW4sIHRpdGxlOiBoYXNTb3VyY2UgPyAnQ2xpY2sgdG8gb3BlbiBpbiB5b3VyIGVkaXRvcicgOiB1bmRlZmluZWQgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIHN0YWNrX2ZyYW1lXzEuZ2V0RnJhbWVTb3VyY2UoZikpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsIGZpbGw6IFwibm9uZVwiLCBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsIHN0cm9rZVdpZHRoOiBcIjJcIiwgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLCBzdHJva2VMaW5lam9pbjogXCJyb3VuZFwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0xOCAxM3Y2YTIgMiAwIDAgMS0yIDJINWEyIDIgMCAwIDEtMi0yVjhhMiAyIDAgMCAxIDItMmg2XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBvbHlsaW5lXCIsIHsgcG9pbnRzOiBcIjE1IDMgMjEgMyAyMSA5XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVcIiwgeyB4MTogXCIxMFwiLCB5MTogXCIxNFwiLCB4MjogXCIyMVwiLCB5MjogXCIzXCIgfSkpKSkpO1xufTtcbnZhciBSdW50aW1lRXJyb3IgPSBmdW5jdGlvbiBSdW50aW1lRXJyb3IoX2EpIHtcbiAgICB2YXIgZXJyb3IgPSBfYS5lcnJvcjtcbiAgICB2YXIgZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXJyb3IuZnJhbWVzLmZpbmRJbmRleChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5leHBhbmRlZCAmJlxuICAgICAgICAgICAgICAgIEJvb2xlYW4oZW50cnkub3JpZ2luYWxDb2RlRnJhbWUpICYmXG4gICAgICAgICAgICAgICAgQm9vbGVhbihlbnRyeS5vcmlnaW5hbFN0YWNrRnJhbWUpO1xuICAgICAgICB9KTtcbiAgICB9LCBbZXJyb3IuZnJhbWVzXSk7XG4gICAgdmFyIGZpcnN0RnJhbWUgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gZXJyb3IuZnJhbWVzW2ZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIH0sIFtlcnJvci5mcmFtZXMsIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhdKTtcbiAgICB2YXIgYWxsTGVhZGluZ0ZyYW1lcyA9IFJlYWN0LnVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCA8IDBcbiAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgIDogZXJyb3IuZnJhbWVzLnNsaWNlKDAsIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXgpO1xuICAgIH0sIFtlcnJvci5mcmFtZXMsIGZpcnN0Rmlyc3RQYXJ0eUZyYW1lSW5kZXhdKTtcbiAgICB2YXIgX2IgPSBfX3JlYWQoUmVhY3QudXNlU3RhdGUoZmlyc3RGcmFtZSA9PSBudWxsKSwgMiksIGFsbCA9IF9iWzBdLCBzZXRBbGwgPSBfYlsxXTtcbiAgICB2YXIgdG9nZ2xlQWxsID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRBbGwoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICF2OyB9KTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGxlYWRpbmdGcmFtZXMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFsbExlYWRpbmdGcmFtZXMuZmlsdGVyKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLmV4cGFuZGVkIHx8IGFsbDsgfSk7IH0sIFthbGwsIGFsbExlYWRpbmdGcmFtZXNdKTtcbiAgICB2YXIgYWxsQ2FsbFN0YWNrRnJhbWVzID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvci5mcmFtZXMuc2xpY2UoZmlyc3RGaXJzdFBhcnR5RnJhbWVJbmRleCArIDEpOyB9LCBbZXJyb3IuZnJhbWVzLCBmaXJzdEZpcnN0UGFydHlGcmFtZUluZGV4XSk7XG4gICAgdmFyIHZpc2libGVDYWxsU3RhY2tGcmFtZXMgPSBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFsbENhbGxTdGFja0ZyYW1lcy5maWx0ZXIoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYuZXhwYW5kZWQgfHwgYWxsOyB9KTsgfSwgW2FsbCwgYWxsQ2FsbFN0YWNrRnJhbWVzXSk7XG4gICAgdmFyIGNhblNob3dNb3JlID0gUmVhY3QudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoYWxsQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCAhPT0gdmlzaWJsZUNhbGxTdGFja0ZyYW1lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIChhbGwgJiYgZmlyc3RGcmFtZSAhPSBudWxsKSk7XG4gICAgfSwgW1xuICAgICAgICBhbGwsXG4gICAgICAgIGFsbENhbGxTdGFja0ZyYW1lcy5sZW5ndGgsXG4gICAgICAgIGZpcnN0RnJhbWUsXG4gICAgICAgIHZpc2libGVDYWxsU3RhY2tGcmFtZXMubGVuZ3RoLFxuICAgIF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgZmlyc3RGcmFtZSA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg1XCIsIG51bGwsIFwiU291cmNlXCIpLFxuICAgICAgICAgICAgbGVhZGluZ0ZyYW1lcy5tYXAoZnVuY3Rpb24gKGZyYW1lLCBpbmRleCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbFN0YWNrRnJhbWUsIHsga2V5OiBcImxlYWRpbmctZnJhbWUtXCIgKyBpbmRleCArIFwiLVwiICsgYWxsLCBmcmFtZTogZnJhbWUgfSkpOyB9KSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29kZUZyYW1lXzEuQ29kZUZyYW1lLCB7IHN0YWNrRnJhbWU6IGZpcnN0RnJhbWUub3JpZ2luYWxTdGFja0ZyYW1lLCBjb2RlRnJhbWU6IGZpcnN0RnJhbWUub3JpZ2luYWxDb2RlRnJhbWUgfSkpKSA6ICh1bmRlZmluZWQpLFxuICAgICAgICB2aXNpYmxlQ2FsbFN0YWNrRnJhbWVzLmxlbmd0aCA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImg1XCIsIG51bGwsIFwiQ2FsbCBTdGFja1wiKSxcbiAgICAgICAgICAgIHZpc2libGVDYWxsU3RhY2tGcmFtZXMubWFwKGZ1bmN0aW9uIChmcmFtZSwgaW5kZXgpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxTdGFja0ZyYW1lLCB7IGtleTogXCJjYWxsLXN0YWNrLVwiICsgaW5kZXggKyBcIi1cIiArIGFsbCwgZnJhbWU6IGZyYW1lIH0pKTsgfSkpKSA6ICh1bmRlZmluZWQpLFxuICAgICAgICBjYW5TaG93TW9yZSA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHRhYkluZGV4OiAxMCwgXCJkYXRhLW5leHRqcy1kYXRhLXJ1bnRpbWUtZXJyb3ItY29sbGFwc2VkLWFjdGlvblwiOiB0cnVlLCB0eXBlOiBcImJ1dHRvblwiLCBvbkNsaWNrOiB0b2dnbGVBbGwgfSxcbiAgICAgICAgICAgICAgICBhbGwgPyAnSGlkZScgOiAnU2hvdycsXG4gICAgICAgICAgICAgICAgXCIgY29sbGFwc2VkIGZyYW1lc1wiKSkpIDogKHVuZGVmaW5lZCkpKTtcbn07XG5leHBvcnRzLlJ1bnRpbWVFcnJvciA9IFJ1bnRpbWVFcnJvcjtcbmV4cG9ydHMuc3R5bGVzID0gbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgYnV0dG9uW2RhdGEtbmV4dGpzLWRhdGEtcnVudGltZS1lcnJvci1jb2xsYXBzZWQtYWN0aW9uXSB7XFxuICAgIGJhY2tncm91bmQ6IG5vbmU7XFxuICAgIGJvcmRlcjogbm9uZTtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgZm9udC1zaXplOiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tc2l6ZS1mb250LWJpZ2dlcik7XFxuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnRzLTMpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdOm5vdCg6bGFzdC1jaGlsZCkge1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcC1kb3VibGUpO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDYge1xcbiAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXN0YWNrLW1vbm9zcGFjZSk7XFxuICAgIGNvbG9yOiAjMjIyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gaDZbZGF0YS1uZXh0anMtZnJhbWUtZXhwYW5kZWQ9J2ZhbHNlJ10ge1xcbiAgICBjb2xvcjogIzY2NjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdiB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHBhZGRpbmctbGVmdDogY2FsYyh2YXIoLS1zaXplLWdhcCkgKyB2YXIoLS1zaXplLWdhcC1oYWxmKSk7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgY29sb3I6ICM5OTk7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYgPiBzdmcge1xcbiAgICB3aWR0aDogYXV0bztcXG4gICAgaGVpZ2h0OiB2YXIoLS1zaXplLWZvbnQtc21hbGwpO1xcbiAgICBtYXJnaW4tbGVmdDogdmFyKC0tc2l6ZS1nYXApO1xcblxcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcblxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV0ge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXTpob3ZlciB7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdID4gc3ZnIHtcXG4gICAgZGlzcGxheTogdW5zZXQ7XFxuICB9XFxuXCJdLCBbXCJcXG4gIGJ1dHRvbltkYXRhLW5leHRqcy1kYXRhLXJ1bnRpbWUtZXJyb3ItY29sbGFwc2VkLWFjdGlvbl0ge1xcbiAgICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgICBib3JkZXI6IG5vbmU7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGZvbnQtc2l6ZTogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXNpemUtZm9udC1iaWdnZXIpO1xcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYWNjZW50cy0zKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXTpub3QoOmxhc3QtY2hpbGQpIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXAtZG91YmxlKTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGg2IHtcXG4gICAgbWFyZ2luLXRvcDogMDtcXG4gICAgbWFyZ2luLWJvdHRvbTogdmFyKC0tc2l6ZS1nYXApO1xcbiAgICBmb250LWZhbWlseTogdmFyKC0tZm9udC1zdGFjay1tb25vc3BhY2UpO1xcbiAgICBjb2xvcjogIzIyMjtcXG4gIH1cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGg2W2RhdGEtbmV4dGpzLWZyYW1lLWV4cGFuZGVkPSdmYWxzZSddIHtcXG4gICAgY29sb3I6ICM2NjY7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXYge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nLWxlZnQ6IGNhbGModmFyKC0tc2l6ZS1nYXApICsgdmFyKC0tc2l6ZS1nYXAtaGFsZikpO1xcbiAgICBmb250LXNpemU6IHZhcigtLXNpemUtZm9udC1zbWFsbCk7XFxuICAgIGNvbG9yOiAjOTk5O1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2ID4gc3ZnIHtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIGhlaWdodDogdmFyKC0tc2l6ZS1mb250LXNtYWxsKTtcXG4gICAgbWFyZ2luLWxlZnQ6IHZhcigtLXNpemUtZ2FwKTtcXG5cXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG5cXG4gIFtkYXRhLW5leHRqcy1jYWxsLXN0YWNrLWZyYW1lXSA+IGRpdltkYXRhLWhhcy1zb3VyY2VdIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgfVxcbiAgW2RhdGEtbmV4dGpzLWNhbGwtc3RhY2stZnJhbWVdID4gZGl2W2RhdGEtaGFzLXNvdXJjZV06aG92ZXIge1xcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICB9XFxuICBbZGF0YS1uZXh0anMtY2FsbC1zdGFjay1mcmFtZV0gPiBkaXZbZGF0YS1oYXMtc291cmNlXSA+IHN2ZyB7XFxuICAgIGRpc3BsYXk6IHVuc2V0O1xcbiAgfVxcblwiXSkpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBzdGFja3RyYWNlX3BhcnNlcl8xID0gcmVxdWlyZShcInN0YWNrdHJhY2UtcGFyc2VyXCIpO1xuZnVuY3Rpb24gZ2V0RmlsZXN5c3RlbUZyYW1lKGZyYW1lKSB7XG4gICAgdmFyIGYgPSBfX2Fzc2lnbih7fSwgZnJhbWUpO1xuICAgIGlmICh0eXBlb2YgZi5maWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIFBvc2l4OlxuICAgICAgICBmLmZpbGUuc3RhcnRzV2l0aCgnLycpIHx8XG4gICAgICAgICAgICAvLyBXaW4zMjpcbiAgICAgICAgICAgIC9eW2Etel06XFxcXC9pLnRlc3QoZi5maWxlKSB8fFxuICAgICAgICAgICAgLy8gV2luMzIgVU5DOlxuICAgICAgICAgICAgZi5maWxlLnN0YXJ0c1dpdGgoJ1xcXFxcXFxcJykpIHtcbiAgICAgICAgICAgIGYuZmlsZSA9IFwiZmlsZTovL1wiICsgZi5maWxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmO1xufVxuZXhwb3J0cy5nZXRGaWxlc3lzdGVtRnJhbWUgPSBnZXRGaWxlc3lzdGVtRnJhbWU7XG52YXIgc3ltYm9sTm9kZUVycm9yID0gU3ltYm9sKCdOZXh0anNOb2RlRXJyb3InKTtcbmZ1bmN0aW9uIGlzTm9kZUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHN5bWJvbE5vZGVFcnJvciBpbiBlcnJvcjtcbn1cbmV4cG9ydHMuaXNOb2RlRXJyb3IgPSBpc05vZGVFcnJvcjtcbmZ1bmN0aW9uIGdldE5vZGVFcnJvcihlcnJvcikge1xuICAgIHZhciBuO1xuICAgIHRyeSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbiA9IGU7XG4gICAgfVxuICAgIG4ubmFtZSA9IGVycm9yLm5hbWU7XG4gICAgdHJ5IHtcbiAgICAgICAgbi5zdGFjayA9IHN0YWNrdHJhY2VfcGFyc2VyXzEucGFyc2UoZXJyb3Iuc3RhY2spXG4gICAgICAgICAgICAubWFwKGdldEZpbGVzeXN0ZW1GcmFtZSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIiAgICBhdCBcIiArIGYubWV0aG9kTmFtZTtcbiAgICAgICAgICAgIGlmIChmLmZpbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9jID0gZi5maWxlO1xuICAgICAgICAgICAgICAgIGlmIChmLmxpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jICs9IFwiOlwiICsgZi5saW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZi5jb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYyArPSBcIjpcIiArIGYuY29sdW1uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0ciArPSBcIiAoXCIgKyBsb2MgKyBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICBuLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBzeW1ib2xOb2RlRXJyb3IsIHtcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiBuO1xufVxuZXhwb3J0cy5nZXROb2RlRXJyb3IgPSBnZXROb2RlRXJyb3I7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5mdW5jdGlvbiBub29wKHN0cmluZ3MpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGtleXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBsYXN0SW5kZXggPSBzdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIChzdHJpbmdzLnNsaWNlKDAsIGxhc3RJbmRleCkucmVkdWNlKGZ1bmN0aW9uIChwLCBzLCBpKSB7IHJldHVybiBwICsgcyArIGtleXNbaV07IH0sICcnKSArXG4gICAgICAgIHN0cmluZ3NbbGFzdEluZGV4XSk7XG59XG5leHBvcnRzLm5vb3AgPSBub29wO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIHN0YWNrdHJhY2VfcGFyc2VyXzEgPSByZXF1aXJlKFwic3RhY2t0cmFjZS1wYXJzZXJcIik7XG52YXIgcmVnZXhOZXh0U3RhdGljID0gL1xcL19uZXh0KFxcL3N0YXRpY1xcLy4rKS9nO1xuZnVuY3Rpb24gcGFyc2VTdGFjayhzdGFjaykge1xuICAgIHZhciBmcmFtZXMgPSBzdGFja3RyYWNlX3BhcnNlcl8xLnBhcnNlKHN0YWNrKTtcbiAgICByZXR1cm4gZnJhbWVzLm1hcChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBuZXcgVVJMKGZyYW1lLmZpbGUpO1xuICAgICAgICAgICAgdmFyIHJlcyA9IHJlZ2V4TmV4dFN0YXRpYy5leGVjKHVybC5wYXRobmFtZSk7XG4gICAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3REaXIgPSAoX2IgPSAoX2EgPSBwcm9jZXNzLmVudi5fX05FWFRfRElTVF9ESVIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKC9cXFxcL2csICcvJykpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0RGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLmZpbGUgPSAnZmlsZTovLycgKyBkaXN0RGlyLmNvbmNhdChyZXMucG9wKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2MpIHsgfVxuICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgfSk7XG59XG5leHBvcnRzLnBhcnNlU3RhY2sgPSBwYXJzZVN0YWNrO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmZ1bmN0aW9uIGdldE9yaWdpbmFsU3RhY2tGcmFtZXMoZnJhbWVzKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGZyYW1lcy5tYXAoZnVuY3Rpb24gKGZyYW1lKSB7IHJldHVybiBnZXRPcmlnaW5hbFN0YWNrRnJhbWUoZnJhbWUpOyB9KSk7XG59XG5leHBvcnRzLmdldE9yaWdpbmFsU3RhY2tGcmFtZXMgPSBnZXRPcmlnaW5hbFN0YWNrRnJhbWVzO1xuZnVuY3Rpb24gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lKHNvdXJjZSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgZnVuY3Rpb24gX2dldE9yaWdpbmFsU3RhY2tGcmFtZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcywga2V5LCBjb250cm9sbGVyLCB0bSwgcmVzLCBfYywgX2QsIF9lLCBib2R5O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2YubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChrZXksICgoX2EgPSBzb3VyY2Vba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjb250cm9sbGVyLmFib3J0KCk7IH0sIDMwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2VsZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmV0Y2goXCIvX19uZXh0anNfb3JpZ2luYWwtc3RhY2stZnJhbWU/XCIgKyBwYXJhbXMudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlbXCJmaW5hbGx5XCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCFyZXMub2sgfHwgcmVzLnN0YXR1cyA9PT0gMjA0KSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBfZCA9IChfYyA9IFByb21pc2UpLnJlamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9lID0gRXJyb3IuYmluZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlcy50ZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfZC5hcHBseShfYywgW25ldyAoX2UuYXBwbHkoRXJyb3IsIFt2b2lkIDAsIF9mLnNlbnQoKV0pKSgpXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbNCAvKnlpZWxkKi8sIHJlcy5qc29uKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gX2Yuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVybmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQ6ICgoX2IgPSBib2R5Lm9yaWdpbmFsU3RhY2tGcmFtZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZpbGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhYm9keS5vcmlnaW5hbFN0YWNrRnJhbWUuZmlsZS5pbmNsdWRlcygnbm9kZV9tb2R1bGVzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVN0YWNrRnJhbWU6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFja0ZyYW1lOiBib2R5Lm9yaWdpbmFsU3RhY2tGcmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxDb2RlRnJhbWU6IGJvZHkub3JpZ2luYWxDb2RlRnJhbWUgfHwgbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCEoKChfYSA9IHNvdXJjZS5maWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRzV2l0aCgnd2VicGFjay1pbnRlcm5hbDonKSkgfHwgKChfYiA9IHNvdXJjZS5maWxlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhcnRzV2l0aCgnZmlsZTonKSkpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgcmVhc29uOiBudWxsLFxuICAgICAgICAgICAgZXh0ZXJuYWw6IHRydWUsXG4gICAgICAgICAgICBleHBhbmRlZDogZmFsc2UsXG4gICAgICAgICAgICBzb3VyY2VTdGFja0ZyYW1lOiBzb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbFN0YWNrRnJhbWU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbENvZGVGcmFtZTogbnVsbFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF9nZXRPcmlnaW5hbFN0YWNrRnJhbWUoKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBlcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgIHJlYXNvbjogKF9iID0gKF9hID0gZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLm1lc3NhZ2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnVW5rbm93biBFcnJvcicsXG4gICAgICAgICAgICBleHRlcm5hbDogZmFsc2UsXG4gICAgICAgICAgICBleHBhbmRlZDogZmFsc2UsXG4gICAgICAgICAgICBzb3VyY2VTdGFja0ZyYW1lOiBzb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbFN0YWNrRnJhbWU6IG51bGwsXG4gICAgICAgICAgICBvcmlnaW5hbENvZGVGcmFtZTogbnVsbFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0T3JpZ2luYWxTdGFja0ZyYW1lID0gZ2V0T3JpZ2luYWxTdGFja0ZyYW1lO1xuZnVuY3Rpb24gZ2V0RnJhbWVTb3VyY2UoZnJhbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB1ID0gbmV3IFVSTChmcmFtZS5maWxlKTtcbiAgICAgICAgLy8gU3RyaXAgdGhlIG9yaWdpbiBmb3Igc2FtZS1vcmlnaW4gc2NyaXB0cy5cbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgKChfYSA9IGdsb2JhbFRoaXMubG9jYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcmlnaW4pICE9PSB1Lm9yaWdpbikge1xuICAgICAgICAgICAgLy8gVVJMcyBjYW4gYmUgdmFsaWQgd2l0aG91dCBhbiBgb3JpZ2luYCwgc28gbG9uZyBhcyB0aGV5IGhhdmUgYVxuICAgICAgICAgICAgLy8gYHByb3RvY29sYC4gSG93ZXZlciwgYG9yaWdpbmAgaXMgcHJlZmVycmVkLlxuICAgICAgICAgICAgaWYgKHUub3JpZ2luID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gdS5wcm90b2NvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciArPSB1Lm9yaWdpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJpcCBxdWVyeSBzdHJpbmcgaW5mb3JtYXRpb24gYXMgaXQncyB0eXBpY2FsbHkgdG9vIHZlcmJvc2UgdG8gYmVcbiAgICAgICAgLy8gbWVhbmluZ2Z1bC5cbiAgICAgICAgc3RyICs9IHUucGF0aG5hbWU7XG4gICAgICAgIHN0ciArPSAnICc7XG4gICAgfVxuICAgIGNhdGNoIChfYikge1xuICAgICAgICBzdHIgKz0gKGZyYW1lLmZpbGUgfHwgJyh1bmtub3duKScpICsgJyAnO1xuICAgIH1cbiAgICBpZiAoZnJhbWUubGluZU51bWJlciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChmcmFtZS5jb2x1bW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9IFwiKFwiICsgZnJhbWUubGluZU51bWJlciArIFwiOlwiICsgZnJhbWUuY29sdW1uICsgXCIpIFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyICs9IFwiKFwiICsgZnJhbWUubGluZU51bWJlciArIFwiKSBcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyLnNsaWNlKDAsIC0xKTtcbn1cbmV4cG9ydHMuZ2V0RnJhbWVTb3VyY2UgPSBnZXRGcmFtZVNvdXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xuZnVuY3Rpb24gdXNlT25DbGlja091dHNpZGUoZWwsIGhhbmRsZXIpIHtcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIGNsaWNraW5nIHJlZidzIGVsZW1lbnQgb3IgZGVzY2VuZGVudCBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKCFlbCB8fCBlbC5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVyKGUpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcm9vdCA9IGVsLmdldFJvb3ROb2RlKCk7XG4gICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbGlzdGVuZXIpO1xuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICB9LCBbaGFuZGxlciwgZWxdKTtcbn1cbmV4cG9ydHMudXNlT25DbGlja091dHNpZGUgPSB1c2VPbkNsaWNrT3V0c2lkZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gKHRoaXMgJiYgdGhpcy5fX21ha2VUZW1wbGF0ZU9iamVjdCkgfHwgZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgICByZXR1cm4gY29va2VkO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZnVuY3Rpb24gQmFzZSgpIHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiB7XG4gICAgICAgICAgICBfX2h0bWw6IG5vb3BfdGVtcGxhdGVfMS5ub29wKHRlbXBsYXRlT2JqZWN0XzEgfHwgKHRlbXBsYXRlT2JqZWN0XzEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gICAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtaGFsZjogMC4yNXJlbTsgLyogNHB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWdhcDogMC41cmVtOyAvKiA4cHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZ2FwLWRvdWJsZTogMXJlbTsgLyogMTZweCAqL1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtcXVhZDogMnJlbTsgLyogMzJweCAqL1xcblxcbiAgICAgICAgICAgIC0tc2l6ZS1mb250LXNtYWxsOiAwLjg3NXJlbTsgLyogMTRweCAqL1xcbiAgICAgICAgICAgIC0tc2l6ZS1mb250OiAxcmVtOyAvKiAxNnB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtYmlnOiAxLjI1cmVtOyAvKiAyMHB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtYmlnZ2VyOiAxLjVyZW07IC8qIDI0cHggKi9cXG5cXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMTogIzgwODA4MDtcXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMjogIzIyMjIyMjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMzogIzQwNDA0MDtcXG5cXG4gICAgICAgICAgICAtLWZvbnQtc3RhY2stbW9ub3NwYWNlOiAnU0ZNb25vLVJlZ3VsYXInLCBDb25zb2xhcyxcXG4gICAgICAgICAgICAgICdMaWJlcmF0aW9uIE1vbm8nLCBNZW5sbywgQ291cmllciwgbW9ub3NwYWNlO1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1zZWxlY3Rpb246IHJnYmEoOTUsIDEyNiwgMTUxLCAwLjQ4KTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmc6ICMxMTExMTE7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWZnOiAjY2NjY2NjO1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS13aGl0ZTogIzc3Nzc3NztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmxhY2s6ICMxNDE0MTQ7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJsdWU6ICMwMGFhZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWN5YW46ICM4OGRkZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWdyZWVuOiAjOThlYzY1O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1tYWdlbnRhOiAjYWE4OGZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1yZWQ6ICNmZjU1NTU7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXllbGxvdzogI2ZmY2MzMztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlOiAjZmZmZmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtYmxhY2s6ICM3Nzc3Nzc7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibHVlOiAjMzNiYmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtY3lhbjogI2JiZWNmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWdyZWVuOiAjYjZmMjkyO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtbWFnZW50YTogI2NlYmJmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXJlZDogI2ZmODg4ODtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXllbGxvdzogI2ZmZDk2NjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICAubW9ubyB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBoMSxcXG4gICAgICAgICAgaDIsXFxuICAgICAgICAgIGgzLFxcbiAgICAgICAgICBoNCxcXG4gICAgICAgICAgaDUsXFxuICAgICAgICAgIGg2IHtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDIuNXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoMiB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAycmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGgzIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDEuNzVyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDQge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGg1IHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDEuMjVyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJdLCBbXCJcXG4gICAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtaGFsZjogMC4yNXJlbTsgLyogNHB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWdhcDogMC41cmVtOyAvKiA4cHggKi9cXG4gICAgICAgICAgICAtLXNpemUtZ2FwLWRvdWJsZTogMXJlbTsgLyogMTZweCAqL1xcbiAgICAgICAgICAgIC0tc2l6ZS1nYXAtcXVhZDogMnJlbTsgLyogMzJweCAqL1xcblxcbiAgICAgICAgICAgIC0tc2l6ZS1mb250LXNtYWxsOiAwLjg3NXJlbTsgLyogMTRweCAqL1xcbiAgICAgICAgICAgIC0tc2l6ZS1mb250OiAxcmVtOyAvKiAxNnB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtYmlnOiAxLjI1cmVtOyAvKiAyMHB4ICovXFxuICAgICAgICAgICAgLS1zaXplLWZvbnQtYmlnZ2VyOiAxLjVyZW07IC8qIDI0cHggKi9cXG5cXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMTogIzgwODA4MDtcXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMjogIzIyMjIyMjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFjY2VudHMtMzogIzQwNDA0MDtcXG5cXG4gICAgICAgICAgICAtLWZvbnQtc3RhY2stbW9ub3NwYWNlOiAnU0ZNb25vLVJlZ3VsYXInLCBDb25zb2xhcyxcXG4gICAgICAgICAgICAgICdMaWJlcmF0aW9uIE1vbm8nLCBNZW5sbywgQ291cmllciwgbW9ub3NwYWNlO1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1zZWxlY3Rpb246IHJnYmEoOTUsIDEyNiwgMTUxLCAwLjQ4KTtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmc6ICMxMTExMTE7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWZnOiAjY2NjY2NjO1xcblxcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS13aGl0ZTogIzc3Nzc3NztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYmxhY2s6ICMxNDE0MTQ7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJsdWU6ICMwMGFhZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWN5YW46ICM4OGRkZmY7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWdyZWVuOiAjOThlYzY1O1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1tYWdlbnRhOiAjYWE4OGZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1yZWQ6ICNmZjU1NTU7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLXllbGxvdzogI2ZmY2MzMztcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXdoaXRlOiAjZmZmZmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtYmxhY2s6ICM3Nzc3Nzc7XFxuICAgICAgICAgICAgLS1jb2xvci1hbnNpLWJyaWdodC1ibHVlOiAjMzNiYmZmO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtY3lhbjogI2JiZWNmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LWdyZWVuOiAjYjZmMjkyO1xcbiAgICAgICAgICAgIC0tY29sb3ItYW5zaS1icmlnaHQtbWFnZW50YTogI2NlYmJmZjtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXJlZDogI2ZmODg4ODtcXG4gICAgICAgICAgICAtLWNvbG9yLWFuc2ktYnJpZ2h0LXllbGxvdzogI2ZmZDk2NjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICAubW9ubyB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtc3RhY2stbW9ub3NwYWNlKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBoMSxcXG4gICAgICAgICAgaDIsXFxuICAgICAgICAgIGgzLFxcbiAgICAgICAgICBoNCxcXG4gICAgICAgICAgaDUsXFxuICAgICAgICAgIGg2IHtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiB2YXIoLS1zaXplLWdhcCk7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDIuNXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBoMiB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAycmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGgzIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDEuNzVyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDQge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGg1IHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDEuMjVyZW07XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMXJlbTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJdKSkpXG4gICAgICAgIH0gfSkpO1xufVxuZXhwb3J0cy5CYXNlID0gQmFzZTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3QgPSAodGhpcyAmJiB0aGlzLl9fbWFrZVRlbXBsYXRlT2JqZWN0KSB8fCBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxuICAgIHJldHVybiBjb29rZWQ7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIHN0eWxlc18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvQ29kZUZyYW1lL3N0eWxlc1wiKTtcbnZhciBEaWFsb2dfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0RpYWxvZ1wiKTtcbnZhciBzdHlsZXNfMiA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL0xlZnRSaWdodERpYWxvZ0hlYWRlci9zdHlsZXNcIik7XG52YXIgc3R5bGVzXzMgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9PdmVybGF5L3N0eWxlc1wiKTtcbnZhciBzdHlsZXNfNCA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL1Rlcm1pbmFsL3N0eWxlc1wiKTtcbnZhciBUb2FzdF8xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvVG9hc3RcIik7XG52YXIgQnVpbGRFcnJvcl8xID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9CdWlsZEVycm9yXCIpO1xudmFyIEVycm9yc18xID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9FcnJvcnNcIik7XG52YXIgUnVudGltZUVycm9yXzEgPSByZXF1aXJlKFwiLi4vY29udGFpbmVyL1J1bnRpbWVFcnJvclwiKTtcbnZhciBub29wX3RlbXBsYXRlXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9ub29wLXRlbXBsYXRlXCIpO1xuZnVuY3Rpb24gQ29tcG9uZW50U3R5bGVzKCkge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIHsgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgIF9faHRtbDogbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcblxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgXCJdLCBbXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG5cXG4gICAgICAgICAgXCIsIFwiXFxuICAgICAgICAgIFwiLCBcIlxcbiAgICAgICAgICBcIiwgXCJcXG4gICAgICAgIFwiXSkpLCBzdHlsZXNfMy5zdHlsZXMsIFRvYXN0XzEuc3R5bGVzLCBEaWFsb2dfMS5zdHlsZXMsIHN0eWxlc18yLnN0eWxlcywgc3R5bGVzXzEuc3R5bGVzLCBzdHlsZXNfNC5zdHlsZXMsIEJ1aWxkRXJyb3JfMS5zdHlsZXMsIEVycm9yc18xLnN0eWxlcywgUnVudGltZUVycm9yXzEuc3R5bGVzKVxuICAgICAgICB9IH0pKTtcbn1cbmV4cG9ydHMuQ29tcG9uZW50U3R5bGVzID0gQ29tcG9uZW50U3R5bGVzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdCA9ICh0aGlzICYmIHRoaXMuX19tYWtlVGVtcGxhdGVPYmplY3QpIHx8IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XG4gICAgcmV0dXJuIGNvb2tlZDtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgbm9vcF90ZW1wbGF0ZV8xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbm9vcC10ZW1wbGF0ZVwiKTtcbmZ1bmN0aW9uIENzc1Jlc2V0KCkge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIHsgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgIF9faHRtbDogbm9vcF90ZW1wbGF0ZV8xLm5vb3AodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgYWxsOiBpbml0aWFsO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC8qIVxcbiAgICAgICAgICAgKiBCb290c3RyYXAgUmVib290IHY0LjQuMSAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tLylcXG4gICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEtMjAxOSBUaGUgQm9vdHN0cmFwIEF1dGhvcnNcXG4gICAgICAgICAgICogQ29weXJpZ2h0IDIwMTEtMjAxOSBUd2l0dGVyLCBJbmMuXFxuICAgICAgICAgICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICAgICAgICAgICAqIEZvcmtlZCBmcm9tIE5vcm1hbGl6ZS5jc3MsIGxpY2Vuc2VkIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcy9ibG9iL21hc3Rlci9MSUNFTlNFLm1kKVxcbiAgICAgICAgICAgKi9cXG4gICAgICAgICAgKixcXG4gICAgICAgICAgKjo6YmVmb3JlLFxcbiAgICAgICAgICAqOjphZnRlciB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICA6aG9zdCB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuMTU7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xcbiAgICAgICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhcnRpY2xlLFxcbiAgICAgICAgICBhc2lkZSxcXG4gICAgICAgICAgZmlnY2FwdGlvbixcXG4gICAgICAgICAgZmlndXJlLFxcbiAgICAgICAgICBmb290ZXIsXFxuICAgICAgICAgIGhlYWRlcixcXG4gICAgICAgICAgaGdyb3VwLFxcbiAgICAgICAgICBtYWluLFxcbiAgICAgICAgICBuYXYsXFxuICAgICAgICAgIHNlY3Rpb24ge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLFxcbiAgICAgICAgICAgICAgJ0hlbHZldGljYSBOZXVlJywgQXJpYWwsICdOb3RvIFNhbnMnLCBzYW5zLXNlcmlmLFxcbiAgICAgICAgICAgICAgJ0FwcGxlIENvbG9yIEVtb2ppJywgJ1NlZ29lIFVJIEVtb2ppJywgJ1NlZ29lIFVJIFN5bWJvbCcsXFxuICAgICAgICAgICAgICAnTm90byBDb2xvciBFbW9qaSc7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxcmVtO1xcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gICAgICAgICAgICBjb2xvcjogIzIxMjUyOTtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3RhYmluZGV4PSctMSddOmZvY3VzOm5vdCg6Zm9jdXMtdmlzaWJsZSkge1xcbiAgICAgICAgICAgIG91dGxpbmU6IDAgIWltcG9ydGFudDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBociB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogY29udGVudC1ib3g7XFxuICAgICAgICAgICAgaGVpZ2h0OiAwO1xcbiAgICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGgxLFxcbiAgICAgICAgICBoMixcXG4gICAgICAgICAgaDMsXFxuICAgICAgICAgIGg0LFxcbiAgICAgICAgICBoNSxcXG4gICAgICAgICAgaDYge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHAge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhYmJyW3RpdGxlXSxcXG4gICAgICAgICAgYWJicltkYXRhLW9yaWdpbmFsLXRpdGxlXSB7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgICAgICAgICAgIGN1cnNvcjogaGVscDtcXG4gICAgICAgICAgICBib3JkZXItYm90dG9tOiAwO1xcbiAgICAgICAgICAgIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOiBub25lO1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbi1za2lwLWluazogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhZGRyZXNzIHtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgICAgICAgICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvbCxcXG4gICAgICAgICAgdWwsXFxuICAgICAgICAgIGRsIHtcXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgb2wgb2wsXFxuICAgICAgICAgIHVsIHVsLFxcbiAgICAgICAgICBvbCB1bCxcXG4gICAgICAgICAgdWwgb2wge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZHQge1xcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZGQge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gICAgICAgICAgICBtYXJnaW4tbGVmdDogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBibG9ja3F1b3RlIHtcXG4gICAgICAgICAgICBtYXJnaW46IDAgMCAxcmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGIsXFxuICAgICAgICAgIHN0cm9uZyB7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzbWFsbCB7XFxuICAgICAgICAgICAgZm9udC1zaXplOiA4MCU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ViLFxcbiAgICAgICAgICBzdXAge1xcbiAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDc1JTtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMDtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ViIHtcXG4gICAgICAgICAgICBib3R0b206IC0wLjI1ZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3VwIHtcXG4gICAgICAgICAgICB0b3A6IC0wLjVlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhIHtcXG4gICAgICAgICAgICBjb2xvcjogIzAwN2JmZjtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpob3ZlciB7XFxuICAgICAgICAgICAgY29sb3I6ICMwMDU2YjM7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpub3QoW2hyZWZdKSB7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGE6bm90KFtocmVmXSk6aG92ZXIge1xcbiAgICAgICAgICAgIGNvbG9yOiBpbmhlcml0O1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcmUsXFxuICAgICAgICAgIGNvZGUsXFxuICAgICAgICAgIGtiZCxcXG4gICAgICAgICAgc2FtcCB7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcyxcXG4gICAgICAgICAgICAgICdMaWJlcmF0aW9uIE1vbm8nLCAnQ291cmllciBOZXcnLCBtb25vc3BhY2U7XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcHJlIHtcXG4gICAgICAgICAgICBtYXJnaW4tdG9wOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZmlndXJlIHtcXG4gICAgICAgICAgICBtYXJnaW46IDAgMCAxcmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGltZyB7XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICAgICAgICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc3ZnIHtcXG4gICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGFibGUge1xcbiAgICAgICAgICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY2FwdGlvbiB7XFxuICAgICAgICAgICAgcGFkZGluZy10b3A6IDAuNzVyZW07XFxuICAgICAgICAgICAgcGFkZGluZy1ib3R0b206IDAuNzVyZW07XFxuICAgICAgICAgICAgY29sb3I6ICM2Yzc1N2Q7XFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgICAgICAgICBjYXB0aW9uLXNpZGU6IGJvdHRvbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0aCB7XFxuICAgICAgICAgICAgdGV4dC1hbGlnbjogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsYWJlbCB7XFxuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24ge1xcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnV0dG9uOmZvY3VzIHtcXG4gICAgICAgICAgICBvdXRsaW5lOiAxcHggZG90dGVkO1xcbiAgICAgICAgICAgIG91dGxpbmU6IDVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnB1dCxcXG4gICAgICAgICAgYnV0dG9uLFxcbiAgICAgICAgICBzZWxlY3QsXFxuICAgICAgICAgIG9wdGdyb3VwLFxcbiAgICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICAgIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIGlucHV0IHtcXG4gICAgICAgICAgICBvdmVyZmxvdzogdmlzaWJsZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIHNlbGVjdCB7XFxuICAgICAgICAgICAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgICB3b3JkLXdyYXA6IG5vcm1hbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXSxcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J10sXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXSB7XFxuICAgICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYnV0dG9uOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgICBbdHlwZT0nYnV0dG9uJ106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdyZXNldCddOm5vdCg6ZGlzYWJsZWQpLFxcbiAgICAgICAgICBbdHlwZT0nc3VibWl0J106bm90KDpkaXNhYmxlZCkge1xcbiAgICAgICAgICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J106Oi1tb3otZm9jdXMtaW5uZXIsXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICAgICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgICAgICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW5wdXRbdHlwZT0ncmFkaW8nXSxcXG4gICAgICAgICAgaW5wdXRbdHlwZT0nY2hlY2tib3gnXSB7XFxuICAgICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlucHV0W3R5cGU9J2RhdGUnXSxcXG4gICAgICAgICAgaW5wdXRbdHlwZT0ndGltZSddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdkYXRldGltZS1sb2NhbCddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdtb250aCddIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGxpc3Rib3g7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGV4dGFyZWEge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiBhdXRvO1xcbiAgICAgICAgICAgIHJlc2l6ZTogdmVydGljYWw7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZmllbGRzZXQge1xcbiAgICAgICAgICAgIG1pbi13aWR0aDogMDtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgICBib3JkZXI6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbGVnZW5kIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcXG4gICAgICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XFxuICAgICAgICAgICAgcGFkZGluZzogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxuICAgICAgICAgICAgZm9udC1zaXplOiAxLjVyZW07XFxuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcm9ncmVzcyB7XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIFt0eXBlPSdudW1iZXInXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG4gICAgICAgICAgW3R5cGU9J251bWJlciddOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gICAgICAgICAgICBoZWlnaHQ6IGF1dG87XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J3NlYXJjaCddIHtcXG4gICAgICAgICAgICBvdXRsaW5lLW9mZnNldDogLTJweDtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J3NlYXJjaCddOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAgICAgICAgICAgZm9udDogaW5oZXJpdDtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvdXRwdXQge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdW1tYXJ5IHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRlbXBsYXRlIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIFtoaWRkZW5dIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XFxuICAgICAgICAgIH1cXG4gICAgICAgIFwiXSwgW1wiXFxuICAgICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgICBhbGw6IGluaXRpYWw7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgLyohXFxuICAgICAgICAgICAqIEJvb3RzdHJhcCBSZWJvb3QgdjQuNC4xIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxcbiAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFRoZSBCb290c3RyYXAgQXV0aG9yc1xcbiAgICAgICAgICAgKiBDb3B5cmlnaHQgMjAxMS0yMDE5IFR3aXR0ZXIsIEluYy5cXG4gICAgICAgICAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcXG4gICAgICAgICAgICogRm9ya2VkIGZyb20gTm9ybWFsaXplLmNzcywgbGljZW5zZWQgTUlUIChodHRwczovL2dpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQpXFxuICAgICAgICAgICAqL1xcbiAgICAgICAgICAqLFxcbiAgICAgICAgICAqOjpiZWZvcmUsXFxuICAgICAgICAgICo6OmFmdGVyIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIDpob3N0IHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS4xNTtcXG4gICAgICAgICAgICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7XFxuICAgICAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFydGljbGUsXFxuICAgICAgICAgIGFzaWRlLFxcbiAgICAgICAgICBmaWdjYXB0aW9uLFxcbiAgICAgICAgICBmaWd1cmUsXFxuICAgICAgICAgIGZvb3RlcixcXG4gICAgICAgICAgaGVhZGVyLFxcbiAgICAgICAgICBoZ3JvdXAsXFxuICAgICAgICAgIG1haW4sXFxuICAgICAgICAgIG5hdixcXG4gICAgICAgICAgc2VjdGlvbiB7XFxuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgOmhvc3Qge1xcbiAgICAgICAgICAgIG1hcmdpbjogMDtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sXFxuICAgICAgICAgICAgICAnSGVsdmV0aWNhIE5ldWUnLCBBcmlhbCwgJ05vdG8gU2FucycsIHNhbnMtc2VyaWYsXFxuICAgICAgICAgICAgICAnQXBwbGUgQ29sb3IgRW1vamknLCAnU2Vnb2UgVUkgRW1vamknLCAnU2Vnb2UgVUkgU3ltYm9sJyxcXG4gICAgICAgICAgICAgICdOb3RvIENvbG9yIEVtb2ppJztcXG4gICAgICAgICAgICBmb250LXNpemU6IDFyZW07XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogMS41O1xcbiAgICAgICAgICAgIGNvbG9yOiAjMjEyNTI5O1xcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdGFiaW5kZXg9Jy0xJ106Zm9jdXM6bm90KDpmb2N1cy12aXNpYmxlKSB7XFxuICAgICAgICAgICAgb3V0bGluZTogMCAhaW1wb3J0YW50O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGhyIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDtcXG4gICAgICAgICAgICBoZWlnaHQ6IDA7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IHZpc2libGU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaDEsXFxuICAgICAgICAgIGgyLFxcbiAgICAgICAgICBoMyxcXG4gICAgICAgICAgaDQsXFxuICAgICAgICAgIGg1LFxcbiAgICAgICAgICBoNiB7XFxuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwLjVyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcCB7XFxuICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcXG4gICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAxcmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFiYnJbdGl0bGVdLFxcbiAgICAgICAgICBhYmJyW2RhdGEtb3JpZ2luYWwtdGl0bGVdIHtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgICAgICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgICAgY3Vyc29yOiBoZWxwO1xcbiAgICAgICAgICAgIGJvcmRlci1ib3R0b206IDA7XFxuICAgICAgICAgICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb24tc2tpcC1pbms6IG5vbmU7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uLXNraXAtaW5rOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGFkZHJlc3Mge1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDFyZW07XFxuICAgICAgICAgICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG9sLFxcbiAgICAgICAgICB1bCxcXG4gICAgICAgICAgZGwge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvbCBvbCxcXG4gICAgICAgICAgdWwgdWwsXFxuICAgICAgICAgIG9sIHVsLFxcbiAgICAgICAgICB1bCBvbCB7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkdCB7XFxuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkZCB7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgICAgICAgICAgIG1hcmdpbi1sZWZ0OiAwO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJsb2NrcXVvdGUge1xcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDFyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYixcXG4gICAgICAgICAgc3Ryb25nIHtcXG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHNtYWxsIHtcXG4gICAgICAgICAgICBmb250LXNpemU6IDgwJTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdWIsXFxuICAgICAgICAgIHN1cCB7XFxuICAgICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogNzUlO1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiAwO1xcbiAgICAgICAgICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdWIge1xcbiAgICAgICAgICAgIGJvdHRvbTogLTAuMjVlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdXAge1xcbiAgICAgICAgICAgIHRvcDogLTAuNWVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGEge1xcbiAgICAgICAgICAgIGNvbG9yOiAjMDA3YmZmO1xcbiAgICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhOmhvdmVyIHtcXG4gICAgICAgICAgICBjb2xvcjogIzAwNTZiMztcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhOm5vdChbaHJlZl0pIHtcXG4gICAgICAgICAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgYTpub3QoW2hyZWZdKTpob3ZlciB7XFxuICAgICAgICAgICAgY29sb3I6IGluaGVyaXQ7XFxuICAgICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHByZSxcXG4gICAgICAgICAgY29kZSxcXG4gICAgICAgICAga2JkLFxcbiAgICAgICAgICBzYW1wIHtcXG4gICAgICAgICAgICBmb250LWZhbWlseTogU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLFxcbiAgICAgICAgICAgICAgJ0xpYmVyYXRpb24gTW9ubycsICdDb3VyaWVyIE5ldycsIG1vbm9zcGFjZTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDFlbTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBwcmUge1xcbiAgICAgICAgICAgIG1hcmdpbi10b3A6IDA7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG4gICAgICAgICAgICBvdmVyZmxvdzogYXV0bztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmaWd1cmUge1xcbiAgICAgICAgICAgIG1hcmdpbjogMCAwIDFyZW07XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW1nIHtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzdmcge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0YWJsZSB7XFxuICAgICAgICAgICAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBjYXB0aW9uIHtcXG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMC43NXJlbTtcXG4gICAgICAgICAgICBwYWRkaW5nLWJvdHRvbTogMC43NXJlbTtcXG4gICAgICAgICAgICBjb2xvcjogIzZjNzU3ZDtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgICAgICAgICAgIGNhcHRpb24tc2lkZTogYm90dG9tO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRoIHtcXG4gICAgICAgICAgICB0ZXh0LWFsaWduOiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGxhYmVsIHtcXG4gICAgICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbiB7XFxuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246Zm9jdXMge1xcbiAgICAgICAgICAgIG91dGxpbmU6IDFweCBkb3R0ZWQ7XFxuICAgICAgICAgICAgb3V0bGluZTogNXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlucHV0LFxcbiAgICAgICAgICBidXR0b24sXFxuICAgICAgICAgIHNlbGVjdCxcXG4gICAgICAgICAgb3B0Z3JvdXAsXFxuICAgICAgICAgIHRleHRhcmVhIHtcXG4gICAgICAgICAgICBtYXJnaW46IDA7XFxuICAgICAgICAgICAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICAgICAgICAgICAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgICAgICAgICAgIGxpbmUtaGVpZ2h0OiBpbmhlcml0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgaW5wdXQge1xcbiAgICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgc2VsZWN0IHtcXG4gICAgICAgICAgICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBzZWxlY3Qge1xcbiAgICAgICAgICAgIHdvcmQtd3JhcDogbm9ybWFsO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbixcXG4gICAgICAgICAgW3R5cGU9J2J1dHRvbiddLFxcbiAgICAgICAgICBbdHlwZT0ncmVzZXQnXSxcXG4gICAgICAgICAgW3R5cGU9J3N1Ym1pdCddIHtcXG4gICAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBidXR0b246bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdidXR0b24nXTpub3QoOmRpc2FibGVkKSxcXG4gICAgICAgICAgW3R5cGU9J3Jlc2V0J106bm90KDpkaXNhYmxlZCksXFxuICAgICAgICAgIFt0eXBlPSdzdWJtaXQnXTpub3QoOmRpc2FibGVkKSB7XFxuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGJ1dHRvbjo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J2J1dHRvbiddOjotbW96LWZvY3VzLWlubmVyLFxcbiAgICAgICAgICBbdHlwZT0ncmVzZXQnXTo6LW1vei1mb2N1cy1pbm5lcixcXG4gICAgICAgICAgW3R5cGU9J3N1Ym1pdCddOjotbW96LWZvY3VzLWlubmVyIHtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIGJvcmRlci1zdHlsZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdyYWRpbyddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSdjaGVja2JveCddIHtcXG4gICAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW5wdXRbdHlwZT0nZGF0ZSddLFxcbiAgICAgICAgICBpbnB1dFt0eXBlPSd0aW1lJ10sXFxuICAgICAgICAgIGlucHV0W3R5cGU9J2RhdGV0aW1lLWxvY2FsJ10sXFxuICAgICAgICAgIGlucHV0W3R5cGU9J21vbnRoJ10ge1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbGlzdGJveDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB0ZXh0YXJlYSB7XFxuICAgICAgICAgICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgICAgICAgICAgcmVzaXplOiB2ZXJ0aWNhbDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBmaWVsZHNldCB7XFxuICAgICAgICAgICAgbWluLXdpZHRoOiAwO1xcbiAgICAgICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICAgICAgbWFyZ2luOiAwO1xcbiAgICAgICAgICAgIGJvcmRlcjogMDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBsZWdlbmQge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xcbiAgICAgICAgICAgIG1heC13aWR0aDogMTAwJTtcXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcXG4gICAgICAgICAgICBmb250LXNpemU6IDEuNXJlbTtcXG4gICAgICAgICAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcXG4gICAgICAgICAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgICAgICAgICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHByb2dyZXNzIHtcXG4gICAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW3R5cGU9J251bWJlciddOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcbiAgICAgICAgICBbdHlwZT0nbnVtYmVyJ106Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcbiAgICAgICAgICAgIGhlaWdodDogYXV0bztcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdHlwZT0nc2VhcmNoJ10ge1xcbiAgICAgICAgICAgIG91dGxpbmUtb2Zmc2V0OiAtMnB4O1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBbdHlwZT0nc2VhcmNoJ106Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICA6Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gICAgICAgICAgICBmb250OiBpbmhlcml0O1xcbiAgICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIG91dHB1dCB7XFxuICAgICAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHN1bW1hcnkge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IGxpc3QtaXRlbTtcXG4gICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGVtcGxhdGUge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgW2hpZGRlbl0ge1xcbiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgXCJdKSkpXG4gICAgICAgIH0gfSkpO1xufVxuZXhwb3J0cy5Dc3NSZXNldCA9IENzc1Jlc2V0O1xudmFyIHRlbXBsYXRlT2JqZWN0XzE7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKHtvbmx5Rmlyc3QgPSBmYWxzZX0gPSB7fSkgPT4ge1xuXHRjb25zdCBwYXR0ZXJuID0gW1xuXHRcdCdbXFxcXHUwMDFCXFxcXHUwMDlCXVtbXFxcXF0oKSM7P10qKD86KD86KD86KD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKykqfFthLXpBLVpcXFxcZF0rKD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKikqKT9cXFxcdTAwMDcpJyxcblx0XHQnKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSknXG5cdF0uam9pbignfCcpO1xuXG5cdHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIG9ubHlGaXJzdCA/IHVuZGVmaW5lZCA6ICdnJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuY29uc3QgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmluZyA9PiB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyA/IHN0cmluZy5yZXBsYWNlKGFuc2lSZWdleCgpLCAnJykgOiBzdHJpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjb250ZXh0LCBkaXNhYmxlZFN0YXRlKSB7XG4gIGlmICghc3VwcG9ydHMpIHtcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAnZWxlbWVudC9kaXNhYmxlZCcsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9KTtcblxuICAvLyBhY2NlcHQgdHJ1dGh5L2ZhbHN5IHZhbHVlc1xuICBkaXNhYmxlZFN0YXRlID0gQm9vbGVhbihkaXNhYmxlZFN0YXRlKTtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLWFsbHktZGlzYWJsZWQnKTtcbiAgLy8gaWYgdGhlcmUncyBubyB2YWx1ZSB0byBzZXQsIHdlJ3JlIHJ1bm5pbmcgYXMgYSBnZXR0ZXJcbiAgdmFyIHJ1bm5pbmdBc0dldHRlciA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XG5cbiAgaWYgKCgwLCBfbmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQyLmRlZmF1bHQpKGVsZW1lbnQpKSB7XG4gICAgaWYgKHJ1bm5pbmdBc0dldHRlcikge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgLy8gZm9ybSBlbGVtZW50cyBrbm93IHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUsIHdoaWNoIHdlIHNoYWxsIHVzZSBpbnN0ZWFkIG9mIG91ciBwb29yIG1hbidzIGNvcHkgb2YgaXRcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGlzYWJsZWRTdGF0ZTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIGlmIChydW5uaW5nQXNHZXR0ZXIpIHtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xuICB9XG5cbiAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gZGlzYWJsZWRTdGF0ZSkge1xuICAgIC8vIG5vIHVwZGF0ZSBuZWNlc3NhcnlcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHNldEVsZW1lbnREaXNhYmxlZChlbGVtZW50LCBkaXNhYmxlZFN0YXRlKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XG5cbnZhciBfdGFiaW5kZXhWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWwvdGFiaW5kZXgtdmFsdWUnKTtcblxudmFyIF90YWJpbmRleFZhbHVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmluZGV4VmFsdWUpO1xuXG52YXIgX25hdGl2ZURpc2FibGVkU3VwcG9ydGVkID0gcmVxdWlyZSgnLi4vaXMvbmF0aXZlLWRpc2FibGVkLXN1cHBvcnRlZCcpO1xuXG52YXIgX25hdGl2ZURpc2FibGVkU3VwcG9ydGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25hdGl2ZURpc2FibGVkU3VwcG9ydGVkKTtcblxudmFyIF90b2dnbGVBdHRyaWJ1dGUgPSByZXF1aXJlKCcuLi91dGlsL3RvZ2dsZS1hdHRyaWJ1dGUnKTtcblxudmFyIF90b2dnbGVBdHRyaWJ1dGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdG9nZ2xlQXR0cmlidXRlKTtcblxudmFyIF90b2dnbGVBdHRyaWJ1dGVWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWwvdG9nZ2xlLWF0dHJpYnV0ZS12YWx1ZScpO1xuXG52YXIgX3RvZ2dsZUF0dHJpYnV0ZVZhbHVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RvZ2dsZUF0dHJpYnV0ZVZhbHVlKTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKCcuLi91dGlsL2xvZ2dlcicpO1xuXG52YXIgX2xvZ2dlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9sb2dnZXIpO1xuXG52YXIgX3N1cHBvcnRzMiA9IHJlcXVpcmUoJy4uL3N1cHBvcnRzL3N1cHBvcnRzJyk7XG5cbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHN1cHBvcnRzID0gdm9pZCAwO1xuLypcbiAgVXRpbGl0eSB0byBtYWtlIGFueSBlbGVtZW50IGluZXJ0IChkaXNhYmxlZCkuIEluZXJ0IG1lYW5zIHRoZSBlbGVtZW50cyBjYW5ub3QgYmUgaW50ZXJhY3RlZFxuICB3aXRoIGFuZCB0aGV5IGNhbm5vdCBiZSBmb2N1c2VkIHZpYSBzY3JpcHQsIHBvaW50ZXIgb3Iga2V5Ym9hcmQgLSBhbmQgdGh1cyBub3QgcmVjZWl2ZSBmb2N1cy5cblxuICBFbGVtZW50cyBtYWRlIGluZXJ0IChkaXNhYmxlZCkgYnkgdGhpcyB1dGlsaXR5IGFyZSBnaXZlbiB0aGUgYXR0cmlidXRlIFtkYXRhLWFsbHktZGlzYWJsZWQ9XCJ0cnVlXCJdLlxuXG4gIC0tLS0tLS0tLS0tLS0tLVxuXG4gIGluZXJ0IGF0dHJpYnV0ZSB3YXMgW3JlbW92ZWRdKGh0dHBzOi8vaHRtbDUub3JnL3IvODUzNikgW3R3ZWV0IGJ5IHN0ZXZlXShodHRwczovL3R3aXR0ZXIuY29tL3N0ZXZlZmF1bGtuZXIvc3RhdHVzLzQ0MzA3NTkwMDIwMTI1OTAwOClcbiAgYnV0IGRlZmluaXRpb24gb2YgW2luZXJ0IHN1YnRyZWVzXShodHRwczovL3d3dy53My5vcmcvaHRtbC93Zy9kcmFmdHMvaHRtbC9tYXN0ZXIvZWRpdGluZy5odG1sI2luZXJ0LXN1YnRyZWVzKSByZW1haW5zLlxuXG4gIFtpbXBsZW1lbnRhdGlvbiBpZGVhIGJ5IFZhc2lsaXNdKGh0dHBzOi8vY29kZXBlbi5pby92YXNpbGlzdmcvcGVuL3Njb3dJKVxuICBbaW5lcnQgYXR0cmlidXRlIHBvbHlmaWxsIGJ5IEdvb2dsZUNocm9tZV0oaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS9pbmVydC1wb2x5ZmlsbClcblxuICBbR2Vja28gQnVnOiBJbmVydCBBdHRyaWJ1dGVdKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkyMTUwNClcbiAgW0Nocm9taXVtIEJ1ZzogSW5lcnQgQXR0cmlidXRlXShodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjY5ODQ2KVxuICBbQ2hyb21pdW0gQnVnOiBJbmVydCBTdWJ0cmVlXShodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjQxNjk5KVxuICBbV2ViS2l0IEJ1ZzogSW5lcnQgU3VidHJlZV0oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTExMDk1MilcbiovXG5cbmZ1bmN0aW9uIGRpc2FibGVkRm9jdXMoKSB7XG4gIF9sb2dnZXIyLmRlZmF1bHQud2FybigndHJ5aW5nIHRvIGZvY3VzIGluZXJ0IGVsZW1lbnQnLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gZGlzYWJsZVRhYmluZGV4KGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpIHtcbiAgaWYgKGRpc2FibGVkU3RhdGUpIHtcbiAgICB2YXIgdGFiSW5kZXggPSAoMCwgX3RhYmluZGV4VmFsdWUyLmRlZmF1bHQpKGVsZW1lbnQpO1xuICAgICgwLCBfdG9nZ2xlQXR0cmlidXRlVmFsdWUyLmRlZmF1bHQpKHtcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICBhdHRyaWJ1dGU6ICd0YWJpbmRleCcsXG4gICAgICB0ZW1wb3JhcnlWYWx1ZTogJy0xJyxcbiAgICAgIHNhdmVWYWx1ZTogdGFiSW5kZXggIT09IG51bGwgPyB0YWJJbmRleCA6ICcnXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgKDAsIF90b2dnbGVBdHRyaWJ1dGVWYWx1ZTIuZGVmYXVsdCkoe1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIGF0dHJpYnV0ZTogJ3RhYmluZGV4J1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc2FibGVWaWRlb0NvbnRyb2xzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpIHtcbiAgKDAsIF90b2dnbGVBdHRyaWJ1dGUyLmRlZmF1bHQpKHtcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIGF0dHJpYnV0ZTogJ2NvbnRyb2xzJyxcbiAgICByZW1vdmU6IGRpc2FibGVkU3RhdGVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRpc2FibGVTdmdGb2N1c2FibGUoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSkge1xuICAoMCwgX3RvZ2dsZUF0dHJpYnV0ZVZhbHVlMi5kZWZhdWx0KSh7XG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBhdHRyaWJ1dGU6ICdmb2N1c2FibGUnLFxuICAgIHRlbXBvcmFyeVZhbHVlOiBkaXNhYmxlZFN0YXRlID8gJ2ZhbHNlJyA6IHVuZGVmaW5lZFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGlzYWJsZVN2Z0xpbmsoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSkge1xuICAoMCwgX3RvZ2dsZUF0dHJpYnV0ZTIuZGVmYXVsdCkoe1xuICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgYXR0cmlidXRlOiAneGxpbms6aHJlZicsXG4gICAgcmVtb3ZlOiBkaXNhYmxlZFN0YXRlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRBcmlhRGlzYWJsZWQoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSkge1xuICAoMCwgX3RvZ2dsZUF0dHJpYnV0ZVZhbHVlMi5kZWZhdWx0KSh7XG4gICAgZWxlbWVudDogZWxlbWVudCxcbiAgICBhdHRyaWJ1dGU6ICdhcmlhLWRpc2FibGVkJyxcbiAgICB0ZW1wb3JhcnlWYWx1ZTogZGlzYWJsZWRTdGF0ZSA/ICd0cnVlJyA6IHVuZGVmaW5lZFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdEZvY3VzKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpIHtcbiAgaWYgKGRpc2FibGVkU3RhdGUpIHtcbiAgICAvLyBtYWtlIHN1cmUgbm8gc2NyaXB0IGNhbiBmb2N1cyB0aGUgZWxlbWVudFxuICAgIGVsZW1lbnQuZm9jdXMgPSBkaXNhYmxlZEZvY3VzO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgZm9jdXMgZnVuY3Rpb24gZnJvbSBwcm90b3R5cGVcbiAgICBkZWxldGUgZWxlbWVudC5mb2N1cztcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNhYmxlUG9pbnRlckV2ZW50cyhlbGVtZW50LCBkaXNhYmxlZFN0YXRlKSB7XG4gIGlmIChkaXNhYmxlZFN0YXRlKSB7XG4gICAgLy8gcmVtZW1iZXIgcHJldmlvdXMgcG9pbnRlciBldmVudHMgc3RhdHVzIHNvIHdlIGNhbiByZXN0b3JlIGl0XG4gICAgdmFyIHBvaW50ZXJFdmVudHMgPSBlbGVtZW50LnN0eWxlLnBvaW50ZXJFdmVudHMgfHwgJyc7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5lcnQtcG9pbnRlci1ldmVudHMnLCBwb2ludGVyRXZlbnRzKTtcbiAgICAvLyBtYWtlIHN1cmUgbm8gcG9pbnRlciBpbnRlcmFjdGlvbiBjYW4gYWNjZXNzIHRoZSBlbGVtZW50XG4gICAgZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3RvcmUgdG8gcHJldmlvdXMgcG9pbnRlciBpbnRlcmFjdGlvbiBzdGF0dXNcbiAgICB2YXIgX3BvaW50ZXJFdmVudHMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1pbmVydC1wb2ludGVyLWV2ZW50cycpO1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWluZXJ0LXBvaW50ZXItZXZlbnRzJyk7XG4gICAgZWxlbWVudC5zdHlsZS5wb2ludGVyRXZlbnRzID0gX3BvaW50ZXJFdmVudHM7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0RWxlbWVudERpc2FibGVkKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpIHtcbiAgc2V0QXJpYURpc2FibGVkKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpO1xuICBkaXNhYmxlVGFiaW5kZXgoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSk7XG4gIGRpc2FibGVTY3JpcHRGb2N1cyhlbGVtZW50LCBkaXNhYmxlZFN0YXRlKTtcbiAgZGlzYWJsZVBvaW50ZXJFdmVudHMoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSk7XG5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobm9kZU5hbWUgPT09ICd2aWRlbycgfHwgbm9kZU5hbWUgPT09ICdhdWRpbycpIHtcbiAgICAvLyBCbGluayBhbmQgR2Vja28gbGVhdmUgPHZpZGVvIGNvbnRyb2xzIHRhYmluZGV4PVwiLTFcIj4gaW4gZG9jdW1lbnQgZm9jdXMgbmF2aWdhdGlvbiBzZXF1ZW5jZVxuICAgIC8vIEJsaW5rIGxlYXZlcyA8YXVkaW8gY29udHJvbHMgdGFiaW5kZXg9XCItMVwiPiBpbiBkb2N1bWVudCBmb2N1cyBuYXZpZ2F0aW9uIHNlcXVlbmNlXG4gICAgZGlzYWJsZVZpZGVvQ29udHJvbHMoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSk7XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICdzdmcnIHx8IGVsZW1lbnQub3duZXJTVkdFbGVtZW50KSB7XG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlKSB7XG4gICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciBrbm93cyBmb2N1c2FibGU9XCJmYWxzZVwiIGluc3RlYWQgb2YgdGFiaW5kZXg9XCItMVwiXG4gICAgICBkaXNhYmxlU3ZnRm9jdXNhYmxlKGVsZW1lbnQsIGRpc2FibGVkU3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoIXN1cHBvcnRzLmZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUgJiYgbm9kZU5hbWUgPT09ICdhJykge1xuICAgICAgLy8gRmlyZWZveCBuZWl0aGVyIGtub3dzIGZvY3VzYWJsZT1cImZhbHNlXCIgbm9yIHRhYmluZGV4PVwiLTFcIlxuICAgICAgZGlzYWJsZVN2Z0xpbmsoZWxlbWVudCwgZGlzYWJsZWRTdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpc2FibGVkU3RhdGUpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1hbGx5LWRpc2FibGVkJywgJ3RydWUnKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hbGx5LWRpc2FibGVkJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNhYmxlZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIC8vIEVkZ2UxMywgRWRnZTE0OiBmb3JlaWduT2JqZWN0IGZvY3VzIGhhY2tcbiAgLy8gaHR0cHM6Ly9qc2Jpbi5jb20va3VuZWhpbnVnaS9lZGl0P2h0bWwsanMsb3V0cHV0XG4gIC8vIGh0dHBzOi8vanNiaW4uY29tL2ZhamFnaS8zL2VkaXQ/aHRtbCxqcyxvdXRwdXRcbiAgdmFyIGlzU3ZnRWxlbWVudCA9IGVsZW1lbnQub3duZXJTVkdFbGVtZW50IHx8IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2Zyc7XG4gIGlmICghaXNTdmdFbGVtZW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gaW5qZWN0IGFuZCBmb2N1cyBhbiA8aW5wdXQ+IGVsZW1lbnQgaW50byB0aGUgU1ZHIGVsZW1lbnQgdG8gcmVjZWl2ZSBmb2N1c1xuICB2YXIgZm9yZWlnbk9iamVjdCA9IG1ha2VGb2N1c2FibGVGb3JlaWduT2JqZWN0KCk7XG4gIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZm9yZWlnbk9iamVjdCk7XG4gIHZhciBpbnB1dCA9IGZvcmVpZ25PYmplY3QucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgaW5wdXQuZm9jdXMoKTtcblxuICAvLyB1cG9uIGRpc2FibGluZyB0aGUgYWN0aXZlRWxlbWVudCwgSUUgYW5kIEVkZ2VcbiAgLy8gd2lsbCBub3Qgc2hpZnQgZm9jdXMgdG8gPGJvZHk+IGxpa2UgYWxsIHRoZSBvdGhlclxuICAvLyBicm93c2VycywgYnV0IGluc3RlYWQgZmluZCB0aGUgZmlyc3QgZm9jdXNhYmxlXG4gIC8vIGFuY2VzdG9yIGFuZCBzaGlmdCBmb2N1cyB0byB0aGF0XG4gIGlucHV0LmRpc2FibGVkID0gdHJ1ZTtcblxuICAvLyBjbGVhbiB1cFxuICBlbGVtZW50LnJlbW92ZUNoaWxkKGZvcmVpZ25PYmplY3QpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIG1ha2VGb2N1c2FibGVGb3JlaWduT2JqZWN0KCkge1xuICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZnJhZ21lbnQuaW5uZXJIVE1MID0gJzxzdmc+PGZvcmVpZ25PYmplY3Qgd2lkdGg9XCIzMFwiIGhlaWdodD1cIjMwXCI+XFxuICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIvPlxcbiAgPC9mb3JlaWduT2JqZWN0Pjwvc3ZnPic7XG5cbiAgcmV0dXJuIGZyYWdtZW50LmZpcnN0Q2hpbGQuZmlyc3RDaGlsZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy5zdmctZm9yZWlnbi1vYmplY3QtaGFjay5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dDtcblxuICB2YXIgbGlzdCA9IFtdO1xuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAnZ2V0L3BhcmVudHMnLFxuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfSk7XG5cbiAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICBsaXN0LnB1c2goZWxlbWVudCk7XG4gICAgLy8gSUUgZG9lcyBrbm93IHN1cHBvcnQgcGFyZW50RWxlbWVudCBvbiBTVkdFbGVtZW50XG4gICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgZWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vLyBbZWxlbSwgZWxlbS5wYXJlbnQsIGVsZW0ucGFyZW50LnBhcmVudCwg4oCmLCBodG1sXVxuLy8gd2lsbCBub3QgY29udGFpbiB0aGUgc2hhZG93Um9vdCAoRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkgYW5kIHNoYWRvd0hvc3Rcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmVudHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQ7XG5cbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcbiAgICBsYWJlbDogJ2dldC9zaGFkb3ctaG9zdCcsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9KTtcblxuICAvLyB3YWxrIHVwIHRvIHRoZSByb290XG4gIHZhciBjb250YWluZXIgPSBudWxsO1xuXG4gIHdoaWxlIChlbGVtZW50KSB7XG4gICAgY29udGFpbmVyID0gZWxlbWVudDtcbiAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUubm9kZVR5cGVcbiAgLy8gTk9URTogRmlyZWZveCAzNCBkb2VzIG5vdCBleHBvc2UgU2hhZG93Um9vdC5ob3N0IChidXQgMzcgZG9lcylcbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gY29udGFpbmVyLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiYgY29udGFpbmVyLmhvc3QpIHtcbiAgICAvLyB0aGUgcm9vdCBpcyBhdHRhY2hlZCB0byBhIGZyYWdtZW50IG5vZGUgdGhhdCBoYXMgYSBob3N0XG4gICAgcmV0dXJuIGNvbnRhaW5lci5ob3N0O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZG93LWhvc3QuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAnaXMvYWN0aXZlLWVsZW1lbnQnLFxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH0pO1xuXG4gIHZhciBfZG9jdW1lbnQgPSAoMCwgX2dldERvY3VtZW50Mi5kZWZhdWx0KShlbGVtZW50KTtcbiAgaWYgKF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgc2hhZG93SG9zdCA9ICgwLCBfc2hhZG93SG9zdDIuZGVmYXVsdCkoeyBjb250ZXh0OiBlbGVtZW50IH0pO1xuICBpZiAoc2hhZG93SG9zdCAmJiBzaGFkb3dIb3N0LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudCA9PT0gZWxlbWVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xuXG52YXIgX3NoYWRvd0hvc3QgPSByZXF1aXJlKCcuLi9nZXQvc2hhZG93LWhvc3QnKTtcblxudmFyIF9zaGFkb3dIb3N0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWRvd0hvc3QpO1xuXG52YXIgX2dldERvY3VtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9nZXQtZG9jdW1lbnQnKTtcblxudmFyIF9nZXREb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXREb2N1bWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIERldGVybWluZXMgaWYgYW4gZWxlbWVudCBpcyB0aGUgYWN0aXZlRWxlbWVudCB3aXRoaW4gaXRzIGNvbnRleHQsIGkuZS4gaXRzIGRvY3VtZW50IGlGcmFtZSBvciBTaGFkb3dIb3N0XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWN0aXZlLWVsZW1lbnQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICBpZiAoIXN1cHBvcnRzKSB7XG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcbiAgICBsYWJlbDogJ2lzL2Rpc2FibGVkJyxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH0pO1xuXG4gIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1hbGx5LWRpc2FibGVkJykpIHtcbiAgICAvLyB0cmVhdCBhbGx5J3MgZWxlbWVudC9kaXNhYmxlZCBsaWtlIHRoZSBET00gbmF0aXZlIGVsZW1lbnQuZGlzYWJsZWRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghKDAsIF9uYXRpdmVEaXNhYmxlZFN1cHBvcnRlZDIuZGVmYXVsdCkoZWxlbWVudCkpIHtcbiAgICAvLyBub24tZm9ybSBlbGVtZW50cyBkbyBub3Qgc3VwcG9ydCB0aGUgZGlzYWJsZWQgYXR0cmlidXRlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQuZGlzYWJsZWQpIHtcbiAgICAvLyB0aGUgZWxlbWVudCBpdHNlbGYgaXMgZGlzYWJsZWRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBwYXJlbnRzID0gKDAsIF9wYXJlbnRzMi5kZWZhdWx0KSh7IGNvbnRleHQ6IGVsZW1lbnQgfSk7XG4gIGlmIChwYXJlbnRzLnNvbWUoaXNEaXNhYmxlZEZpZWxkc2V0KSkge1xuICAgIC8vIGEgcGFyZW50YWwgPGZpZWxkc2V0PiBpcyBkaXNhYmxkIGFuZCBpbmhlcml0cyB0aGUgc3RhdGUgb250byB0aGlzIGVsZW1lbnRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghc3VwcG9ydHMuZm9jdXNGb3JtRGlzYWJsZWQgJiYgcGFyZW50cy5zb21lKGlzRGlzYWJsZWRGb3JtKSkge1xuICAgIC8vIGEgcGFyZW50YWwgPGZvcm0+IGlzIGRpc2FibGQgYW5kIGluaGVyaXRzIHRoZSBzdGF0ZSBvbnRvIHRoaXMgZWxlbWVudFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xuXG52YXIgX3BhcmVudHMgPSByZXF1aXJlKCcuLi9nZXQvcGFyZW50cycpO1xuXG52YXIgX3BhcmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyZW50cyk7XG5cbnZhciBfbmF0aXZlRGlzYWJsZWRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL25hdGl2ZS1kaXNhYmxlZC1zdXBwb3J0ZWQnKTtcblxudmFyIF9uYXRpdmVEaXNhYmxlZFN1cHBvcnRlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9uYXRpdmVEaXNhYmxlZFN1cHBvcnRlZCk7XG5cbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcblxudmFyIF9zdXBwb3J0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0czIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBEZXRlcm1pbmUgaWYgYW4gZWxlbWVudCBpcyBkaXNhYmxlZCAoaS5lLiBub3QgZWRpdGFibGUpXG5cbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcblxuZnVuY3Rpb24gaXNEaXNhYmxlZEZpZWxkc2V0KGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdmaWVsZHNldCcgJiYgZWxlbWVudC5kaXNhYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNEaXNhYmxlZEZvcm0oZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ2Zvcm0nICYmIGVsZW1lbnQuZGlzYWJsZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzYWJsZWQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BhcmVudHMgPSByZXF1aXJlKCcuLi9nZXQvcGFyZW50cycpO1xuXG52YXIgX3BhcmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGFyZW50cyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcblxudmFyIF9lbGVtZW50TWF0Y2hlcyA9IHJlcXVpcmUoJy4uL3V0aWwvZWxlbWVudC1tYXRjaGVzJyk7XG5cbnZhciBfZWxlbWVudE1hdGNoZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWxlbWVudE1hdGNoZXMpO1xuXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XG5cbnZhciBfdGFiaW5kZXhWYWx1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJpbmRleFZhbHVlKTtcblxudmFyIF92YWxpZFRhYmluZGV4ID0gcmVxdWlyZSgnLi92YWxpZC10YWJpbmRleCcpO1xuXG52YXIgX3ZhbGlkVGFiaW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmFsaWRUYWJpbmRleCk7XG5cbnZhciBfaXMgPSByZXF1aXJlKCcuL2lzLnV0aWwnKTtcblxudmFyIF9zdXBwb3J0czIgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9zdXBwb3J0cycpO1xuXG52YXIgX3N1cHBvcnRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcbi8vIGRldGVybWluZSBpZiBhbiBlbGVtZW50IHN1cHBvcnRzLmNhbiBiZSBmb2N1c2VkIGJ5IHNjcmlwdCByZWdhcmRsZXNzXG4vLyBvZiB0aGUgZWxlbWVudCBhY3R1YWxseSBiZWluZyBmb2N1c2FibGUgYXQgdGhlIHRpbWUgb2YgZXhlY3V0aW9uXG4vLyBpLmUuIDxpbnB1dCBkaXNhYmxlZD4gaXMgY29uaXNkZXJlZCBmb2N1cy1yZWxldmFudCwgYnV0IG5vdCBmb2N1c2FibGVcblxuZnVuY3Rpb24gaXNGb2N1c1JlbGV2YW50UnVsZXMoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICBfcmVmJGV4Y2VwdCA9IF9yZWYuZXhjZXB0LFxuICAgICAgZXhjZXB0ID0gX3JlZiRleGNlcHQgPT09IHVuZGVmaW5lZCA/IHtcbiAgICBmbGV4Ym94OiBmYWxzZSxcbiAgICBzY3JvbGxhYmxlOiBmYWxzZSxcbiAgICBzaGFkb3c6IGZhbHNlXG4gIH0gOiBfcmVmJGV4Y2VwdDtcblxuICBpZiAoIXN1cHBvcnRzKSB7XG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcbiAgICBsYWJlbDogJ2lzL2ZvY3VzLXJlbGV2YW50JyxcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9KTtcblxuICBpZiAoIWV4Y2VwdC5zaGFkb3cgJiYgZWxlbWVudC5zaGFkb3dSb290KSB7XG4gICAgLy8gYSBTaGFkb3dET00gaG9zdCByZWNlaXZlcyBmb2N1cyB3aGVuIHRoZSBmb2N1cyBtb3ZlcyB0byBpdHMgY29udGVudFxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtZW50LnR5cGUgPT09ICdoaWRkZW4nKSB7XG4gICAgLy8gaW5wdXRbdHlwZT1cImhpZGRlblwiXSBzdXBwb3J0cy5jYW5ub3QgYmUgZm9jdXNlZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0JyB8fCBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdidXR0b24nIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICdsZWdlbmQnICYmIHN1cHBvcnRzLmZvY3VzUmVkaXJlY3RMZWdlbmQpIHtcbiAgICAvLyBzcGVjaWZpY3MgZmlsdGVyZWQgaW4gaXMvZm9jdXNhYmxlXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICdsYWJlbCcpIHtcbiAgICAvLyBzcGVjaWZpY3MgZmlsdGVyZWQgaW4gaXMvZm9jdXNhYmxlXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICdhcmVhJykge1xuICAgIC8vIHNwZWNpZmljcyBmaWx0ZXJlZCBpbiBpcy9mb2N1c2FibGVcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2EnICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdocmVmJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3VzZW1hcCcpKSB7XG4gICAgLy8gb2JqZWN0W3VzZW1hcF0gaXMgbm90IGZvY3VzYWJsZSBpbiBhbnkgYnJvd3NlclxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgc3ZnVHlwZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgaWYgKCFzdXBwb3J0cy5mb2N1c09iamVjdFN2ZyAmJiBzdmdUeXBlID09PSAnaW1hZ2Uvc3ZnK3htbCcpIHtcbiAgICAgIC8vIG9iamVjdFt0eXBlPVwiaW1hZ2Uvc3ZnK3htbFwiXSBpcyBub3QgZm9jdXNhYmxlIGluIEludGVybmV0IEV4cGxvcmVyXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghc3VwcG9ydHMuZm9jdXNPYmplY3RTd2YgJiYgc3ZnVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJykge1xuICAgICAgLy8gb2JqZWN0W3R5cGU9XCJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaFwiXSBpcyBub3QgZm9jdXNhYmxlIGluIEludGVybmV0IEV4cGxvcmVyIDlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICdpZnJhbWUnIHx8IG5vZGVOYW1lID09PSAnb2JqZWN0Jykge1xuICAgIC8vIGJyb3dzaW5nIGNvbnRleHQgY29udGFpbmVyc1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnZW1iZWQnIHx8IG5vZGVOYW1lID09PSAna2V5Z2VuJykge1xuICAgIC8vIGVtYmVkIGlzIGNvbnNpZGVyZWQgZm9jdXMtcmVsZXZhbnQgYnV0IG5vdCBmb2N1c2FibGVcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy84MlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSkge1xuICAgIC8vIGFsc28gc2VlIENTUyBwcm9wZXJ0eSB1c2VyLW1vZGlmeSBiZWxvd1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnYXVkaW8nICYmIChzdXBwb3J0cy5mb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250cm9scycpKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndmlkZW8nICYmIChzdXBwb3J0cy5mb2N1c1ZpZGVvV2l0aG91dENvbnRyb2xzIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250cm9scycpKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHN1cHBvcnRzLmZvY3VzU3VtbWFyeSAmJiBub2RlTmFtZSA9PT0gJ3N1bW1hcnknKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgdmFsaWRUYWJpbmRleCA9ICgwLCBfdmFsaWRUYWJpbmRleDIuZGVmYXVsdCkoZWxlbWVudCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW1nJyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndXNlbWFwJykpIHtcbiAgICAvLyBHZWNrbywgVHJpZGVudCBhbmQgRWRnZSBkbyBub3QgYWxsb3cgYW4gaW1hZ2Ugd2l0aCBhbiBpbWFnZSBtYXAgYW5kIHRhYmluZGV4IHRvIGJlIGZvY3VzZWQsXG4gICAgLy8gaXQgYXBwZWFycyB0aGUgdGFiaW5kZXggaXMgb3ZlcnJ1bGVkIHNvIGZvY3VzIGlzIHN0aWxsIGZvcndhcmRlZCB0byB0aGUgPG1hcD5cbiAgICByZXR1cm4gdmFsaWRUYWJpbmRleCAmJiBzdXBwb3J0cy5mb2N1c0ltZ1VzZW1hcFRhYmluZGV4IHx8IHN1cHBvcnRzLmZvY3VzUmVkaXJlY3RJbWdVc2VtYXA7XG4gIH1cblxuICBpZiAoc3VwcG9ydHMuZm9jdXNUYWJsZSAmJiAobm9kZU5hbWUgPT09ICd0YWJsZScgfHwgbm9kZU5hbWUgPT09ICd0ZCcpKSB7XG4gICAgLy8gSUUxMC0xMSBzdXBwb3J0cy5jYW4gZm9jdXMgPHRhYmxlPiBhbmQgPHRkPlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHN1cHBvcnRzLmZvY3VzRmllbGRzZXQgJiYgbm9kZU5hbWUgPT09ICdmaWVsZHNldCcpIHtcbiAgICAvLyBJRTEwLTExIHN1cHBvcnRzLmNhbiBmb2N1cyA8ZmllbGRzZXQ+XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgaXNTdmdFbGVtZW50ID0gbm9kZU5hbWUgPT09ICdzdmcnO1xuICB2YXIgaXNTdmdDb250ZW50ID0gZWxlbWVudC5vd25lclNWR0VsZW1lbnQ7XG4gIHZhciBmb2N1c2FibGVBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZm9jdXNhYmxlJyk7XG4gIHZhciB0YWJpbmRleCA9ICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZWxlbWVudCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndXNlJyAmJiB0YWJpbmRleCAhPT0gbnVsbCAmJiAhc3VwcG9ydHMuZm9jdXNTdmdVc2VUYWJpbmRleCkge1xuICAgIC8vIDx1c2U+IGNhbm5vdCBiZSBtYWRlIGZvY3VzYWJsZSBieSBhZGRpbmcgYSB0YWJpbmRleCBhdHRyaWJ1dGUgYW55d2hlcmUgYnV0IEJsaW5rIGFuZCBXZWJLaXRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICdmb3JlaWdub2JqZWN0Jykge1xuICAgIC8vIDx1c2U+IGNhbiBvbmx5IGJlIG1hZGUgZm9jdXNhYmxlIGluIEJsaW5rIGFuZCBXZWJLaXRcbiAgICByZXR1cm4gdGFiaW5kZXggIT09IG51bGwgJiYgc3VwcG9ydHMuZm9jdXNTdmdGb3JlaWdub2JqZWN0VGFiaW5kZXg7XG4gIH1cblxuICBpZiAoKDAsIF9lbGVtZW50TWF0Y2hlczIuZGVmYXVsdCkoZWxlbWVudCwgJ3N2ZyBhJykgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKChpc1N2Z0VsZW1lbnQgfHwgaXNTdmdDb250ZW50KSAmJiBlbGVtZW50LmZvY3VzICYmICFzdXBwb3J0cy5mb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGUgJiYgdGFiaW5kZXggPCAwKSB7XG4gICAgLy8gRmlyZWZveCA1MSBhbmQgNTIgdHJlYXQgYW55IG5hdGl2ZWx5IHRhYmJhYmxlIFNWRyBlbGVtZW50IHdpdGhcbiAgICAvLyB0YWJpbmRleD1cIi0xXCIgYXMgdGFiYmFibGUgYW5kIGV2ZXJ5dGhpbmcgZWxzZSBhcyBpbmVydFxuICAgIC8vIHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzAyMzQwXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzU3ZnRWxlbWVudCkge1xuICAgIHJldHVybiB2YWxpZFRhYmluZGV4IHx8IHN1cHBvcnRzLmZvY3VzU3ZnIHx8IHN1cHBvcnRzLmZvY3VzU3ZnSW5JZnJhbWVcbiAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciB1bmRlcnN0YW5kcyB0aGUgZm9jdXNhYmxlIGF0dHJpYnV0ZSBpbnRyb2R1Y2VkIGluIFNWRyBUaW55IDEuMlxuICAgIHx8IEJvb2xlYW4oc3VwcG9ydHMuZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUgJiYgZm9jdXNhYmxlQXR0cmlidXRlICYmIGZvY3VzYWJsZUF0dHJpYnV0ZSA9PT0gJ3RydWUnKTtcbiAgfVxuXG4gIGlmIChpc1N2Z0NvbnRlbnQpIHtcbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZSAmJiB2YWxpZFRhYmluZGV4KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNTdmdGb2N1c2FibGVBdHRyaWJ1dGUpIHtcbiAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIHVuZGVyc3RhbmRzIHRoZSBmb2N1c2FibGUgYXR0cmlidXRlIGludHJvZHVjZWQgaW4gU1ZHIFRpbnkgMS4yXG4gICAgICByZXR1cm4gZm9jdXNhYmxlQXR0cmlidXRlID09PSAndHJ1ZSc7XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNzZXF1ZW50aWFsLWZvY3VzLW5hdmlnYXRpb24tYW5kLXRoZS10YWJpbmRleC1hdHRyaWJ1dGVcbiAgaWYgKHZhbGlkVGFiaW5kZXgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICBpZiAoKDAsIF9pcy5pc1VzZXJNb2RpZnlXcml0YWJsZSkoc3R5bGUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc3VwcG9ydHMuZm9jdXNJbWdJc21hcCAmJiBub2RlTmFtZSA9PT0gJ2ltZycgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2lzbWFwJykpIHtcbiAgICAvLyBJRTEwLTExIGNvbnNpZGVycyB0aGUgPGltZz4gaW4gPGEgaHJlZj48aW1nIGlzbWFwPiBmb2N1c2FibGVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIwXG4gICAgdmFyIGhhc0xpbmtQYXJlbnQgPSAoMCwgX3BhcmVudHMyLmRlZmF1bHQpKHsgY29udGV4dDogZWxlbWVudCB9KS5zb21lKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgIHJldHVybiBwYXJlbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnICYmIHBhcmVudC5oYXNBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICB9KTtcblxuICAgIGlmIChoYXNMaW5rUGFyZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXG4gIGlmICghZXhjZXB0LnNjcm9sbGFibGUgJiYgc3VwcG9ydHMuZm9jdXNTY3JvbGxDb250YWluZXIpIHtcbiAgICBpZiAoc3VwcG9ydHMuZm9jdXNTY3JvbGxDb250YWluZXJXaXRob3V0T3ZlcmZsb3cpIHtcbiAgICAgIC8vIEludGVybmV0IEV4cGxvcmVyIGRvZXMgd2lsbCBjb25zaWRlciB0aGUgc2Nyb2xsYWJsZSBhcmVhIGZvY3VzYWJsZVxuICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaXMgYSA8ZGl2PiBvciBhIDxzcGFuPiBhbmQgaXQgaXMgaW4gZmFjdCBzY3JvbGxhYmxlLFxuICAgICAgLy8gcmVnYXJkbGVzcyBvZiB0aGUgQ1NTIG92ZXJmbG93IHByb3BlcnR5XG4gICAgICBpZiAoKDAsIF9pcy5pc1Njcm9sbGFibGVDb250YWluZXIpKGVsZW1lbnQsIG5vZGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCgwLCBfaXMuaGFzQ3NzT3ZlcmZsb3dTY3JvbGwpKHN0eWxlKSkge1xuICAgICAgLy8gRmlyZWZveCByZXF1aXJlcyBwcm9wZXIgb3ZlcmZsb3cgc2V0dGluZywgSUUgZG9lcyBub3QgbmVjZXNzYXJpbHlcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9vdmVyZmxvd1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFleGNlcHQuZmxleGJveCAmJiBzdXBwb3J0cy5mb2N1c0ZsZXhib3hDb250YWluZXIgJiYgKDAsIF9pcy5oYXNDc3NEaXNwbGF5RmxleCkoc3R5bGUpKSB7XG4gICAgLy8gZWxlbWVudHMgd2l0aCBkaXNwbGF5OmZsZXggYXJlIGZvY3VzYWJsZSBpbiBJRTEwLTExXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICBpZiAoIWV4Y2VwdC5zY3JvbGxhYmxlICYmIHBhcmVudCkge1xuICAgIHZhciBwYXJlbnROb2RlTmFtZSA9IHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBwYXJlbnRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCwgbnVsbCk7XG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzU2Nyb2xsQm9keSAmJiAoMCwgX2lzLmlzU2Nyb2xsYWJsZUNvbnRhaW5lcikocGFyZW50LCBub2RlTmFtZSwgcGFyZW50Tm9kZU5hbWUsIHBhcmVudFN0eWxlKSkge1xuICAgICAgLy8gc2Nyb2xsYWJsZSBib2RpZXMgYXJlIGZvY3VzYWJsZSBJbnRlcm5ldCBFeHBsb3JlclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hpbGRyZW4gb2YgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGggZGlzcGxheTpmbGV4IGFyZSBmb2N1c2FibGUgaW4gSUUxMC0xMVxuICAgIGlmIChzdXBwb3J0cy5mb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94KSB7XG4gICAgICBpZiAoKDAsIF9pcy5oYXNDc3NEaXNwbGF5RmxleCkocGFyZW50U3R5bGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE5PVEU6IGVsZW1lbnRzIG1hcmtlZCBhcyBpbmVydCBhcmUgbm90IGZvY3VzYWJsZSxcbiAgLy8gYnV0IHRoYXQgcHJvcGVydHkgaXMgbm90IGV4cG9zZWQgdG8gdGhlIERPTVxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZWRpdGluZy5odG1sI2luZXJ0XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBiaW5kIGV4Y2VwdGlvbnMgdG8gYW4gaXRlcmF0b3IgY2FsbGJhY2tcbmlzRm9jdXNSZWxldmFudFJ1bGVzLmV4Y2VwdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGV4Y2VwdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgdmFyIGlzRm9jdXNSZWxldmFudCA9IGZ1bmN0aW9uIGlzRm9jdXNSZWxldmFudChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGlzRm9jdXNSZWxldmFudFJ1bGVzKHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBleGNlcHQ6IGV4Y2VwdFxuICAgIH0pO1xuICB9O1xuXG4gIGlzRm9jdXNSZWxldmFudC5ydWxlcyA9IGlzRm9jdXNSZWxldmFudFJ1bGVzO1xuICByZXR1cm4gaXNGb2N1c1JlbGV2YW50O1xufTtcblxuLy8gcHJvdmlkZSBpc0ZvY3VzUmVsZXZhbnQoY29udGV4dCkgYXMgZGVmYXVsdCBpdGVyYXRvciBjYWxsYmFja1xudmFyIGlzRm9jdXNSZWxldmFudCA9IGlzRm9jdXNSZWxldmFudFJ1bGVzLmV4Y2VwdCh7fSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0ZvY3VzUmVsZXZhbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXJlbGV2YW50LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9mb2N1c1JlbGV2YW50ID0gcmVxdWlyZSgnLi9mb2N1cy1yZWxldmFudCcpO1xuXG52YXIgX2ZvY3VzUmVsZXZhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNSZWxldmFudCk7XG5cbnZhciBfdmFsaWRBcmVhID0gcmVxdWlyZSgnLi92YWxpZC1hcmVhJyk7XG5cbnZhciBfdmFsaWRBcmVhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbGlkQXJlYSk7XG5cbnZhciBfdmlzaWJsZSA9IHJlcXVpcmUoJy4vdmlzaWJsZScpO1xuXG52YXIgX3Zpc2libGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlzaWJsZSk7XG5cbnZhciBfZGlzYWJsZWQgPSByZXF1aXJlKCcuL2Rpc2FibGVkJyk7XG5cbnZhciBfZGlzYWJsZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGlzYWJsZWQpO1xuXG52YXIgX29ubHlUYWJiYWJsZSA9IHJlcXVpcmUoJy4vb25seS10YWJiYWJsZScpO1xuXG52YXIgX29ubHlUYWJiYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vbmx5VGFiYmFibGUpO1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XG5cbnZhciBfZ2V0RnJhbWVFbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9nZXQtZnJhbWUtZWxlbWVudCcpO1xuXG52YXIgX2dldEZyYW1lRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRGcmFtZUVsZW1lbnQpO1xuXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XG5cbnZhciBfdGFiaW5kZXhWYWx1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJpbmRleFZhbHVlKTtcblxudmFyIF9zdXBwb3J0czIgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9zdXBwb3J0cycpO1xuXG52YXIgX3N1cHBvcnRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcbi8vIGRldGVybWluZSBpZiBhbiBlbGVtZW50IGNhbiBiZSBmb2N1c2VkXG5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjZm9jdXMtbWFuYWdlbWVudFxuXG4vLyBOT1RFOiBUaGUgZm9sbG93aW5nIGtub3duIGlzc3VlcyBleGlzdDpcbi8vICAgR2Vja286IGBzdmcgYVt4bGlua3xocmVmXWAgaXMgbm90IGlkZW50aWZpZWQgYXMgZm9jdXNhYmxlIChiZWNhdXNlIFNWR0VsZW1lbnQucHJvdG90eXBlLmZvY3VzIGlzIG1pc3NpbmcpXG4vLyAgIEJsaW5rLCBXZWJLaXQ6IFNWR0VsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIG1hZGUgZm9jdXNhYmxlIGJ5IGFkZGluZyBhIGZvY3VzIGV2ZW50IGxpc3RlbmVyIGFyZSBub3QgaWRlbnRpZmllZCBhcyBmb2N1c2FibGVcblxuZnVuY3Rpb24gaXNPbmx5Rm9jdXNSZWxldmFudChlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKG5vZGVOYW1lID09PSAnZW1iZWQnIHx8IG5vZGVOYW1lID09PSAna2V5Z2VuJykge1xuICAgIC8vIGVtYmVkIGlzIGNvbnNpZGVyZWQgZm9jdXMtcmVsZXZhbnQgYnV0IG5vdCBmb2N1c2FibGVcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy84MlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIF90YWJpbmRleCA9ICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZWxlbWVudCk7XG4gIGlmIChlbGVtZW50LnNoYWRvd1Jvb3QgJiYgX3RhYmluZGV4ID09PSBudWxsKSB7XG4gICAgLy8gU2hhZG93RE9NIGhvc3QgZWxlbWVudHMgKm1heSogcmVjZWl2ZSBmb2N1c1xuICAgIC8vIGV2ZW4gdGhvdWdoIHRoZXkgYXJlIG5vdCBjb25zaWRlcmVkIGZvY3VhYmxlXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICdsYWJlbCcpIHtcbiAgICAvLyA8bGFiZWwgdGFiaW5kZXg9XCIwXCI+IGlzIG9ubHkgdGFiYmFibGUgaW4gRmlyZWZveCwgbm90IHNjcmlwdC1mb2N1c2FibGVcbiAgICAvLyB0aGVyZSdzIG5vIHdheSB0byBtYWtlIGFuIGVsZW1lbnQgZm9jdXNhYmxlIG90aGVyIHRoYW4gYnkgYWRkaW5nIGEgdGFiaW5kZXgsXG4gICAgLy8gYW5kIGZvY3VzIGJlaGF2aW9yIG9mIHRoZSBsYWJlbCBlbGVtZW50IHNlZW1zIGhhcmQtd2lyZWQgdG8gaWdub3JlIHRhYmluZGV4XG4gICAgLy8gaW4gc29tZSBicm93c2VycyAobGlrZSBHZWNrbywgQmxpbmsgYW5kIFdlYktpdClcbiAgICByZXR1cm4gIXN1cHBvcnRzLmZvY3VzTGFiZWxUYWJpbmRleCB8fCBfdGFiaW5kZXggPT09IG51bGw7XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICdsZWdlbmQnKSB7XG4gICAgcmV0dXJuIF90YWJpbmRleCA9PT0gbnVsbDtcbiAgfVxuXG4gIGlmIChzdXBwb3J0cy5mb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZSAmJiAoZWxlbWVudC5vd25lclNWR0VsZW1lbnQgfHwgbm9kZU5hbWUgPT09ICdzdmcnKSkge1xuICAgIC8vIEludGVybmV0IEV4cGxvcmVyIHVuZGVyc3RhbmRzIHRoZSBmb2N1c2FibGUgYXR0cmlidXRlIGludHJvZHVjZWQgaW4gU1ZHIFRpbnkgMS4yXG4gICAgdmFyIGZvY3VzYWJsZUF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmb2N1c2FibGUnKTtcbiAgICByZXR1cm4gZm9jdXNhYmxlQXR0cmlidXRlICYmIGZvY3VzYWJsZUF0dHJpYnV0ZSA9PT0gJ2ZhbHNlJztcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2ltZycgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3VzZW1hcCcpKSB7XG4gICAgLy8gR2Vja28sIFRyaWRlbnQgYW5kIEVkZ2UgZG8gbm90IGFsbG93IGFuIGltYWdlIHdpdGggYW4gaW1hZ2UgbWFwIGFuZCB0YWJpbmRleCB0byBiZSBmb2N1c2VkLFxuICAgIC8vIGl0IGFwcGVhcnMgdGhlIHRhYmluZGV4IGlzIG92ZXJydWxlZCBzbyBmb2N1cyBpcyBzdGlsbCBmb3J3YXJkZWQgdG8gdGhlIDxtYXA+XG4gICAgcmV0dXJuIF90YWJpbmRleCA9PT0gbnVsbCB8fCAhc3VwcG9ydHMuZm9jdXNJbWdVc2VtYXBUYWJpbmRleDtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2FyZWEnKSB7XG4gICAgLy8gYWxsIDxhcmVhPnMgYXJlIGNvbnNpZGVyZWQgcmVsZXZhbnQsXG4gICAgLy8gYnV0IG9ubHkgdGhlIHZhbGlkIDxhcmVhPnMgYXJlIGZvY3VzYWJsZVxuICAgIHJldHVybiAhKDAsIF92YWxpZEFyZWEyLmRlZmF1bHQpKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0ZvY3VzYWJsZVJ1bGVzKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgX3JlZiRleGNlcHQgPSBfcmVmLmV4Y2VwdCxcbiAgICAgIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWQgPyB7XG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIHZpc2libGU6IGZhbHNlLFxuICAgIG9ubHlUYWJiYWJsZTogZmFsc2VcbiAgfSA6IF9yZWYkZXhjZXB0O1xuXG4gIGlmICghc3VwcG9ydHMpIHtcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XG4gIH1cblxuICB2YXIgX2lzT25seVRhYmJhYmxlID0gX29ubHlUYWJiYWJsZTIuZGVmYXVsdC5ydWxlcy5leGNlcHQoe1xuICAgIG9ubHlGb2N1c2FibGVCcm93c2luZ0NvbnRleHQ6IHRydWUsXG4gICAgdmlzaWJsZTogZXhjZXB0LnZpc2libGVcbiAgfSk7XG5cbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcbiAgICBsYWJlbDogJ2lzL2ZvY3VzYWJsZScsXG4gICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfSk7XG5cbiAgdmFyIGZvY3VzUmVsZXZhbnQgPSBfZm9jdXNSZWxldmFudDIuZGVmYXVsdC5ydWxlcyh7XG4gICAgY29udGV4dDogZWxlbWVudCxcbiAgICBleGNlcHQ6IGV4Y2VwdFxuICB9KTtcblxuICBpZiAoIWZvY3VzUmVsZXZhbnQgfHwgaXNPbmx5Rm9jdXNSZWxldmFudChlbGVtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghZXhjZXB0LmRpc2FibGVkICYmICgwLCBfZGlzYWJsZWQyLmRlZmF1bHQpKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFleGNlcHQub25seVRhYmJhYmxlICYmIF9pc09ubHlUYWJiYWJsZShlbGVtZW50KSkge1xuICAgIC8vIHNvbWUgZWxlbWVudHMgbWF5IGJlIGtleWJvYXJkIGZvY3VzYWJsZSwgYnV0IG5vdCBzY3JpcHQgZm9jdXNhYmxlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbm90IHJlbmRlcmVkLCBjYW5ub3QgYmUgZm9jdXNlZFxuICBpZiAoIWV4Y2VwdC52aXNpYmxlKSB7XG4gICAgdmFyIHZpc2liaWxpdHlPcHRpb25zID0ge1xuICAgICAgY29udGV4dDogZWxlbWVudCxcbiAgICAgIGV4Y2VwdDoge31cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzSW5IaWRkZW5JZnJhbWUpIHtcbiAgICAgIC8vIFdlYktpdCBhbmQgQmxpbmsgY2FuIGZvY3VzIGNvbnRlbnQgaW4gaGlkZGVuIDxpZnJhbWU+IGFuZCA8b2JqZWN0PlxuICAgICAgdmlzaWJpbGl0eU9wdGlvbnMuZXhjZXB0LmJyb3dzaW5nQ29udGV4dCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzLmZvY3VzT2JqZWN0U3ZnSGlkZGVuKSB7XG4gICAgICAvLyBCbGluayBhbGxvd3MgZm9jdXNpbmcgdGhlIG9iamVjdCBlbGVtZW50LCBldmVuIGlmIGl0IGhhcyB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgICAvLyBAYnJvd3Nlci1pc3N1ZSBCbGluayBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg2MTkxXG4gICAgICB2YXIgX25vZGVOYW1lMiA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChfbm9kZU5hbWUyID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2aXNpYmlsaXR5T3B0aW9ucy5leGNlcHQuY3NzVmlzaWJpbGl0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFfdmlzaWJsZTIuZGVmYXVsdC5ydWxlcyh2aXNpYmlsaXR5T3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZnJhbWVFbGVtZW50ID0gKDAsIF9nZXRGcmFtZUVsZW1lbnQyLmRlZmF1bHQpKGVsZW1lbnQpO1xuICBpZiAoZnJhbWVFbGVtZW50KSB7XG4gICAgdmFyIF9ub2RlTmFtZSA9IGZyYW1lRWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChfbm9kZU5hbWUgPT09ICdvYmplY3QnICYmICFzdXBwb3J0cy5mb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdCkge1xuICAgICAgaWYgKCFmcmFtZUVsZW1lbnQub2Zmc2V0V2lkdGggfHwgIWZyYW1lRWxlbWVudC5vZmZzZXRIZWlnaHQpIHtcbiAgICAgICAgLy8gV2ViS2l0IGNhbiBub3QgZm9jdXMgY29udGVudCBpbiA8b2JqZWN0PiBpZiBpdCBkb2Vzbid0IGhhdmUgZGltZW5zaW9uc1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAobm9kZU5hbWUgPT09ICdzdmcnICYmIHN1cHBvcnRzLmZvY3VzU3ZnSW5JZnJhbWUgJiYgIWZyYW1lRWxlbWVudCAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBiaW5kIGV4Y2VwdGlvbnMgdG8gYW4gaXRlcmF0b3IgY2FsbGJhY2tcbmlzRm9jdXNhYmxlUnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXhjZXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgaXNGb2N1c2FibGUgPSBmdW5jdGlvbiBpc0ZvY3VzYWJsZShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGlzRm9jdXNhYmxlUnVsZXMoe1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgfSk7XG4gIH07XG5cbiAgaXNGb2N1c2FibGUucnVsZXMgPSBpc0ZvY3VzYWJsZVJ1bGVzO1xuICByZXR1cm4gaXNGb2N1c2FibGU7XG59O1xuXG4vLyBwcm92aWRlIGlzRm9jdXNSZWxldmFudChjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXG52YXIgaXNGb2N1c2FibGUgPSBpc0ZvY3VzYWJsZVJ1bGVzLmV4Y2VwdCh7fSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0ZvY3VzYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXNhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNVc2VyTW9kaWZ5V3JpdGFibGUgPSBpc1VzZXJNb2RpZnlXcml0YWJsZTtcbmV4cG9ydHMuaGFzQ3NzT3ZlcmZsb3dTY3JvbGwgPSBoYXNDc3NPdmVyZmxvd1Njcm9sbDtcbmV4cG9ydHMuaGFzQ3NzRGlzcGxheUZsZXggPSBoYXNDc3NEaXNwbGF5RmxleDtcbmV4cG9ydHMuaXNTY3JvbGxhYmxlQ29udGFpbmVyID0gaXNTY3JvbGxhYmxlQ29udGFpbmVyO1xuXG4vLyB0aGlzIGlzIGEgc2hhcmVkIHV0aWxpdHkgZmlsZSBmb3IgZm9jdXMtcmVsZXZhbnQuanMgYW5kIHRhYmJhYmxlLmpzXG4vLyBzZXBhcmF0ZSB0ZXN0aW5nIG9mIHRoaXMgZmlsZSdzIGZ1bmN0aW9ucyBpcyBub3QgbmVjZXNzYXJ5LFxuLy8gYXMgdGhleSdyZSBpbXBsaWNpdGx5IHRlc3RlZCBieSB3YXkgb2YgdGhlIGNvbnN1bWVyc1xuXG5mdW5jdGlvbiBpc1VzZXJNb2RpZnlXcml0YWJsZShzdHlsZSkge1xuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9XRC1jc3MzLXVzZXJpbnQtMTk5OTA5MTYjdXNlci1tb2RpZnlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8xN1xuICB2YXIgdXNlck1vZGlmeSA9IHN0eWxlLndlYmtpdFVzZXJNb2RpZnkgfHwgJyc7XG4gIHJldHVybiBCb29sZWFuKHVzZXJNb2RpZnkgJiYgdXNlck1vZGlmeS5pbmRleE9mKCd3cml0ZScpICE9PSAtMSk7XG59XG5cbmZ1bmN0aW9uIGhhc0Nzc092ZXJmbG93U2Nyb2xsKHN0eWxlKSB7XG4gIHJldHVybiBbc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cnKSwgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnb3ZlcmZsb3cteCcpLCBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdy15JyldLnNvbWUoZnVuY3Rpb24gKG92ZXJmbG93KSB7XG4gICAgcmV0dXJuIG92ZXJmbG93ID09PSAnYXV0bycgfHwgb3ZlcmZsb3cgPT09ICdzY3JvbGwnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGFzQ3NzRGlzcGxheUZsZXgoc3R5bGUpIHtcbiAgcmV0dXJuIHN0eWxlLmRpc3BsYXkuaW5kZXhPZignZmxleCcpID4gLTE7XG59XG5cbmZ1bmN0aW9uIGlzU2Nyb2xsYWJsZUNvbnRhaW5lcihlbGVtZW50LCBub2RlTmFtZSwgcGFyZW50Tm9kZU5hbWUsIHBhcmVudFN0eWxlKSB7XG4gIGlmIChub2RlTmFtZSAhPT0gJ2RpdicgJiYgbm9kZU5hbWUgIT09ICdzcGFuJykge1xuICAgIC8vIEludGVybmV0IEV4cGxvcmVyIGFkdmFuY2VzIHNjcm9sbGFibGUgY29udGFpbmVycyBhbmQgYm9kaWVzIHRvIGZvY3VzYWJsZVxuICAgIC8vIG9ubHkgaWYgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGlzIDxkaXY+IG9yIDxzcGFuPiAtIHRoaXMgZG9lcyAqbm90KlxuICAgIC8vIGhhcHBlbiBmb3IgPHNlY3Rpb24+LCA8YXJ0aWNsZT4sIOKAplxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwYXJlbnROb2RlTmFtZSAmJiBwYXJlbnROb2RlTmFtZSAhPT0gJ2RpdicgJiYgcGFyZW50Tm9kZU5hbWUgIT09ICdzcGFuJyAmJiAhaGFzQ3NzT3ZlcmZsb3dTY3JvbGwocGFyZW50U3R5bGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDwgZWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgZWxlbWVudC5vZmZzZXRXaWR0aCA8IGVsZW1lbnQuc2Nyb2xsV2lkdGg7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy51dGlsLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgaWYgKCFzdXBwb3J0cykge1xuICAgIHN1cHBvcnRzID0gKDAsIF9zdXBwb3J0czMuZGVmYXVsdCkoKTtcblxuICAgIGlmIChzdXBwb3J0cy5mb2N1c0ZpZWxkc2V0RGlzYWJsZWQpIHtcbiAgICAgIGRlbGV0ZSBkaXNhYmxlZEVsZW1lbnRzLmZpZWxkc2V0O1xuICAgIH1cblxuICAgIGlmIChzdXBwb3J0cy5mb2N1c0Zvcm1EaXNhYmxlZCkge1xuICAgICAgZGVsZXRlIGRpc2FibGVkRWxlbWVudHMuZm9ybTtcbiAgICB9XG5cbiAgICBkaXNhYmxlZEVsZW1lbnRzUGF0dGVybiA9IG5ldyBSZWdFeHAoJ14oJyArIE9iamVjdC5rZXlzKGRpc2FibGVkRWxlbWVudHMpLmpvaW4oJ3wnKSArICcpJCcpO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcbiAgICBsYWJlbDogJ2lzL25hdGl2ZS1kaXNhYmxlZC1zdXBwb3J0ZWQnLFxuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfSk7XG5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gQm9vbGVhbihkaXNhYmxlZEVsZW1lbnRzUGF0dGVybi50ZXN0KG5vZGVOYW1lKSk7XG59O1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XG5cbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcblxudmFyIF9zdXBwb3J0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0czIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBEZXRlcm1pbmUgaWYgYW4gZWxlbWVudCBzdXBwb3J0cyB0aGUgZGlzYWJsZWQgYXR0cmlidXRlXG5cbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Rpc2FibGVkLWVsZW1lbnRzLmh0bWwjY29uY2VwdC1lbGVtZW50LWRpc2FibGVkXG52YXIgZGlzYWJsZWRFbGVtZW50c1BhdHRlcm4gPSB2b2lkIDA7XG52YXIgZGlzYWJsZWRFbGVtZW50cyA9IHtcbiAgaW5wdXQ6IHRydWUsXG4gIHNlbGVjdDogdHJ1ZSxcbiAgdGV4dGFyZWE6IHRydWUsXG4gIGJ1dHRvbjogdHJ1ZSxcbiAgZmllbGRzZXQ6IHRydWUsXG4gIGZvcm06IHRydWVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF0aXZlLWRpc2FibGVkLXN1cHBvcnRlZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdmlzaWJsZSA9IHJlcXVpcmUoJy4vdmlzaWJsZScpO1xuXG52YXIgX3Zpc2libGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlzaWJsZSk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcblxudmFyIF9nZXRGcmFtZUVsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2dldC1mcmFtZS1lbGVtZW50Jyk7XG5cbnZhciBfZ2V0RnJhbWVFbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEZyYW1lRWxlbWVudCk7XG5cbnZhciBfdGFiaW5kZXhWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWwvdGFiaW5kZXgtdmFsdWUnKTtcblxudmFyIF90YWJpbmRleFZhbHVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmluZGV4VmFsdWUpO1xuXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xuXG52YXIgX3BsYXRmb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYXRmb3JtKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNPbmx5VGFiYmFibGVSdWxlcygpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICAgIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsXG4gICAgICBleGNlcHQgPSBfcmVmJGV4Y2VwdCA9PT0gdW5kZWZpbmVkID8ge1xuICAgIG9ubHlGb2N1c2FibGVCcm93c2luZ0NvbnRleHQ6IGZhbHNlLFxuICAgIHZpc2libGU6IGZhbHNlXG4gIH0gOiBfcmVmJGV4Y2VwdDtcblxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAnaXMvb25seS10YWJiYWJsZScsXG4gICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfSk7XG5cbiAgaWYgKCFleGNlcHQudmlzaWJsZSAmJiAhKDAsIF92aXNpYmxlMi5kZWZhdWx0KShlbGVtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghZXhjZXB0Lm9ubHlGb2N1c2FibGVCcm93c2luZ0NvbnRleHQgJiYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTyB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuVFJJREVOVCB8fCBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuRURHRSkpIHtcbiAgICB2YXIgZnJhbWVFbGVtZW50ID0gKDAsIF9nZXRGcmFtZUVsZW1lbnQyLmRlZmF1bHQpKGVsZW1lbnQpO1xuICAgIGlmIChmcmFtZUVsZW1lbnQpIHtcbiAgICAgIGlmICgoMCwgX3RhYmluZGV4VmFsdWUyLmRlZmF1bHQpKGZyYW1lRWxlbWVudCkgPCAwKSB7XG4gICAgICAgIC8vIGlmcmFtZVt0YWJpbmRleD1cIi0xXCJdIGFuZCBvYmplY3RbdGFiaW5kZXg9XCItMVwiXSBpbmhlcml0IHRoZVxuICAgICAgICAvLyB0YWJiYWJsZSBkZW1vdGlvbiBvbnRvIGVsZW1lbnRzIG9mIHRoZWlyIGJyb3dzaW5nIGNvbnRleHRzXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHZhciB0YWJpbmRleCA9ICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZWxlbWVudCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnbGFiZWwnICYmIF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTykge1xuICAgIC8vIEZpcmVmb3ggY2Fubm90IGZvY3VzLCBidXQgdGFiIHRvOiBsYWJlbFt0YWJpbmRleD0wXVxuICAgIHJldHVybiB0YWJpbmRleCAhPT0gbnVsbCAmJiB0YWJpbmRleCA+PSAwO1xuICB9XG5cbiAgLy8gU1ZHIEVsZW1lbnRzIHdlcmUga2V5Ym9hcmQgZm9jdXNhYmxlIGJ1dCBub3Qgc2NyaXB0IGZvY3VzYWJsZSBiZWZvcmUgRmlyZWZveCA1MS5cbiAgLy8gRmlyZWZveCA1MSBhZGRlZCB0aGUgZm9jdXMgbWFuYWdlbWVudCBET00gQVBJICguZm9jdXMgYW5kIC5ibHVyKSB0byBTVkdFbGVtZW50LFxuICAvLyBzZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Nzc4NjU0XG4gIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08gJiYgZWxlbWVudC5vd25lclNWR0VsZW1lbnQgJiYgIWVsZW1lbnQuZm9jdXMpIHtcbiAgICBpZiAobm9kZU5hbWUgPT09ICdhJyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgneGxpbms6aHJlZicpKSB7XG4gICAgICAvLyBhbnkgZm9jdXNhYmxlIGNoaWxkIG9mIDxzdmc+IGNhbm5vdCBiZSBmb2N1c2VkLCBidXQgdGFiYmVkIHRvXG4gICAgICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gYmluZCBleGNlcHRpb25zIHRvIGFuIGl0ZXJhdG9yIGNhbGxiYWNrXG5pc09ubHlUYWJiYWJsZVJ1bGVzLmV4Y2VwdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGV4Y2VwdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgdmFyIGlzT25seVRhYmJhYmxlID0gZnVuY3Rpb24gaXNPbmx5VGFiYmFibGUoY29udGV4dCkge1xuICAgIHJldHVybiBpc09ubHlUYWJiYWJsZVJ1bGVzKHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBleGNlcHQ6IGV4Y2VwdFxuICAgIH0pO1xuICB9O1xuXG4gIGlzT25seVRhYmJhYmxlLnJ1bGVzID0gaXNPbmx5VGFiYmFibGVSdWxlcztcbiAgcmV0dXJuIGlzT25seVRhYmJhYmxlO1xufTtcblxuLy8gcHJvdmlkZSBpc09ubHlUYWJiYWJsZShjb250ZXh0KSBhcyBkZWZhdWx0IGl0ZXJhdG9yIGNhbGxiYWNrXG52YXIgaXNPbmx5VGFiYmFibGUgPSBpc09ubHlUYWJiYWJsZVJ1bGVzLmV4Y2VwdCh7fSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc09ubHlUYWJiYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b25seS10YWJiYWJsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdmlzaWJsZSA9IHJlcXVpcmUoJy4vdmlzaWJsZScpO1xuXG52YXIgX3Zpc2libGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlzaWJsZSk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcblxudmFyIF9lbGVtZW50TWF0Y2hlcyA9IHJlcXVpcmUoJy4uL3V0aWwvZWxlbWVudC1tYXRjaGVzJyk7XG5cbnZhciBfZWxlbWVudE1hdGNoZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZWxlbWVudE1hdGNoZXMpO1xuXG52YXIgX3RhYmluZGV4VmFsdWUgPSByZXF1aXJlKCcuLi91dGlsL3RhYmluZGV4LXZhbHVlJyk7XG5cbnZhciBfdGFiaW5kZXhWYWx1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJpbmRleFZhbHVlKTtcblxudmFyIF9mb2N1c1JlbGV2YW50ID0gcmVxdWlyZSgnLi9mb2N1cy1yZWxldmFudCcpO1xuXG52YXIgX2ZvY3VzUmVsZXZhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNSZWxldmFudCk7XG5cbnZhciBfZ2V0RnJhbWVFbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9nZXQtZnJhbWUtZWxlbWVudCcpO1xuXG52YXIgX2dldEZyYW1lRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRGcmFtZUVsZW1lbnQpO1xuXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xuXG52YXIgX3BsYXRmb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYXRmb3JtKTtcblxudmFyIF9pbWFnZU1hcCA9IHJlcXVpcmUoJy4uL3V0aWwvaW1hZ2UtbWFwJyk7XG5cbnZhciBfaXMgPSByZXF1aXJlKCcuL2lzLnV0aWwnKTtcblxudmFyIF9zdXBwb3J0czIgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9zdXBwb3J0cycpO1xuXG52YXIgX3N1cHBvcnRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGRldGVybWluZSBpZiBhbiBlbGVtZW50IGNhbiBiZSBmb2N1c2VkIGJ5IGtleWJvYXJkIChpLmUuIGlzIHBhcnQgb2YgdGhlIGRvY3VtZW50J3Mgc2VxdWVudGlhbCBmb2N1cyBuYXZpZ2F0aW9uIG9yZGVyKVxuXG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XG5cbi8vIEludGVybmV0IEV4cGxvcmVyIDExIGNvbnNpZGVycyBmaWVsZHNldCwgdGFibGUsIHRkIGZvY3VzYWJsZSwgYnV0IG5vdCB0YWJiYWJsZVxuLy8gSW50ZXJuZXQgRXhwbG9yZXIgMTEgY29uc2lkZXJzIGJvZHkgdG8gaGF2ZSBbdGFiaW5kZXg9MF0sIGJ1dCBkb2VzIG5vdCBhbGxvdyB0YWJiaW5nIHRvIGl0XG52YXIgZm9jdXNhYmxlRWxlbWVudHNQYXR0ZXJuID0gL14oZmllbGRzZXR8dGFibGV8dGR8Ym9keSkkLztcblxuZnVuY3Rpb24gaXNUYWJiYWJsZVJ1bGVzKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgX3JlZiRleGNlcHQgPSBfcmVmLmV4Y2VwdCxcbiAgICAgIGV4Y2VwdCA9IF9yZWYkZXhjZXB0ID09PSB1bmRlZmluZWQgPyB7XG4gICAgZmxleGJveDogZmFsc2UsXG4gICAgc2Nyb2xsYWJsZTogZmFsc2UsXG4gICAgc2hhZG93OiBmYWxzZSxcbiAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICBvbmx5VGFiYmFibGU6IGZhbHNlXG4gIH0gOiBfcmVmJGV4Y2VwdDtcblxuICBpZiAoIXN1cHBvcnRzKSB7XG4gICAgc3VwcG9ydHMgPSAoMCwgX3N1cHBvcnRzMy5kZWZhdWx0KSgpO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcbiAgICBsYWJlbDogJ2lzL3RhYmJhYmxlJyxcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9KTtcblxuICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkJMSU5LICYmIF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5BTkRST0lEICYmIF9wbGF0Zm9ybTIuZGVmYXVsdC5tYWpvclZlcnNpb24gPiA0Mikge1xuICAgIC8vIEV4dGVybmFsIGtleWJvYXJkIHN1cHBvcnQgd29ya2VkIGZpbmUgaW4gQ0hyb21lIDQyLCBidXQgc3RvcHBlZCB3b3JraW5nIGluIENocm9tZSA0NS5cbiAgICAvLyBUaGUgb24tc2NyZWVuIGtleWJvYXJkIGRvZXMgbm90IHByb3ZpZGUgYSB3YXkgdG8gZm9jdXMgdGhlIG5leHQgaW5wdXQgZWxlbWVudCAobGlrZSBpT1MgZG9lcykuXG4gICAgLy8gVGhhdCBsZWF2ZXMgdXMgd2l0aCBubyBvcHRpb24gdG8gYWR2YW5jZSBmb2N1cyBieSBrZXlib2FyZCwgZXJnbyBub3RoaW5nIGlzIHRhYmJhYmxlIChrZXlib2FyZCBmb2N1c2FibGUpLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBmcmFtZUVsZW1lbnQgPSAoMCwgX2dldEZyYW1lRWxlbWVudDIuZGVmYXVsdCkoZWxlbWVudCk7XG4gIGlmIChmcmFtZUVsZW1lbnQpIHtcbiAgICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLldFQktJVCAmJiBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuSU9TKSB7XG4gICAgICAvLyBpT1Mgb25seSBkb2VzIG5vdCBjb25zaWRlciBhbnl0aGluZyBmcm9tIGFub3RoZXIgYnJvd3NpbmcgY29udGV4dCBrZXlib2FyZCBmb2N1c2FibGVcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBpZnJhbWVbdGFiaW5kZXg9XCItMVwiXSBhbmQgb2JqZWN0W3RhYmluZGV4PVwiLTFcIl0gaW5oZXJpdCB0aGVcbiAgICAvLyB0YWJiYWJsZSBkZW1vdGlvbiBvbnRvIGVsZW1lbnRzIG9mIHRoZWlyIGJyb3dzaW5nIGNvbnRleHRzXG4gICAgaWYgKCgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZnJhbWVFbGVtZW50KSA8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWV4Y2VwdC52aXNpYmxlICYmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuQkxJTksgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLldFQktJVCkgJiYgISgwLCBfdmlzaWJsZTIuZGVmYXVsdCkoZnJhbWVFbGVtZW50KSkge1xuICAgICAgLy8gQmxpbmsgYW5kIFdlYktpdCBjb25zaWRlciBlbGVtZW50cyBpbiBoaWRkZW4gYnJvd3NpbmcgY29udGV4dHMgZm9jdXNhYmxlLCBidXQgbm90IHRhYmJhYmxlXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gV2Via2l0IGFuZCBCbGluayBkb24ndCBjb25zaWRlciBhbnl0aGluZyBpbiA8b2JqZWN0PiB0YWJiYWJsZVxuICAgIC8vIEJsaW5rIGZpeGVkIHRoYXQgZml4ZWQgaW4gQ2hyb21lIDU0LCBPcGVyYSA0MVxuICAgIHZhciBmcmFtZU5vZGVOYW1lID0gZnJhbWVFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGZyYW1lTm9kZU5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgaXNGaXhlZEJsaW5rID0gX3BsYXRmb3JtMi5kZWZhdWx0Lm5hbWUgPT09ICdDaHJvbWUnICYmIF9wbGF0Zm9ybTIuZGVmYXVsdC5tYWpvclZlcnNpb24gPj0gNTQgfHwgX3BsYXRmb3JtMi5kZWZhdWx0Lm5hbWUgPT09ICdPcGVyYScgJiYgX3BsYXRmb3JtMi5kZWZhdWx0Lm1ham9yVmVyc2lvbiA+PSA0MTtcblxuICAgICAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5XRUJLSVQgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkJMSU5LICYmICFpc0ZpeGVkQmxpbmspIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgdmFyIF90YWJpbmRleCA9ICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoZWxlbWVudCk7XG4gIHZhciB0YWJpbmRleCA9IF90YWJpbmRleCA9PT0gbnVsbCA/IG51bGwgOiBfdGFiaW5kZXggPj0gMDtcblxuICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkVER0UgJiYgX3BsYXRmb3JtMi5kZWZhdWx0Lm1ham9yVmVyc2lvbiA+PSAxNCAmJiBmcmFtZUVsZW1lbnQgJiYgZWxlbWVudC5vd25lclNWR0VsZW1lbnQgJiYgX3RhYmluZGV4IDwgMCkge1xuICAgIC8vIEVkZ2UgMTQrIGNvbnNpZGVycyA8YSB4bGluazpocmVmPVwi4oCmXCIgdGFiaW5kZXg9XCItMVwiPiBrZXlib2FyZCBmb2N1c2FibGVcbiAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBpbiBhIG5lc3RlZCBicm93c2luZyBjb250ZXh0XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgaGFzVGFiYmFibGVUYWJpbmRleE9yTm9uZSA9IHRhYmluZGV4ICE9PSBmYWxzZTtcbiAgdmFyIGhhc1RhYmJhYmxlVGFiaW5kZXggPSBfdGFiaW5kZXggIT09IG51bGwgJiYgX3RhYmluZGV4ID49IDA7XG5cbiAgLy8gTk9URTogRmlyZWZveCAzMSBjb25zaWRlcnMgW2NvbnRlbnRlZGl0YWJsZV0gdG8gaGF2ZSBbdGFiaW5kZXg9LTFdLCBidXQgYWxsb3dzIHRhYmJpbmcgdG8gaXRcbiAgLy8gZml4ZWQgaW4gRmlyZWZveCA0MCB0aGUgbGF0ZXN0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTE4NTY1N1xuICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XG4gICAgLy8gdGFiYmluZyBjYW4gc3RpbGwgYmUgZGlzYWJsZWQgYnkgZXhwbGljaXRseSBwcm92aWRpbmcgW3RhYmluZGV4PVwiLTFcIl1cbiAgICByZXR1cm4gaGFzVGFiYmFibGVUYWJpbmRleE9yTm9uZTtcbiAgfVxuXG4gIGlmIChmb2N1c2FibGVFbGVtZW50c1BhdHRlcm4udGVzdChub2RlTmFtZSkgJiYgdGFiaW5kZXggIT09IHRydWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLldFQktJVCAmJiBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuSU9TKSB7XG4gICAgLy8gaU9TIG9ubHkgY29uc2lkZXJzIGEgaGFuZCBmdWxsIG9mIGVsZW1lbnRzIHRhYmJhYmxlIChrZXlib2FyZCBmb2N1c2FibGUpXG4gICAgLy8gdGhpcyBob2xkcyB0cnVlIGV2ZW4gd2l0aCBleHRlcm5hbCBrZXlib2FyZHNcbiAgICB2YXIgcG90ZW50aWFsbHlUYWJiYWJsZSA9IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW1lbnQudHlwZSA9PT0gJ3RleHQnIHx8IGVsZW1lbnQudHlwZSA9PT0gJ3Bhc3N3b3JkJyB8fCBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuXG4gICAgaWYgKCFwb3RlbnRpYWxseVRhYmJhYmxlKSB7XG4gICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgICAgIHBvdGVudGlhbGx5VGFiYmFibGUgPSAoMCwgX2lzLmlzVXNlck1vZGlmeVdyaXRhYmxlKShzdHlsZSk7XG4gICAgfVxuXG4gICAgaWYgKCFwb3RlbnRpYWxseVRhYmJhYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndXNlJyAmJiBfdGFiaW5kZXggIT09IG51bGwpIHtcbiAgICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkJMSU5LIHx8IF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5XRUJLSVQgJiYgX3BsYXRmb3JtMi5kZWZhdWx0Lm1ham9yVmVyc2lvbiA9PT0gOSkge1xuICAgICAgLy8gSW4gQ2hyb21lIGFuZCBTYWZhcmkgOSB0aGUgPHVzZT4gZWxlbWVudCBpcyBrZXlib2FyZCBmb2N1c2FibGUgZXZlbiBmb3IgdGFiaW5kZXg9XCItMVwiXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoKDAsIF9lbGVtZW50TWF0Y2hlczIuZGVmYXVsdCkoZWxlbWVudCwgJ3N2ZyBhJykgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKSkge1xuICAgIGlmIChoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lKSB7XG4gICAgICAvLyBpbiBUcmlkZW50IGFuZCBHZWNrbyBTVkdFbGVtZW50IGRvZXMgbm90IGhhbmRsZSB0aGUgdGFiSW5kZXggcHJvcGVydHkgcHJvcGVybHlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LmZvY3VzICYmICFzdXBwb3J0cy5mb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGUpIHtcbiAgICAgIC8vIEZpcmVmb3ggNTEgYW5kIDUyIHRyZWF0IGFueSBuYXRpdmVseSB0YWJiYWJsZSBTVkcgZWxlbWVudCB3aXRoXG4gICAgICAvLyB0YWJpbmRleD1cIi0xXCIgYXMgdGFiYmFibGUgYW5kIGV2ZXJ5dGhpbmcgZWxzZSBhcyBpbmVydFxuICAgICAgLy8gc2VlIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzMDIzNDBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3N2ZycgJiYgc3VwcG9ydHMuZm9jdXNTdmdJbklmcmFtZSAmJiBoYXNUYWJiYWJsZVRhYmluZGV4T3JOb25lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLlRSSURFTlQgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkVER0UpIHtcbiAgICBpZiAobm9kZU5hbWUgPT09ICdzdmcnKSB7XG4gICAgICBpZiAoc3VwcG9ydHMuZm9jdXNTdmcpIHtcbiAgICAgICAgLy8gb2xkZXIgSW50ZXJuZXQgRXhwbG9yZXJzIGNvbnNpZGVyIDxzdmc+IGtleWJvYXJkIGZvY3VzYWJsZVxuICAgICAgICAvLyB1bmxlc3MgdGhleSBoYXZlIGZvY3NhYmxlPVwiZmFsc2VcIiwgYnV0IHRoZW4gdGhleSB3b3VsZG4ndFxuICAgICAgICAvLyBiZSBmb2N1c2FibGUgYW5kIHRodXMgbm90IGV2ZW4gcmVhY2ggdGhpcyBmaWx0ZXJcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGVsZW1lbnRzIHRoYXQgaGF2ZSBbZm9jdXNhYmxlXSBhcmUgYXV0b21hdGljYWxseSBrZXlib2FyZCBmb2N1c2FibGUgcmVnYXJkbGVzcyBvZiB0aGUgYXR0cmlidXRlJ3MgdmFsdWVcbiAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZm9jdXNhYmxlJykgfHwgaGFzVGFiYmFibGVUYWJpbmRleDtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5vd25lclNWR0VsZW1lbnQpIHtcbiAgICAgIGlmIChzdXBwb3J0cy5mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlICYmIGhhc1RhYmJhYmxlVGFiaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGVsZW1lbnRzIHRoYXQgaGF2ZSBbZm9jdXNhYmxlXSBhcmUgYXV0b21hdGljYWxseSBrZXlib2FyZCBmb2N1c2FibGUgcmVnYXJkbGVzcyBvZiB0aGUgYXR0cmlidXRlJ3MgdmFsdWVcbiAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZm9jdXNhYmxlJyk7XG4gICAgfVxuICB9XG4gIGlmIChlbGVtZW50LnRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gQm9vbGVhbihleGNlcHQub25seVRhYmJhYmxlKTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2F1ZGlvJykge1xuICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRyb2xzJykpIHtcbiAgICAgIC8vIEluIEludGVybmV0IEV4cGxvcmVyIHRoZSA8YXVkaW8+IGVsZW1lbnQgaXMgZm9jdXNhYmxlLCBidXQgbm90IHRhYmJhYmxlLCBhbmQgdGFiSW5kZXggcHJvcGVydHkgaXMgd3JvbmdcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5CTElOSykge1xuICAgICAgLy8gSW4gQ2hyb21lIDxhdWRpbyBjb250cm9scyB0YWJpbmRleD1cIi0xXCI+IHJlbWFpbnMga2V5Ym9hcmQgZm9jdXNhYmxlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICd2aWRlbycpIHtcbiAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdjb250cm9scycpKSB7XG4gICAgICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLlRSSURFTlQgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkVER0UpIHtcbiAgICAgICAgLy8gSW4gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgdGhlIDx2aWRlbz4gZWxlbWVudCBpcyBmb2N1c2FibGUsIGJ1dCBub3QgdGFiYmFibGUsIGFuZCB0YWJJbmRleCBwcm9wZXJ0eSBpcyB3cm9uZ1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfcGxhdGZvcm0yLmRlZmF1bHQuaXMuQkxJTksgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPKSB7XG4gICAgICAvLyBJbiBDaHJvbWUgYW5kIEZpcmVmb3ggPHZpZGVvIGNvbnRyb2xzIHRhYmluZGV4PVwiLTFcIj4gcmVtYWlucyBrZXlib2FyZCBmb2N1c2FibGVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkJMSU5LIHx8IF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5XRUJLSVQpIHtcbiAgICAgIC8vIEluIGFsbCBCbGluayBhbmQgV2ViS2l0IGJhc2VkIGJyb3dzZXJzIDxlbWJlZD4gYW5kIDxvYmplY3Q+IGFyZSBuZXZlciBrZXlib2FyZCBmb2N1c2FibGUsIGV2ZW4gd2l0aCB0YWJpbmRleD1cIjBcIiBzZXRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICdpZnJhbWUnKSB7XG4gICAgLy8gSW4gSW50ZXJuZXQgRXhwbG9yZXIgYWxsIGlmcmFtZXMgYXJlIG9ubHkgZm9jdXNhYmxlXG4gICAgLy8gSW4gV2ViS2l0LCBCbGluayBhbmQgR2Vja28gaWZyYW1lcyBtYXkgYmUgdGFiYmFibGUgZGVwZW5kaW5nIG9uIGNvbnRlbnQuXG4gICAgLy8gU2luY2Ugd2UgY2FuJ3QgcmVsaWFibHkgaW52ZXN0aWdhdGUgaWZyYW1lIGRvY3VtZW50cyBiZWNhdXNlIG9mIHRoZVxuICAgIC8vIFNhbWVPcmlnaW5Qb2xpY3ksIHdlJ3JlIGRlY2xhcmluZyBldmVyeXRoaW5nIG9ubHkgZm9jdXNhYmxlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghZXhjZXB0LnNjcm9sbGFibGUgJiYgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPKSB7XG4gICAgLy8gRmlyZWZveCBjb25zaWRlcnMgc2Nyb2xsYWJsZSBjb250YWluZXJzIGtleWJvYXJkIGZvY3VzYWJsZSxcbiAgICAvLyBldmVuIHRob3VnaCB0aGVpciB0YWJJbmRleCBwcm9wZXJ0eSBpcyAtMVxuICAgIHZhciBfc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgICBpZiAoKDAsIF9pcy5oYXNDc3NPdmVyZmxvd1Njcm9sbCkoX3N0eWxlKSkge1xuICAgICAgcmV0dXJuIGhhc1RhYmJhYmxlVGFiaW5kZXhPck5vbmU7XG4gICAgfVxuICB9XG5cbiAgaWYgKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5UUklERU5UIHx8IF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5FREdFKSB7XG4gICAgLy8gSUUgYW5kIEVkZ2UgZGVncmFkZSA8YXJlYT4gdG8gc2NyaXB0IGZvY3VzYWJsZSwgaWYgdGhlIGltYWdlXG4gICAgLy8gdXNpbmcgdGhlIDxtYXA+IGhhcyBiZWVuIGdpdmVuIHRhYmluZGV4PVwiLTFcIlxuICAgIGlmIChub2RlTmFtZSA9PT0gJ2FyZWEnKSB7XG4gICAgICB2YXIgaW1nID0gKDAsIF9pbWFnZU1hcC5nZXRJbWFnZU9mQXJlYSkoZWxlbWVudCk7XG4gICAgICBpZiAoaW1nICYmICgwLCBfdGFiaW5kZXhWYWx1ZTIuZGVmYXVsdCkoaW1nKSA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfc3R5bGUyID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgaWYgKCgwLCBfaXMuaXNVc2VyTW9kaWZ5V3JpdGFibGUpKF9zdHlsZTIpKSB7XG4gICAgICAvLyBwcmV2ZW50IGJlaW5nIHN3YWxsb3dlZCBieSB0aGUgb3ZlcnplYWxvdXMgaXNTY3JvbGxhYmxlQ29udGFpbmVyKCkgYmVsb3dcbiAgICAgIHJldHVybiBlbGVtZW50LnRhYkluZGV4ID49IDA7XG4gICAgfVxuXG4gICAgaWYgKCFleGNlcHQuZmxleGJveCAmJiAoMCwgX2lzLmhhc0Nzc0Rpc3BsYXlGbGV4KShfc3R5bGUyKSkge1xuICAgICAgaWYgKF90YWJpbmRleCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gaGFzVGFiYmFibGVUYWJpbmRleDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzRm9jdXNSZWxldmFudFdpdGhvdXRGbGV4Ym94KGVsZW1lbnQpICYmIGlzVGFiYmFibGVXaXRob3V0RmxleGJveChlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBJRSBjb25zaWRlcnMgc2Nyb2xsYWJsZSBjb250YWluZXJzIHNjcmlwdCBmb2N1c2FibGUgb25seSxcbiAgICAvLyBldmVuIHRob3VnaCB0aGVpciB0YWJJbmRleCBwcm9wZXJ0eSBpcyAwXG4gICAgaWYgKCgwLCBfaXMuaXNTY3JvbGxhYmxlQ29udGFpbmVyKShlbGVtZW50LCBub2RlTmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIHZhciBwYXJlbnROb2RlTmFtZSA9IHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHBhcmVudFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50LCBudWxsKTtcbiAgICAgIC8vIElFIGNvbnNpZGVycyBzY3JvbGxhYmxlIGJvZGllcyBzY3JpcHQgZm9jdXNhYmxlIG9ubHksXG4gICAgICBpZiAoKDAsIF9pcy5pc1Njcm9sbGFibGVDb250YWluZXIpKHBhcmVudCwgbm9kZU5hbWUsIHBhcmVudE5vZGVOYW1lLCBwYXJlbnRTdHlsZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGlsZHJlbiBvZiBmb2N1c2FibGUgZWxlbWVudHMgd2l0aCBkaXNwbGF5OmZsZXggYXJlIGZvY3VzYWJsZSBpbiBJRTEwLTExLFxuICAgICAgLy8gZXZlbiB0aG91Z2ggdGhlaXIgdGFiSW5kZXggcHJvcGVydHkgc3VnZ2VzdHMgb3RoZXJ3aXNlXG4gICAgICBpZiAoKDAsIF9pcy5oYXNDc3NEaXNwbGF5RmxleCkocGFyZW50U3R5bGUpKSB7XG4gICAgICAgIC8vIHZhbHVlIG9mIHRhYmluZGV4IHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgcmV0dXJuIGhhc1RhYmJhYmxlVGFiaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS9QRi9hcmlhLXByYWN0aWNlcy8jZm9jdXNfdGFiaW5kZXhcbiAgcmV0dXJuIGVsZW1lbnQudGFiSW5kZXggPj0gMDtcbn1cblxuLy8gYmluZCBleGNlcHRpb25zIHRvIGFuIGl0ZXJhdG9yIGNhbGxiYWNrXG5pc1RhYmJhYmxlUnVsZXMuZXhjZXB0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZXhjZXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgaXNUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzVGFiYmFibGUoY29udGV4dCkge1xuICAgIHJldHVybiBpc1RhYmJhYmxlUnVsZXMoe1xuICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgIGV4Y2VwdDogZXhjZXB0XG4gICAgfSk7XG4gIH07XG5cbiAgaXNUYWJiYWJsZS5ydWxlcyA9IGlzVGFiYmFibGVSdWxlcztcbiAgcmV0dXJuIGlzVGFiYmFibGU7XG59O1xuXG52YXIgaXNGb2N1c1JlbGV2YW50V2l0aG91dEZsZXhib3ggPSBfZm9jdXNSZWxldmFudDIuZGVmYXVsdC5ydWxlcy5leGNlcHQoeyBmbGV4Ym94OiB0cnVlIH0pO1xudmFyIGlzVGFiYmFibGVXaXRob3V0RmxleGJveCA9IGlzVGFiYmFibGVSdWxlcy5leGNlcHQoeyBmbGV4Ym94OiB0cnVlIH0pO1xuXG4vLyBwcm92aWRlIGlzVGFiYmFibGUoY29udGV4dCkgYXMgZGVmYXVsdCBpdGVyYXRvciBjYWxsYmFja1xudmFyIGlzVGFiYmFibGUgPSBpc1RhYmJhYmxlUnVsZXMuZXhjZXB0KHt9KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVGFiYmFibGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYmJhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgaWYgKCFzdXBwb3J0cykge1xuICAgIHN1cHBvcnRzID0gKDAsIF9zdXBwb3J0czMuZGVmYXVsdCkoKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gKDAsIF9jb250ZXh0VG9FbGVtZW50Mi5kZWZhdWx0KSh7XG4gICAgbGFiZWw6ICdpcy92YWxpZC1hcmVhJyxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH0pO1xuXG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKG5vZGVOYW1lICE9PSAnYXJlYScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaGFzVGFiaW5kZXggPSBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgaWYgKCFzdXBwb3J0cy5mb2N1c0FyZWFUYWJpbmRleCAmJiBoYXNUYWJpbmRleCkge1xuICAgIC8vIEJsaW5rIGFuZCBXZWJLaXQgZG8gbm90IGNvbnNpZGVyIDxhcmVhIHRhYmluZGV4PVwiLTFcIiBocmVmPVwiI3ZvaWRcIj4gZm9jdXNhYmxlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGltZyA9ICgwLCBfaW1hZ2VNYXAuZ2V0SW1hZ2VPZkFyZWEpKGVsZW1lbnQpO1xuICBpZiAoIWltZyB8fCAhKDAsIF92aXNpYmxlMi5kZWZhdWx0KShpbWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRmlyZWZveCBvbmx5IGFsbG93cyBmdWxseSBsb2FkZWQgaW1hZ2VzIHRvIHJlZmVyZW5jZSBpbWFnZSBtYXBzXG4gIC8vIGh0dHBzOi8vc3RlcmVvY2hyby5tZS9pZGVhcy9kZXRlY3RpbmctYnJva2VuLWltYWdlcy1qc1xuICBpZiAoIXN1cHBvcnRzLmZvY3VzQnJva2VuSW1hZ2VNYXAgJiYgKCFpbWcuY29tcGxldGUgfHwgIWltZy5uYXR1cmFsSGVpZ2h0IHx8IGltZy5vZmZzZXRXaWR0aCA8PSAwIHx8IGltZy5vZmZzZXRIZWlnaHQgPD0gMCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBGaXJlZm94IHN1cHBvcnRzLmNhbiBmb2N1cyBhcmVhIGVsZW1lbnRzIGV2ZW4gaWYgdGhleSBkb24ndCBoYXZlIGFuIGhyZWYgYXR0cmlidXRlXG4gIGlmICghc3VwcG9ydHMuZm9jdXNBcmVhV2l0aG91dEhyZWYgJiYgIWVsZW1lbnQuaHJlZikge1xuICAgIC8vIEludGVybmV0IGV4cGxvcmVyIHN1cHBvcnRzLmNhbiBmb2N1cyBhcmVhIGVsZW1lbnRzIHdpdGhvdXQgaHJlZiBpZiBlaXRoZXJcbiAgICAvLyB0aGUgYXJlYSBlbGVtZW50IG9yIHRoZSBpbWFnZSBlbGVtZW50IGhhcyBhIHRhYmluZGV4IGF0dHJpYnV0ZVxuICAgIHJldHVybiBzdXBwb3J0cy5mb2N1c0FyZWFUYWJpbmRleCAmJiBoYXNUYWJpbmRleCB8fCBzdXBwb3J0cy5mb2N1c0FyZWFJbWdUYWJpbmRleCAmJiBpbWcuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxuICB2YXIgY2hpbGRPZkludGVyYWN0aXZlID0gKDAsIF9wYXJlbnRzMi5kZWZhdWx0KSh7IGNvbnRleHQ6IGltZyB9KS5zbGljZSgxKS5zb21lKGZ1bmN0aW9uIChfZWxlbWVudCkge1xuICAgIHZhciBuYW1lID0gX2VsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbmFtZSA9PT0gJ2J1dHRvbicgfHwgbmFtZSA9PT0gJ2EnO1xuICB9KTtcblxuICBpZiAoY2hpbGRPZkludGVyYWN0aXZlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQgPSByZXF1aXJlKCcuLi91dGlsL2NvbnRleHQtdG8tZWxlbWVudCcpO1xuXG52YXIgX2NvbnRleHRUb0VsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udGV4dFRvRWxlbWVudCk7XG5cbnZhciBfdmlzaWJsZSA9IHJlcXVpcmUoJy4vdmlzaWJsZScpO1xuXG52YXIgX3Zpc2libGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmlzaWJsZSk7XG5cbnZhciBfcGFyZW50cyA9IHJlcXVpcmUoJy4uL2dldC9wYXJlbnRzJyk7XG5cbnZhciBfcGFyZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJlbnRzKTtcblxudmFyIF9pbWFnZU1hcCA9IHJlcXVpcmUoJy4uL3V0aWwvaW1hZ2UtbWFwJyk7XG5cbnZhciBfc3VwcG9ydHMyID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvc3VwcG9ydHMnKTtcblxudmFyIF9zdXBwb3J0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdXBwb3J0czIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc3VwcG9ydHMgPSB2b2lkIDA7XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9tYXBcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5LXVpL2Jsb2IvbWFzdGVyL3VpL2NvcmUuanMjTDg4LUwxMDdcblxuLy8gZGV0ZXJtaW5lIGlmIGFuIDxhcmVhPiBlbGVtZW50IGlzIGJlaW5nIHByb3Blcmx5IHVzZWQgYnkgYW5kIDxpbWc+IHZpYSBhIDxtYXA+XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWQtYXJlYS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIGlmICghc3VwcG9ydHMpIHtcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XG4gIH1cblxuICB2YXIgdmFsaWRJbnRlZ2VyUGF0dGVybiA9IHN1cHBvcnRzLmZvY3VzVGFiaW5kZXhUcmFpbGluZ0NoYXJhY3RlcnMgPyB2YWxpZEludGVnZXJQYXR0ZXJuV2l0aFRyYWlsaW5nIDogdmFsaWRJbnRlZ2VyUGF0dGVybk5vVHJhaWxpbmc7XG5cbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcbiAgICBsYWJlbDogJ2lzL3ZhbGlkLXRhYmluZGV4JyxcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9KTtcblxuICAvLyBFZGdlIDE0IGhhcyBhIGNhcGl0YWxpemF0aW9uIHByb2JsZW0gb24gU1ZHIGVsZW1lbnRzLFxuICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvOTI4MjA1OC9cbiAgdmFyIGhhc1RhYmluZGV4ID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gIHZhciBoYXNUYWJJbmRleCA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJJbmRleCcpO1xuXG4gIGlmICghaGFzVGFiaW5kZXggJiYgIWhhc1RhYkluZGV4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gb2xkZXIgRmlyZWZveCBhbmQgSW50ZXJuZXQgRXhwbG9yZXIgZG9uJ3Qgc3VwcG9ydCB0YWJpbmRleCBvbiBTVkcgZWxlbWVudHNcbiAgdmFyIGlzU3ZnRWxlbWVudCA9IGVsZW1lbnQub3duZXJTVkdFbGVtZW50IHx8IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2Zyc7XG4gIGlmIChpc1N2Z0VsZW1lbnQgJiYgIXN1cHBvcnRzLmZvY3VzU3ZnVGFiaW5kZXhBdHRyaWJ1dGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBAYnJvd3Nlci1pc3N1ZSBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTI4MDU0XG4gIGlmIChzdXBwb3J0cy5mb2N1c0ludmFsaWRUYWJpbmRleCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gYW4gZWxlbWVudCBtYXRjaGVzIHRoZSB0YWJpbmRleCBzZWxlY3RvciBldmVuIGlmIGl0cyB2YWx1ZSBpcyBpbnZhbGlkXG4gIHZhciB0YWJpbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGhhc1RhYmluZGV4ID8gJ3RhYmluZGV4JyA6ICd0YWJJbmRleCcpO1xuICAvLyBJRTExIHBhcnNlcyB0YWJpbmRleD1cIlwiIGFzIHRoZSB2YWx1ZSBcIi0zMjc2OFwiXG4gIC8vIEBicm93c2VyLWlzc3VlIFRyaWRlbnQgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xMDcyOTY1XG4gIGlmICh0YWJpbmRleCA9PT0gJy0zMjc2OCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gQm9vbGVhbih0YWJpbmRleCAmJiB2YWxpZEludGVnZXJQYXR0ZXJuLnRlc3QodGFiaW5kZXgpKTtcbn07XG5cbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcblxudmFyIF9zdXBwb3J0czIgPSByZXF1aXJlKCcuLi9zdXBwb3J0cy9zdXBwb3J0cycpO1xuXG52YXIgX3N1cHBvcnRzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGRldGVybWluZSBpZiBhbiBlbGVtZW50J3MgdGFiaW5kZXggYXR0cmlidXRlIGhhcyBhIHZhbGlkIHZhbHVlXG5cbnZhciBzdXBwb3J0cyA9IHZvaWQgMDtcblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjcnVsZXMtZm9yLXBhcnNpbmctaW50ZWdlcnNcbi8vIE5PVEU6IGFsbCBicm93c2VycyBhZ3JlZSB0byBhbGxvdyB0cmFpbGluZyBzcGFjZXMgYXMgd2VsbFxudmFyIHZhbGlkSW50ZWdlclBhdHRlcm5Ob1RyYWlsaW5nID0gL15cXHMqKC18XFwrKT9bMC05XStcXHMqJC87XG52YXIgdmFsaWRJbnRlZ2VyUGF0dGVybldpdGhUcmFpbGluZyA9IC9eXFxzKigtfFxcKyk/WzAtOV0rLiokLztcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZC10YWJpbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfYXJyYXlGaW5kSW5kZXggPSByZXF1aXJlKCcuLi91dGlsL2FycmF5LWZpbmQtaW5kZXgnKTtcblxudmFyIF9hcnJheUZpbmRJbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcnJheUZpbmRJbmRleCk7XG5cbnZhciBfcGFyZW50cyA9IHJlcXVpcmUoJy4uL2dldC9wYXJlbnRzJyk7XG5cbnZhciBfcGFyZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJlbnRzKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9jb250ZXh0LXRvLWVsZW1lbnQnKTtcblxudmFyIF9jb250ZXh0VG9FbGVtZW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRleHRUb0VsZW1lbnQpO1xuXG52YXIgX2dldEZyYW1lRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWZyYW1lLWVsZW1lbnQnKTtcblxudmFyIF9nZXRGcmFtZUVsZW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0RnJhbWVFbGVtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L3JlbmRlcmluZy5odG1sI2JlaW5nLXJlbmRlcmVkXG4vLyA8YXJlYT4gaXMgbm90IHJlbmRlcmVkLCBidXQgd2UgKmNvbnNpZGVyKiBpdCB2aXNpYmxlIHRvIHNpbXBsZml5IHRoaXMgZnVuY3Rpb24ncyB1c2FnZVxuXG4vLyBkZXRlcm1pbmUgaWYgYW4gZWxlbWVudCBpcyByZW5kZXJlZFxuLy8gTk9URTogdGhhdCBkb2VzIG5vdCBtZWFuIGFuIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnQsIHNlZSB1dGlsL3Zpc2libGUtYXJlYVxuXG52YXIgbm90UmVuZGVyZWRFbGVtZW50c1BhdHRlcm4gPSAvXihhcmVhKSQvO1xuXG5mdW5jdGlvbiBjb21wdXRlZFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbn1cblxuZnVuY3Rpb24gbm90RGlzcGxheWVkKF9wYXRoKSB7XG4gIHJldHVybiBfcGF0aC5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgLy8gZGlzcGxheTpub25lIGlzIG5vdCB2aXNpYmxlIChvcHRpbWl6ZWQgYXdheSBhdCBsYXlvdXQpXG4gICAgcmV0dXJuIGNvbXB1dGVkU3R5bGUoZWxlbWVudCwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbm90VmlzaWJsZShfcGF0aCkge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS11aS9ibG9iL21hc3Rlci91aS9jb3JlLmpzI0wxMDktTDExNFxuICAvLyBOT1RFOiBhIG5lc3RlZCBlbGVtZW50IGNhbiByZXZlcnNlIHZpc2liaWxpdHk6aGlkZGVufGNvbGxhcHNlIGJ5IGV4cGxpY2l0bHkgc2V0dGluZyB2aXNpYmlsaXR5OnZpc2libGVcbiAgLy8gTk9URTogdmlzaWJpbGl0eSBjYW4gYmUgW1wiXCIsIFwidmlzaWJsZVwiLCBcImhpZGRlblwiLCBcImNvbGxhcHNlXCJdXG4gIHZhciBoaWRkZW4gPSAoMCwgX2FycmF5RmluZEluZGV4Mi5kZWZhdWx0KShfcGF0aCwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB2YXIgdmlzaWJpbGl0eSA9IGNvbXB1dGVkU3R5bGUoZWxlbWVudCwgJ3Zpc2liaWxpdHknKTtcbiAgICByZXR1cm4gdmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicgfHwgdmlzaWJpbGl0eSA9PT0gJ2NvbGxhcHNlJztcbiAgfSk7XG5cbiAgaWYgKGhpZGRlbiA9PT0gLTEpIHtcbiAgICAvLyB0aGVyZSBpcyBubyBoaWRkZW4gZWxlbWVudFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB2aXNpYmxlID0gKDAsIF9hcnJheUZpbmRJbmRleDIuZGVmYXVsdCkoX3BhdGgsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGNvbXB1dGVkU3R5bGUoZWxlbWVudCwgJ3Zpc2liaWxpdHknKSA9PT0gJ3Zpc2libGUnO1xuICB9KTtcblxuICBpZiAodmlzaWJsZSA9PT0gLTEpIHtcbiAgICAvLyB0aGVyZSBpcyBubyB2aXNpYmxlIGVsZW1lbnQgKGJ1dCBhIGhpZGRlbiBlbGVtZW50KVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGhpZGRlbiA8IHZpc2libGUpIHtcbiAgICAvLyB0aGVyZSBpcyBhIGhpZGRlbiBlbGVtZW50IGFuZCBpdCdzIGNsb3NlciB0aGFuIHRoZSBmaXJzdCB2aXNpYmxlIGVsZW1lbnRcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRoZXJlIG1heSBiZSBhIGhpZGRlbiBlbGVtZW50LCBidXQgdGhlIGNsb3Nlc3QgZWxlbWVudCBpcyB2aXNpYmxlXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29sbGFwc2VkUGFyZW50KF9wYXRoKSB7XG4gIHZhciBvZmZzZXQgPSAxO1xuICBpZiAoX3BhdGhbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N1bW1hcnknKSB7XG4gICAgb2Zmc2V0ID0gMjtcbiAgfVxuXG4gIHJldHVybiBfcGF0aC5zbGljZShvZmZzZXQpLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAvLyBcImNvbnRlbnQgY2hpbGRyZW5cIiBvZiBhIGNsb3NlZCBkZXRhaWxzIGVsZW1lbnQgYXJlIG5vdCB2aXNpYmxlXG4gICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2RldGFpbHMnICYmIGVsZW1lbnQub3BlbiA9PT0gZmFsc2U7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc1Zpc2libGVSdWxlcygpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICAgIF9yZWYkZXhjZXB0ID0gX3JlZi5leGNlcHQsXG4gICAgICBleGNlcHQgPSBfcmVmJGV4Y2VwdCA9PT0gdW5kZWZpbmVkID8ge1xuICAgIG5vdFJlbmRlcmVkOiBmYWxzZSxcbiAgICBjc3NEaXNwbGF5OiBmYWxzZSxcbiAgICBjc3NWaXNpYmlsaXR5OiBmYWxzZSxcbiAgICBkZXRhaWxzRWxlbWVudDogZmFsc2UsXG4gICAgYnJvd3NpbmdDb250ZXh0OiBmYWxzZVxuICB9IDogX3JlZiRleGNlcHQ7XG5cbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcbiAgICBsYWJlbDogJ2lzL3Zpc2libGUnLFxuICAgIHJlc29sdmVEb2N1bWVudDogdHJ1ZSxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH0pO1xuXG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCFleGNlcHQubm90UmVuZGVyZWQgJiYgbm90UmVuZGVyZWRFbGVtZW50c1BhdHRlcm4udGVzdChub2RlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBfcGF0aCA9ICgwLCBfcGFyZW50czIuZGVmYXVsdCkoeyBjb250ZXh0OiBlbGVtZW50IH0pO1xuXG4gIC8vIGluIEludGVybmV0IEV4cGxvcmVyIDxhdWRpbz4gaGFzIGEgZGVmYXVsdCBkaXNwbGF5OiBub25lLCB3aGVyZSBvdGhlcnMgaGF2ZSBkaXNwbGF5OiBpbmxpbmVcbiAgLy8gYnV0IElFIGFsbG93cyBmb2N1c2luZyA8YXVkaW8gc3R5bGU9XCJkaXNwbGF5Om5vbmVcIj4sIGJ1dCBub3QgPGRpdiBkaXNwbGF5Om5vbmU+PGF1ZGlvPlxuICAvLyB0aGlzIGlzIGlycmVsZXZhbnQgdG8gb3RoZXIgYnJvd3NlcnMsIGFzIHRoZSBjb250cm9scyBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgdG8gbWFrZSA8YXVkaW8+IGZvY3VzYWJsZVxuICB2YXIgaXNBdWRpb1dpdGhvdXRDb250cm9scyA9IG5vZGVOYW1lID09PSAnYXVkaW8nICYmICFlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnY29udHJvbHMnKTtcbiAgaWYgKCFleGNlcHQuY3NzRGlzcGxheSAmJiBub3REaXNwbGF5ZWQoaXNBdWRpb1dpdGhvdXRDb250cm9scyA/IF9wYXRoLnNsaWNlKDEpIDogX3BhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFleGNlcHQuY3NzVmlzaWJpbGl0eSAmJiBub3RWaXNpYmxlKF9wYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghZXhjZXB0LmRldGFpbHNFbGVtZW50ICYmIGNvbGxhcHNlZFBhcmVudChfcGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWV4Y2VwdC5icm93c2luZ0NvbnRleHQpIHtcbiAgICAvLyBlbGVtZW50cyB3aXRoaW4gYSBicm93c2luZyBjb250ZXh0IGFyZSBhZmZlY3RlZCBieSB0aGVcbiAgICAvLyBicm93c2luZyBjb250ZXh0IGhvc3QgZWxlbWVudCdzIHZpc2liaWxpdHkgYW5kIHRhYmluZGV4XG4gICAgdmFyIGZyYW1lRWxlbWVudCA9ICgwLCBfZ2V0RnJhbWVFbGVtZW50Mi5kZWZhdWx0KShlbGVtZW50KTtcbiAgICB2YXIgX2lzVmlzaWJsZSA9IGlzVmlzaWJsZVJ1bGVzLmV4Y2VwdChleGNlcHQpO1xuICAgIGlmIChmcmFtZUVsZW1lbnQgJiYgIV9pc1Zpc2libGUoZnJhbWVFbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBiaW5kIGV4Y2VwdGlvbnMgdG8gYW4gaXRlcmF0b3IgY2FsbGJhY2tcbmlzVmlzaWJsZVJ1bGVzLmV4Y2VwdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGV4Y2VwdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgdmFyIGlzVmlzaWJsZSA9IGZ1bmN0aW9uIGlzVmlzaWJsZShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGlzVmlzaWJsZVJ1bGVzKHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBleGNlcHQ6IGV4Y2VwdFxuICAgIH0pO1xuICB9O1xuXG4gIGlzVmlzaWJsZS5ydWxlcyA9IGlzVmlzaWJsZVJ1bGVzO1xuICByZXR1cm4gaXNWaXNpYmxlO1xufTtcblxuLy8gcHJvdmlkZSBpc1Zpc2libGUoY29udGV4dCkgYXMgZGVmYXVsdCBpdGVyYXRvciBjYWxsYmFja1xudmFyIGlzVmlzaWJsZSA9IGlzVmlzaWJsZVJ1bGVzLmV4Y2VwdCh7fSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1Zpc2libGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpc2libGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuLypcbiAgVXRpbGl0eSB0byBtYWtlIGEgc3ViLXRyZWUgb2YgdGhlIERPTSBpbmVydC4gSW5lcnQgbWVhbnMgdGhlIGVsZW1lbnRzIGNhbm5vdCBiZSBpbnRlcmFjdGVkXG4gIHdpdGggYW5kIHRoZXkgY2Fubm90IGJlIGZvY3VzZWQgdmlhIHNjcmlwdCwgcG9pbnRlciBvciBrZXlib2FyZC5cblxuICBpbmVydCBhdHRyaWJ1dGUgd2FzIFtyZW1vdmVkXShodHRwczovL2h0bWw1Lm9yZy9yLzg1MzYpIFt0d2VldCBieSBzdGV2ZV0oaHR0cHM6Ly90d2l0dGVyLmNvbS9zdGV2ZWZhdWxrbmVyL3N0YXR1cy80NDMwNzU5MDAyMDEyNTkwMDgpXG4gIGJ1dCBkZWZpbml0aW9uIG9mIFtpbmVydCBzdWJ0cmVlc10oaHR0cHM6Ly93d3cudzMub3JnL2h0bWwvd2cvZHJhZnRzL2h0bWwvbWFzdGVyL2VkaXRpbmcuaHRtbCNpbmVydC1zdWJ0cmVlcykgcmVtYWlucy5cblxuICBbaW1wbGVtZW50YXRpb24gaWRlYSBieSBWYXNpbGlzXShodHRwczovL2NvZGVwZW4uaW8vdmFzaWxpc3ZnL3Blbi9zY293SSlcbiAgW2luZXJ0IGF0dHJpYnV0ZSBwb2x5ZmlsbCBieSBHb29nbGVDaHJvbWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvaW5lcnQtcG9seWZpbGwpXG5cbiAgW0dlY2tvIEJ1ZzogSW5lcnQgQXR0cmlidXRlXShodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05MjE1MDQpXG4gIFtDaHJvbWl1bSBCdWc6IEluZXJ0IEF0dHJpYnV0ZV0oaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI2OTg0NilcbiAgW0Nocm9taXVtIEJ1ZzogSW5lcnQgU3VidHJlZV0oaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI0MTY5OSlcbiAgW1dlYktpdCBCdWc6IEluZXJ0IFN1YnRyZWVdKGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTA5NTIpXG4qL1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmMiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBjb250ZXh0ID0gX3JlZjIuY29udGV4dCxcbiAgICAgIGZpbHRlciA9IF9yZWYyLmZpbHRlcjtcblxuICB2YXIgc2VydmljZSA9IG5ldyBJbmVydFN1YnRyZWUoeyBjb250ZXh0OiBjb250ZXh0LCBmaWx0ZXI6IGZpbHRlciB9KTtcbiAgcmV0dXJuIHsgZGlzZW5nYWdlOiBzZXJ2aWNlLmRpc2VuZ2FnZSB9O1xufTtcblxudmFyIF9ub2RlQXJyYXkgPSByZXF1aXJlKCcuLi91dGlsL25vZGUtYXJyYXknKTtcblxudmFyIF9ub2RlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9kZUFycmF5KTtcblxudmFyIF9mb2N1c2FibGUgPSByZXF1aXJlKCcuLi9xdWVyeS9mb2N1c2FibGUnKTtcblxudmFyIF9mb2N1c2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNhYmxlKTtcblxudmFyIF9kaXNhYmxlZCA9IHJlcXVpcmUoJy4uL2VsZW1lbnQvZGlzYWJsZWQnKTtcblxudmFyIF9kaXNhYmxlZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXNhYmxlZCk7XG5cbnZhciBfc2hhZG93TXV0YXRpb25zID0gcmVxdWlyZSgnLi4vb2JzZXJ2ZS9zaGFkb3ctbXV0YXRpb25zJyk7XG5cbnZhciBfc2hhZG93TXV0YXRpb25zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NoYWRvd011dGF0aW9ucyk7XG5cbnZhciBfY29tcGFyZVBvc2l0aW9uID0gcmVxdWlyZSgnLi4vdXRpbC9jb21wYXJlLXBvc2l0aW9uJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIG1ha2VFbGVtZW50SW5lcnQoZWxlbWVudCkge1xuICByZXR1cm4gKDAsIF9kaXNhYmxlZDIuZGVmYXVsdCkoZWxlbWVudCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHVuZG9FbGVtZW50SW5lcnQoZWxlbWVudCkge1xuICByZXR1cm4gKDAsIF9kaXNhYmxlZDIuZGVmYXVsdCkoZWxlbWVudCwgZmFsc2UpO1xufVxuXG52YXIgb2JzZXJ2ZXJDb25maWcgPSB7XG4gIGF0dHJpYnV0ZXM6IHRydWUsXG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgc3VidHJlZTogdHJ1ZSxcbiAgYXR0cmlidXRlRmlsdGVyOiBbJ3RhYmluZGV4JywgJ2Rpc2FibGVkJywgJ2RhdGEtYWxseS1kaXNhYmxlZCddXG59O1xuXG52YXIgSW5lcnRTdWJ0cmVlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbmVydFN1YnRyZWUoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICAgICAgZmlsdGVyID0gX3JlZi5maWx0ZXI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRTdWJ0cmVlKTtcblxuICAgIHRoaXMuX2NvbnRleHQgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkoY29udGV4dCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpWzBdO1xuICAgIHRoaXMuX2ZpbHRlciA9ICgwLCBfbm9kZUFycmF5Mi5kZWZhdWx0KShmaWx0ZXIpO1xuICAgIHRoaXMuX2luZXJ0RWxlbWVudENhY2hlID0gW107XG5cbiAgICB0aGlzLmRpc2VuZ2FnZSA9IHRoaXMuZGlzZW5nYWdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVNdXRhdGlvbiA9IHRoaXMuaGFuZGxlTXV0YXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLnJlbmRlckluZXJ0ID0gdGhpcy5yZW5kZXJJbmVydC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZmlsdGVyRWxlbWVudHMgPSB0aGlzLmZpbHRlckVsZW1lbnRzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5maWx0ZXJQYXJlbnRFbGVtZW50cyA9IHRoaXMuZmlsdGVyUGFyZW50RWxlbWVudHMuYmluZCh0aGlzKTtcblxuICAgIHZhciBmb2N1c2FibGUgPSAoMCwgX2ZvY3VzYWJsZTIuZGVmYXVsdCkoe1xuICAgICAgY29udGV4dDogdGhpcy5fY29udGV4dCxcbiAgICAgIGluY2x1ZGVDb250ZXh0OiB0cnVlLFxuICAgICAgc3RyYXRlZ3k6ICdhbGwnXG4gICAgfSk7XG5cbiAgICB0aGlzLnJlbmRlckluZXJ0KGZvY3VzYWJsZSk7XG5cbiAgICB0aGlzLnNoYWRvd09ic2VydmVyID0gKDAsIF9zaGFkb3dNdXRhdGlvbnMyLmRlZmF1bHQpKHtcbiAgICAgIGNvbnRleHQ6IHRoaXMuX2NvbnRleHQsXG4gICAgICBjb25maWc6IG9ic2VydmVyQ29uZmlnLFxuICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG11dGF0aW9ucykge1xuICAgICAgICByZXR1cm4gbXV0YXRpb25zLmZvckVhY2goX3RoaXMuaGFuZGxlTXV0YXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEluZXJ0U3VidHJlZSwgW3tcbiAgICBrZXk6ICdkaXNlbmdhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNlbmdhZ2UoKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1bmRvRWxlbWVudEluZXJ0KHRoaXMuX2NvbnRleHQpO1xuICAgICAgdGhpcy5faW5lcnRFbGVtZW50Q2FjaGUuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdW5kb0VsZW1lbnRJbmVydChlbGVtZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9pbmVydEVsZW1lbnRDYWNoZSA9IG51bGw7XG4gICAgICB0aGlzLl9maWx0ZXIgPSBudWxsO1xuICAgICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLnNoYWRvd09ic2VydmVyICYmIHRoaXMuc2hhZG93T2JzZXJ2ZXIuZGlzZW5nYWdlKCk7XG4gICAgICB0aGlzLnNoYWRvd09ic2VydmVyID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdsaXN0UXVlcnlGb2N1c2FibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0UXVlcnlGb2N1c2FibGUobGlzdCkge1xuICAgICAgcmV0dXJuIGxpc3RcbiAgICAgIC8vIGZpbmQgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoaW4gdGhlIGdpdmVuIGNvbnRleHRzXG4gICAgICAubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAoMCwgX2ZvY3VzYWJsZTIuZGVmYXVsdCkoeyBjb250ZXh0OiBlbGVtZW50LCBpbmNsdWRlQ29udGV4dDogdHJ1ZSwgc3RyYXRlZ3k6ICdhbGwnIH0pO1xuICAgICAgfSlcbiAgICAgIC8vIGZsYXR0ZW4gbmVzdGVkIGFycmF5c1xuICAgICAgLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzLmNvbmNhdChjdXJyZW50KTtcbiAgICAgIH0sIFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXJJbmVydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckluZXJ0KGVsZW1lbnRzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG1ha2VJbmVydCA9IGZ1bmN0aW9uIG1ha2VJbmVydChlbGVtZW50KSB7XG4gICAgICAgIF90aGlzMi5faW5lcnRFbGVtZW50Q2FjaGUucHVzaChlbGVtZW50KTtcbiAgICAgICAgbWFrZUVsZW1lbnRJbmVydChlbGVtZW50KTtcbiAgICAgIH07XG5cbiAgICAgIGVsZW1lbnRzLmZpbHRlcih0aGlzLmZpbHRlckVsZW1lbnRzKS5maWx0ZXIodGhpcy5maWx0ZXJQYXJlbnRFbGVtZW50cylcbiAgICAgIC8vIGlnbm9yZSBlbGVtZW50cyB0aGF0IGFscmVhZHkgYXJlIGRpc2FibGVkXG4gICAgICAvLyBzbyB3ZSBkb24ndCBlbmFibGUgdGhlbSBvbiBkaXNlbmdhZ2UoKVxuICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gISgwLCBfZGlzYWJsZWQyLmRlZmF1bHQpKGVsZW1lbnQpO1xuICAgICAgfSkuZm9yRWFjaChtYWtlSW5lcnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2ZpbHRlckVsZW1lbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsdGVyRWxlbWVudHMoZWxlbWVudCkge1xuICAgICAgLy8gaWdub3JlIGVsZW1lbnRzIHdpdGhpbiB0aGUgZXhlbXB0ZWQgc3ViLXRyZWVzXG4gICAgICB2YXIgaXNQYXJlbnRPZkVsZW1lbnQgPSAoMCwgX2NvbXBhcmVQb3NpdGlvbi5nZXRQYXJlbnRDb21wYXJhdG9yKSh7IGVsZW1lbnQ6IGVsZW1lbnQsIGluY2x1ZGVTZWxmOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuICF0aGlzLl9maWx0ZXIuc29tZShpc1BhcmVudE9mRWxlbWVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZmlsdGVyUGFyZW50RWxlbWVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWx0ZXJQYXJlbnRFbGVtZW50cyhlbGVtZW50KSB7XG4gICAgICAvLyBpZ25vcmUgYW5jZXN0b3JzIG9mIHRoZSBleGVtcHRlZCBzdWItdHJlZXNcbiAgICAgIHZhciBpc1BhcmVudE9mRWxlbWVudCA9ICgwLCBfY29tcGFyZVBvc2l0aW9uLmdldFBhcmVudENvbXBhcmF0b3IpKHsgcGFyZW50OiBlbGVtZW50IH0pO1xuICAgICAgcmV0dXJuICF0aGlzLl9maWx0ZXIuc29tZShpc1BhcmVudE9mRWxlbWVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGFuZGxlTXV0YXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgIHZhciBhZGRlZEVsZW1lbnRzID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKG11dGF0aW9uLmFkZGVkTm9kZXMpLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghYWRkZWRFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYWRkZWRGb2N1c2FibGVFbGVtZW50cyA9IHRoaXMubGlzdFF1ZXJ5Rm9jdXNhYmxlKGFkZGVkRWxlbWVudHMpO1xuICAgICAgICB0aGlzLnJlbmRlckluZXJ0KGFkZGVkRm9jdXNhYmxlRWxlbWVudHMpO1xuICAgICAgfSBlbHNlIGlmIChtdXRhdGlvbi50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJJbmVydChbbXV0YXRpb24udGFyZ2V0XSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEluZXJ0U3VidHJlZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXNhYmxlZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dDtcblxuICBpZiAoIWNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSBzdXBwb3J0cyB0ZXN0cyBhcmUgcnVuIGJlZm9yZSBpbnRlcmNlcHRpbmcgdGhlIFRhYiBrZXksXG4gIC8vIG9yIElFMTAgYW5kIElFMTEgd2lsbCBmYWlsIHRvIHByb2Nlc3MgdGhlIGZpcnN0IFRhYiBrZXkgZXZlbnQuIE5vdFxuICAvLyBsaW1pdGluZyB0aGlzIHdhcm0tdXAgdG8gSUUgYmVjYXVzZSBpdCBtYXkgYmUgYSBwcm9ibGVtIGVsc2V3aGVyZSwgdG9vLlxuICAoMCwgX3RhYnNlcXVlbmNlMi5kZWZhdWx0KSgpO1xuXG4gIHJldHVybiAoMCwgX2tleTIuZGVmYXVsdCkoe1xuICAgIC8vIFNhZmFyaSBvbiBPU1ggbWF5IHJlcXVpcmUgQUxUK1RBQiB0byByZWFjaCBsaW5rcyxcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8xNDZcbiAgICAnP2FsdCs/c2hpZnQrdGFiJzogZnVuY3Rpb24gYWx0U2hpZnRUYWIoZXZlbnQpIHtcbiAgICAgIC8vIHdlJ3JlIGNvbXBsZXRlbHkgdGFraW5nIG92ZXIgdGhlIFRhYiBrZXkgaGFuZGxpbmdcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBzZXF1ZW5jZSA9ICgwLCBfdGFic2VxdWVuY2UyLmRlZmF1bHQpKHtcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBiYWNrd2FyZCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgdmFyIGZpcnN0ID0gc2VxdWVuY2VbMF07XG4gICAgICB2YXIgbGFzdCA9IHNlcXVlbmNlW3NlcXVlbmNlLmxlbmd0aCAtIDFdO1xuXG4gICAgICAvLyB3cmFwIGFyb3VuZCBmaXJzdCB0byBsYXN0LCBsYXN0IHRvIGZpcnN0XG4gICAgICB2YXIgc291cmNlID0gYmFja3dhcmQgPyBmaXJzdCA6IGxhc3Q7XG4gICAgICB2YXIgdGFyZ2V0ID0gYmFja3dhcmQgPyBsYXN0IDogZmlyc3Q7XG4gICAgICBpZiAoKDAsIF9hY3RpdmVFbGVtZW50Mi5kZWZhdWx0KShzb3VyY2UpKSB7XG4gICAgICAgIHRhcmdldC5mb2N1cygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGZpbmQgY3VycmVudCBwb3NpdGlvbiBpbiB0YWJzZXF1ZW5jZVxuICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHZvaWQgMDtcbiAgICAgIHZhciBmb3VuZCA9IHNlcXVlbmNlLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgIGlmICghKDAsIF9hY3RpdmVFbGVtZW50Mi5kZWZhdWx0KShlbGVtZW50KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgIC8vIHJlZGlyZWN0IHRvIGZpcnN0IGFzIHdlJ3JlIG5vdCBpbiBvdXIgdGFic2VxdWVuY2VcbiAgICAgICAgZmlyc3QuZm9jdXMoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBzaGlmdCBmb2N1cyB0byBwcmV2aW91cy9uZXh0IGVsZW1lbnQgaW4gdGhlIHNlcXVlbmNlXG4gICAgICB2YXIgb2Zmc2V0ID0gYmFja3dhcmQgPyAtMSA6IDE7XG4gICAgICBzZXF1ZW5jZVtjdXJyZW50SW5kZXggKyBvZmZzZXRdLmZvY3VzKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBfYWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2lzL2FjdGl2ZS1lbGVtZW50Jyk7XG5cbnZhciBfYWN0aXZlRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hY3RpdmVFbGVtZW50KTtcblxudmFyIF90YWJzZXF1ZW5jZSA9IHJlcXVpcmUoJy4uL3F1ZXJ5L3RhYnNlcXVlbmNlJyk7XG5cbnZhciBfdGFic2VxdWVuY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFic2VxdWVuY2UpO1xuXG52YXIgX2tleSA9IHJlcXVpcmUoJy4uL3doZW4va2V5Jyk7XG5cbnZhciBfa2V5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFiLWZvY3VzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLy8gY29kZXMgbW9zdGx5IGNsb25lZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rZWl0aGFtdXMvandlcnR5L2Jsb2IvbWFzdGVyL2p3ZXJ0eS5qc1xuLy8gZGVsaWJlcmF0ZWx5IG5vdCBleHBvc2luZyBjaGFyYWN0ZXJzIGxpa2UgPCwuLSMqIGJlY2F1c2UgdGhleSB2YXJ5ICp3aWxkbHkqXG4vLyBhY3Jvc3Mga2V5Ym9hcmQgbGF5b3V0cyBhbmQgbWF5IGNhdXNlIHZhcmlvdXMgcHJvYmxlbXNcbi8vIChlLmcuIFwiKlwiIGlzIFwiU2hpZnQgK1wiIG9uIGEgR2VybWFuIE1hYyBrZXlib2FyZClcbi8vIChlLmcuIFwiQFwiIGlzIFwiQWx0IExcIiBvbiBhIEdlcm1hbiBNYWMga2V5Ym9hcmQpXG5cbnZhciBrZXljb2RlID0ge1xuICAvLyBFbGVtZW50IEZvY3VzXG4gIHRhYjogOSxcblxuICAvLyBOYXZpZ2F0aW9uXG4gIGxlZnQ6IDM3LFxuICB1cDogMzgsXG4gIHJpZ2h0OiAzOSxcbiAgZG93bjogNDAsXG4gIHBhZ2VVcDogMzMsXG4gICdwYWdlLXVwJzogMzMsXG4gIHBhZ2VEb3duOiAzNCxcbiAgJ3BhZ2UtZG93bic6IDM0LFxuICBlbmQ6IDM1LFxuICBob21lOiAzNixcblxuICAvLyBBY3Rpb25cbiAgZW50ZXI6IDEzLFxuICBlc2NhcGU6IDI3LFxuICBzcGFjZTogMzIsXG5cbiAgLy8gTW9kaWZpZXJcbiAgc2hpZnQ6IDE2LFxuICBjYXBzTG9jazogMjAsXG4gICdjYXBzLWxvY2snOiAyMCxcbiAgY3RybDogMTcsXG4gIGFsdDogMTgsXG4gIG1ldGE6IDkxLFxuICAvLyBpbiBmaXJlZm94OiAyMjRcbiAgLy8gb24gbWFjIChjaHJvbWUpOiBtZXRhLWxlZnQ9OTEsIG1ldGEtcmlnaHQ9OTNcbiAgLy8gb24gd2luIChJRTExKTogbWV0YS1sZWZ0PTkxLCBtZXRhLXJpZ2h0PTkyXG4gIHBhdXNlOiAxOSxcblxuICAvLyBDb250ZW50IE1hbmlwdWxhdGlvblxuICBpbnNlcnQ6IDQ1LFxuICAnZGVsZXRlJzogNDYsXG4gIGJhY2tzcGFjZTogOCxcblxuICAvLyB0aGUgc2FtZSBsb2dpY2FsIGtleSBtYXkgYmUgaWRlbnRpZmllZCB0aHJvdWdoIGRpZmZlcmVudCBrZXlDb2Rlc1xuICBfYWxpYXM6IHtcbiAgICA5MTogWzkyLCA5MywgMjI0XVxuICB9XG59O1xuXG4vLyBGdW5jdGlvbiBrZXlzICgxMTIgLSAxMzcpXG4vLyBOT1RFOiBub3QgZXZlcnkga2V5Ym9hcmQga25vd3MgRjEzK1xuZm9yICh2YXIgbiA9IDE7IG4gPCAyNjsgbisrKSB7XG4gIGtleWNvZGVbJ2YnICsgbl0gPSBuICsgMTExO1xufVxuXG4vLyBOdW1iZXIga2V5cyAoNDgtNTcsIG51bXBhZCA5Ni0xMDUpXG4vLyBOT1RFOiBub3QgZXZlcnkga2V5Ym9hcmQga25vd3MgbnVtLTArXG5mb3IgKHZhciBfbiA9IDA7IF9uIDwgMTA7IF9uKyspIHtcbiAgdmFyIGNvZGUgPSBfbiArIDQ4O1xuICB2YXIgbnVtQ29kZSA9IF9uICsgOTY7XG4gIGtleWNvZGVbX25dID0gY29kZTtcbiAga2V5Y29kZVsnbnVtLScgKyBfbl0gPSBudW1Db2RlO1xuICBrZXljb2RlLl9hbGlhc1tjb2RlXSA9IFtudW1Db2RlXTtcbn1cblxuLy8gTGF0aW4gY2hhcmFjdGVycyAoNjUgLSA5MClcbmZvciAodmFyIF9uMiA9IDA7IF9uMiA8IDI2OyBfbjIrKykge1xuICB2YXIgX2NvZGUgPSBfbjIgKyA2NTtcbiAgdmFyIG5hbWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKF9jb2RlKS50b0xvd2VyQ2FzZSgpO1xuICBrZXljb2RlW25hbWVdID0gX2NvZGU7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGtleWNvZGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleWNvZGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIGNvbnRleHQgPSBfcmVmMi5jb250ZXh0LFxuICAgICAgY2FsbGJhY2sgPSBfcmVmMi5jYWxsYmFjayxcbiAgICAgIGNvbmZpZyA9IF9yZWYyLmNvbmZpZztcblxuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2JzZXJ2ZS9zaGFkb3ctbXV0YXRpb25zIHJlcXVpcmVzIG9wdGlvbnMuY2FsbGJhY2sgdG8gYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKCh0eXBlb2YgY29uZmlnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb25maWcpKSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvYnNlcnZlL3NoYWRvdy1tdXRhdGlvbnMgcmVxdWlyZXMgb3B0aW9ucy5jb25maWcgdG8gYmUgYW4gb2JqZWN0Jyk7XG4gIH1cblxuICBpZiAoIXdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgLy8gbm90IHN1cHBvcnRpbmcgSUUxMCB2aWEgTXV0YXRpb24gRXZlbnRzLCBiZWNhdXNlIHRoZXkncmUgdG9vIGV4cGVuc2l2ZVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL0V2ZW50cy9NdXRhdGlvbl9ldmVudHNcbiAgICByZXR1cm4ge1xuICAgICAgZGlzZW5nYWdlOiBmdW5jdGlvbiBkaXNlbmdhZ2UoKSB7fVxuICAgIH07XG4gIH1cblxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAnb2JzZXJ2ZS9zaGFkb3ctbXV0YXRpb25zJyxcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgZGVmYXVsdFRvRG9jdW1lbnQ6IHRydWUsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9KTtcblxuICB2YXIgc2VydmljZSA9IG5ldyBTaGFkb3dNdXRhdGlvbk9ic2VydmVyKHtcbiAgICBjb250ZXh0OiBlbGVtZW50LFxuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBjb25maWc6IGNvbmZpZ1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGRpc2VuZ2FnZTogc2VydmljZS5kaXNlbmdhZ2VcbiAgfTtcbn07XG5cbnZhciBfbm9kZUFycmF5ID0gcmVxdWlyZSgnLi4vdXRpbC9ub2RlLWFycmF5Jyk7XG5cbnZhciBfbm9kZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25vZGVBcnJheSk7XG5cbnZhciBfc2hhZG93SG9zdHMgPSByZXF1aXJlKCcuLi9xdWVyeS9zaGFkb3ctaG9zdHMnKTtcblxudmFyIF9zaGFkb3dIb3N0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zaGFkb3dIb3N0cyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIHNoYWRvd09ic2VydmVyQ29uZmlnID0ge1xuICBjaGlsZExpc3Q6IHRydWUsXG4gIHN1YnRyZWU6IHRydWVcbn07XG5cbnZhciBTaGFkb3dNdXRhdGlvbk9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaGFkb3dNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICAgIGNhbGxiYWNrID0gX3JlZi5jYWxsYmFjayxcbiAgICAgICAgY29uZmlnID0gX3JlZi5jb25maWc7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2hhZG93TXV0YXRpb25PYnNlcnZlcik7XG5cbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcblxuICAgIHRoaXMuZGlzZW5nYWdlID0gdGhpcy5kaXNlbmdhZ2UuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuY2xpZW50T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjayk7XG4gICAgdGhpcy5ob3N0T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG4gICAgICByZXR1cm4gbXV0YXRpb25zLmZvckVhY2goX3RoaXMuaGFuZGxlSG9zdE11dGF0aW9uLCBfdGhpcyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm9ic2VydmVDb250ZXh0KGNvbnRleHQpO1xuICAgIHRoaXMub2JzZXJ2ZVNoYWRvd0hvc3RzKGNvbnRleHQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNoYWRvd011dGF0aW9uT2JzZXJ2ZXIsIFt7XG4gICAga2V5OiAnZGlzZW5nYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzZW5nYWdlKCkge1xuICAgICAgdGhpcy5jbGllbnRPYnNlcnZlciAmJiB0aGlzLmNsaWVudE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuY2xpZW50T2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgdGhpcy5ob3N0T2JzZXJ2ZXIgJiYgdGhpcy5ob3N0T2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5ob3N0T2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29ic2VydmVTaGFkb3dIb3N0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9ic2VydmVTaGFkb3dIb3N0cyhjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGhvc3RzID0gKDAsIF9zaGFkb3dIb3N0czIuZGVmYXVsdCkoe1xuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICB9KTtcblxuICAgICAgaG9zdHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLm9ic2VydmVDb250ZXh0KGVsZW1lbnQuc2hhZG93Um9vdCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvYnNlcnZlQ29udGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9ic2VydmVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIHRoaXMuY2xpZW50T2JzZXJ2ZXIub2JzZXJ2ZShjb250ZXh0LCB0aGlzLmNvbmZpZyk7XG4gICAgICB0aGlzLmhvc3RPYnNlcnZlci5vYnNlcnZlKGNvbnRleHQsIHNoYWRvd09ic2VydmVyQ29uZmlnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdoYW5kbGVIb3N0TXV0YXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVIb3N0TXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgIGlmIChtdXRhdGlvbi50eXBlICE9PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBhZGRlZEVsZW1lbnRzID0gKDAsIF9ub2RlQXJyYXkyLmRlZmF1bHQpKG11dGF0aW9uLmFkZGVkTm9kZXMpLmZpbHRlcihmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREU7XG4gICAgICB9KTtcbiAgICAgIGFkZGVkRWxlbWVudHMuZm9yRWFjaCh0aGlzLm9ic2VydmVTaGFkb3dIb3N0cywgdGhpcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoYWRvd011dGF0aW9uT2JzZXJ2ZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZG93LW11dGF0aW9ucy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICAgIGluY2x1ZGVDb250ZXh0ID0gX3JlZi5pbmNsdWRlQ29udGV4dCxcbiAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsXG4gICAgICBfcmVmJHN0cmF0ZWd5ID0gX3JlZi5zdHJhdGVneSxcbiAgICAgIHN0cmF0ZWd5ID0gX3JlZiRzdHJhdGVneSA9PT0gdW5kZWZpbmVkID8gJ3F1aWNrJyA6IF9yZWYkc3RyYXRlZ3k7XG5cbiAgdmFyIGVsZW1lbnQgPSAoMCwgX2NvbnRleHRUb0VsZW1lbnQyLmRlZmF1bHQpKHtcbiAgICBsYWJlbDogJ3F1ZXJ5L2ZvY3VzYWJsZScsXG4gICAgcmVzb2x2ZURvY3VtZW50OiB0cnVlLFxuICAgIGRlZmF1bHRUb0RvY3VtZW50OiB0cnVlLFxuICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgfSk7XG5cbiAgdmFyIG9wdGlvbnMgPSB7XG4gICAgY29udGV4dDogZWxlbWVudCxcbiAgICBpbmNsdWRlQ29udGV4dDogaW5jbHVkZUNvbnRleHQsXG4gICAgaW5jbHVkZU9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZSxcbiAgICBzdHJhdGVneTogc3RyYXRlZ3lcbiAgfTtcblxuICBpZiAoc3RyYXRlZ3kgPT09ICdxdWljaycpIHtcbiAgICByZXR1cm4gKDAsIF9mb2N1c2FibGU0LmRlZmF1bHQpKG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKHN0cmF0ZWd5ID09PSAnc3RyaWN0JyB8fCBzdHJhdGVneSA9PT0gJ2FsbCcpIHtcbiAgICByZXR1cm4gKDAsIF9mb2N1c2FibGUyLmRlZmF1bHQpKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigncXVlcnkvZm9jdXNhYmxlIHJlcXVpcmVzIG9wdGlvbi5zdHJhdGVneSB0byBiZSBvbmUgb2YgW1wicXVpY2tcIiwgXCJzdHJpY3RcIiwgXCJhbGxcIl0nKTtcbn07XG5cbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcblxudmFyIF9mb2N1c2FibGUgPSByZXF1aXJlKCcuL2ZvY3VzYWJsZS5zdHJpY3QnKTtcblxudmFyIF9mb2N1c2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNhYmxlKTtcblxudmFyIF9mb2N1c2FibGUzID0gcmVxdWlyZSgnLi9mb2N1c2FibGUucXVpY2snKTtcblxudmFyIF9mb2N1c2FibGU0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNhYmxlMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjZm9jdXNhYmxlXG4vLyBodHRwczovL3d3dy53My5vcmcvV0FJL1BGL2FyaWEtcHJhY3RpY2VzLyNrZXlib2FyZFxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzYWJsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBxdWVyeUZvY3VzYWJsZVF1aWNrO1xuXG52YXIgX2ZvY3VzYWJsZSA9IHJlcXVpcmUoJy4uL3NlbGVjdG9yL2ZvY3VzYWJsZScpO1xuXG52YXIgX2ZvY3VzYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c2FibGUpO1xuXG52YXIgX2ZvY3VzYWJsZTMgPSByZXF1aXJlKCcuLi9pcy9mb2N1c2FibGUnKTtcblxudmFyIF9mb2N1c2FibGU0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNhYmxlMyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjZm9jdXNhYmxlXG4vLyBodHRwczovL3d3dy53My5vcmcvV0FJL1BGL2FyaWEtcHJhY3RpY2VzLyNrZXlib2FyZFxuXG5mdW5jdGlvbiBxdWVyeUZvY3VzYWJsZVF1aWNrKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgaW5jbHVkZUNvbnRleHQgPSBfcmVmLmluY2x1ZGVDb250ZXh0LFxuICAgICAgaW5jbHVkZU9ubHlUYWJiYWJsZSA9IF9yZWYuaW5jbHVkZU9ubHlUYWJiYWJsZTtcblxuICB2YXIgX3NlbGVjdG9yID0gKDAsIF9mb2N1c2FibGUyLmRlZmF1bHQpKCk7XG4gIHZhciBlbGVtZW50cyA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbChfc2VsZWN0b3IpO1xuICAvLyB0aGUgc2VsZWN0b3IgcG90ZW50aWFsbHkgbWF0Y2hlcyBtb3JlIHRoYW4gcmVhbGx5IGlzIGZvY3VzYWJsZVxuXG4gIHZhciBfaXNGb2N1c2FibGUgPSBfZm9jdXNhYmxlNC5kZWZhdWx0LnJ1bGVzLmV4Y2VwdCh7XG4gICAgb25seVRhYmJhYmxlOiBpbmNsdWRlT25seVRhYmJhYmxlXG4gIH0pO1xuXG4gIHZhciByZXN1bHQgPSBbXS5maWx0ZXIuY2FsbChlbGVtZW50cywgX2lzRm9jdXNhYmxlKTtcblxuICAvLyBhZGQgY29udGV4dCBpZiByZXF1ZXN0ZWQgYW5kIGZvY3VzYWJsZVxuICBpZiAoaW5jbHVkZUNvbnRleHQgJiYgX2lzRm9jdXNhYmxlKGNvbnRleHQpKSB7XG4gICAgcmVzdWx0LnVuc2hpZnQoY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1c2FibGUucXVpY2suanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcXVlcnlGb2N1c2FibGVTdHJpY3Q7XG5cbnZhciBfZm9jdXNhYmxlID0gcmVxdWlyZSgnLi4vaXMvZm9jdXNhYmxlJyk7XG5cbnZhciBfZm9jdXNhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzYWJsZSk7XG5cbnZhciBfZm9jdXNSZWxldmFudCA9IHJlcXVpcmUoJy4uL2lzL2ZvY3VzLXJlbGV2YW50Jyk7XG5cbnZhciBfZm9jdXNSZWxldmFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1JlbGV2YW50KTtcblxudmFyIF9nZXREb2N1bWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWRvY3VtZW50Jyk7XG5cbnZhciBfZ2V0RG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0RG9jdW1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXIoY29uZGl0aW9uKSB7XG4gIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZUZpbHRlclxuICB2YXIgZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKG5vZGUpIHtcbiAgICBpZiAobm9kZS5zaGFkb3dSb290KSB7XG4gICAgICAvLyByZXR1cm4gU2hhZG93Um9vdCBlbGVtZW50cyByZWdhcmRsZXNzIG9mIHRoZW0gYmVpbmcgZm9jdXNhYmxlLFxuICAgICAgLy8gc28gdGhleSBjYW4gYmUgd2Fsa2VkIHJlY3Vyc2l2ZWx5IGxhdGVyXG4gICAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICAgIH1cblxuICAgIGlmIChjb25kaXRpb24obm9kZSkpIHtcbiAgICAgIC8vIGZpbmRzIGVsZW1lbnRzIHRoYXQgY291bGQgaGF2ZSBiZWVuIGZvdW5kIGJ5IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoKVxuICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICB9XG5cbiAgICByZXR1cm4gTm9kZUZpbHRlci5GSUxURVJfU0tJUDtcbiAgfTtcbiAgLy8gSUUgcmVxdWlyZXMgYSBmdW5jdGlvbiwgQnJvd3NlcnMgcmVxdWlyZSB7YWNjZXB0Tm9kZTogZnVuY3Rpb259XG4gIC8vIHNlZSBodHRwOi8vd3d3LmJlbm5hZGVsLmNvbS9ibG9nLzI2MDctZmluZGluZy1odG1sLWNvbW1lbnQtbm9kZXMtaW4tdGhlLWRvbS11c2luZy10cmVld2Fsa2VyLmh0bVxuICBmaWx0ZXIuYWNjZXB0Tm9kZSA9IGZpbHRlcjtcbiAgcmV0dXJuIGZpbHRlcjtcbn1cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjZm9jdXNhYmxlXG4vLyBodHRwczovL3d3dy53My5vcmcvV0FJL1BGL2FyaWEtcHJhY3RpY2VzLyNrZXlib2FyZFxuXG52YXIgUG9zc2libHlGb2N1c2FibGVGaWx0ZXIgPSBjcmVhdGVGaWx0ZXIoX2ZvY3VzUmVsZXZhbnQyLmRlZmF1bHQpO1xuXG5mdW5jdGlvbiBxdWVyeUZvY3VzYWJsZVN0cmljdCgpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dCxcbiAgICAgIGluY2x1ZGVDb250ZXh0ID0gX3JlZi5pbmNsdWRlQ29udGV4dCxcbiAgICAgIGluY2x1ZGVPbmx5VGFiYmFibGUgPSBfcmVmLmluY2x1ZGVPbmx5VGFiYmFibGUsXG4gICAgICBzdHJhdGVneSA9IF9yZWYuc3RyYXRlZ3k7XG5cbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIHZhciBfaXNGb2N1c2FibGUgPSBfZm9jdXNhYmxlMi5kZWZhdWx0LnJ1bGVzLmV4Y2VwdCh7XG4gICAgb25seVRhYmJhYmxlOiBpbmNsdWRlT25seVRhYmJhYmxlXG4gIH0pO1xuXG4gIHZhciBfZG9jdW1lbnQgPSAoMCwgX2dldERvY3VtZW50Mi5kZWZhdWx0KShjb250ZXh0KTtcbiAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9jcmVhdGVUcmVlV2Fsa2VyXG4gIHZhciB3YWxrZXIgPSBfZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihcbiAgLy8gcm9vdCBlbGVtZW50IHRvIHN0YXJ0IHNlYXJjaCBpblxuICBjb250ZXh0LFxuICAvLyBlbGVtZW50IHR5cGUgZmlsdGVyXG4gIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULFxuICAvLyBjdXN0b20gTm9kZUZpbHRlciBmaWx0ZXJcbiAgc3RyYXRlZ3kgPT09ICdhbGwnID8gUG9zc2libHlGb2N1c2FibGVGaWx0ZXIgOiBjcmVhdGVGaWx0ZXIoX2lzRm9jdXNhYmxlKSxcbiAgLy8gZGVwcmVjYXRlZCwgYnV0IElFIHJlcXVpcmVzIGl0XG4gIGZhbHNlKTtcblxuICB2YXIgbGlzdCA9IFtdO1xuXG4gIHdoaWxlICh3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgIGlmICh3YWxrZXIuY3VycmVudE5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgaWYgKF9pc0ZvY3VzYWJsZSh3YWxrZXIuY3VycmVudE5vZGUpKSB7XG4gICAgICAgIGxpc3QucHVzaCh3YWxrZXIuY3VycmVudE5vZGUpO1xuICAgICAgfVxuXG4gICAgICBsaXN0ID0gbGlzdC5jb25jYXQocXVlcnlGb2N1c2FibGVTdHJpY3Qoe1xuICAgICAgICBjb250ZXh0OiB3YWxrZXIuY3VycmVudE5vZGUuc2hhZG93Um9vdCxcbiAgICAgICAgaW5jbHVkZU9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZSxcbiAgICAgICAgc3RyYXRlZ3k6IHN0cmF0ZWd5XG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3QucHVzaCh3YWxrZXIuY3VycmVudE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBjb250ZXh0IGlmIHJlcXVlc3RlZCBhbmQgZm9jdXNhYmxlXG4gIGlmIChpbmNsdWRlQ29udGV4dCkge1xuICAgIGlmIChzdHJhdGVneSA9PT0gJ2FsbCcpIHtcbiAgICAgIGlmICgoMCwgX2ZvY3VzUmVsZXZhbnQyLmRlZmF1bHQpKGNvbnRleHQpKSB7XG4gICAgICAgIGxpc3QudW5zaGlmdChjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKF9pc0ZvY3VzYWJsZShjb250ZXh0KSkge1xuICAgICAgbGlzdC51bnNoaWZ0KGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsaXN0O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1c2FibGUuc3RyaWN0LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHF1ZXJ5U2hhZG93SG9zdHM7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvY29udGV4dC10by1lbGVtZW50Jyk7XG5cbnZhciBfY29udGV4dFRvRWxlbWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250ZXh0VG9FbGVtZW50KTtcblxudmFyIF9nZXREb2N1bWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvZ2V0LWRvY3VtZW50Jyk7XG5cbnZhciBfZ2V0RG9jdW1lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0RG9jdW1lbnQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGVGaWx0ZXJcbnZhciBmaWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIobm9kZSkge1xuICBpZiAobm9kZS5zaGFkb3dSb290KSB7XG4gICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgfVxuXG4gIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xufTtcbi8vIElFIHJlcXVpcmVzIGEgZnVuY3Rpb24sIEJyb3dzZXJzIHJlcXVpcmUge2FjY2VwdE5vZGU6IGZ1bmN0aW9ufVxuLy8gc2VlIGh0dHA6Ly93d3cuYmVubmFkZWwuY29tL2Jsb2cvMjYwNy1maW5kaW5nLWh0bWwtY29tbWVudC1ub2Rlcy1pbi10aGUtZG9tLXVzaW5nLXRyZWV3YWxrZXIuaHRtXG5maWx0ZXIuYWNjZXB0Tm9kZSA9IGZpbHRlcjtcblxuZnVuY3Rpb24gcXVlcnlTaGFkb3dIb3N0cygpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgY29udGV4dCA9IF9yZWYuY29udGV4dDtcblxuICB2YXIgZWxlbWVudCA9ICgwLCBfY29udGV4dFRvRWxlbWVudDIuZGVmYXVsdCkoe1xuICAgIGxhYmVsOiAncXVlcnkvc2hhZG93LWhvc3RzJyxcbiAgICByZXNvbHZlRG9jdW1lbnQ6IHRydWUsXG4gICAgZGVmYXVsdFRvRG9jdW1lbnQ6IHRydWUsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9KTtcblxuICB2YXIgX2RvY3VtZW50ID0gKDAsIF9nZXREb2N1bWVudDIuZGVmYXVsdCkoY29udGV4dCk7XG4gIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvY3JlYXRlVHJlZVdhbGtlclxuICB2YXIgd2Fsa2VyID0gX2RvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoXG4gIC8vIHJvb3QgZWxlbWVudCB0byBzdGFydCBzZWFyY2ggaW5cbiAgZWxlbWVudCxcbiAgLy8gZWxlbWVudCB0eXBlIGZpbHRlclxuICBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCxcbiAgLy8gY3VzdG9tIE5vZGVGaWx0ZXIgZmlsdGVyXG4gIGZpbHRlcixcbiAgLy8gZGVwcmVjYXRlZCwgYnV0IElFIHJlcXVpcmVzIGl0XG4gIGZhbHNlKTtcblxuICB2YXIgbGlzdCA9IFtdO1xuXG4gIGlmIChlbGVtZW50LnNoYWRvd1Jvb3QpIHtcbiAgICAvLyBUcmVlV2Fsa2VyIGRvZXMgbm90IHJ1biB0aGUgZmlsdGVyIG9uIHRoZSBjb250ZXh0IGVsZW1lbnRcbiAgICBsaXN0LnB1c2goZWxlbWVudCk7XG4gICAgbGlzdCA9IGxpc3QuY29uY2F0KHF1ZXJ5U2hhZG93SG9zdHMoe1xuICAgICAgY29udGV4dDogZWxlbWVudC5zaGFkb3dSb290XG4gICAgfSkpO1xuICB9XG5cbiAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgbGlzdC5wdXNoKHdhbGtlci5jdXJyZW50Tm9kZSk7XG4gICAgbGlzdCA9IGxpc3QuY29uY2F0KHF1ZXJ5U2hhZG93SG9zdHMoe1xuICAgICAgY29udGV4dDogd2Fsa2VyLmN1cnJlbnROb2RlLnNoYWRvd1Jvb3RcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhZG93LWhvc3RzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgaW5jbHVkZUNvbnRleHQgPSBfcmVmLmluY2x1ZGVDb250ZXh0LFxuICAgICAgaW5jbHVkZU9ubHlUYWJiYWJsZSA9IF9yZWYuaW5jbHVkZU9ubHlUYWJiYWJsZSxcbiAgICAgIHN0cmF0ZWd5ID0gX3JlZi5zdHJhdGVneTtcblxuICB2YXIgX2lzVGFiYmFibGUgPSBfdGFiYmFibGUyLmRlZmF1bHQucnVsZXMuZXhjZXB0KHtcbiAgICBvbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGVcbiAgfSk7XG5cbiAgcmV0dXJuICgwLCBfZm9jdXNhYmxlMi5kZWZhdWx0KSh7XG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBpbmNsdWRlQ29udGV4dDogaW5jbHVkZUNvbnRleHQsXG4gICAgaW5jbHVkZU9ubHlUYWJiYWJsZTogaW5jbHVkZU9ubHlUYWJiYWJsZSxcbiAgICBzdHJhdGVneTogc3RyYXRlZ3lcbiAgfSkuZmlsdGVyKF9pc1RhYmJhYmxlKTtcbn07XG5cbnZhciBfZm9jdXNhYmxlID0gcmVxdWlyZSgnLi9mb2N1c2FibGUnKTtcblxudmFyIF9mb2N1c2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNhYmxlKTtcblxudmFyIF90YWJiYWJsZSA9IHJlcXVpcmUoJy4uL2lzL3RhYmJhYmxlJyk7XG5cbnZhciBfdGFiYmFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiYmFibGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjc2VxdWVudGlhbC1mb2N1cy1uYXZpZ2F0aW9uLWFuZC10aGUtdGFiaW5kZXgtYXR0cmlidXRlXG4vLyBodHRwczovL3d3dy53My5vcmcvV0FJL1BGL2FyaWEtcHJhY3RpY2VzLyNrZXlib2FyZFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFiYmFibGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICBpbmNsdWRlQ29udGV4dCA9IF9yZWYuaW5jbHVkZUNvbnRleHQsXG4gICAgICBpbmNsdWRlT25seVRhYmJhYmxlID0gX3JlZi5pbmNsdWRlT25seVRhYmJhYmxlLFxuICAgICAgc3RyYXRlZ3kgPSBfcmVmLnN0cmF0ZWd5O1xuXG4gIGlmICghc3VwcG9ydHMpIHtcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XG4gIH1cblxuICB2YXIgX2NvbnRleHQgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkoY29udGV4dClbMF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgZWxlbWVudHMgPSAoMCwgX3RhYmJhYmxlMi5kZWZhdWx0KSh7XG4gICAgY29udGV4dDogX2NvbnRleHQsXG4gICAgaW5jbHVkZUNvbnRleHQ6IGluY2x1ZGVDb250ZXh0LFxuICAgIGluY2x1ZGVPbmx5VGFiYmFibGU6IGluY2x1ZGVPbmx5VGFiYmFibGUsXG4gICAgc3RyYXRlZ3k6IHN0cmF0ZWd5XG4gIH0pO1xuXG4gIGlmIChkb2N1bWVudC5ib2R5LmNyZWF0ZVNoYWRvd1Jvb3QgJiYgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkJMSU5LKSB7XG4gICAgLy8gc29ydCB0YWJpbmRleCBsb2NhbGl6ZWQgdG8gc2hhZG93IGRvbVxuICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzZcbiAgICBlbGVtZW50cyA9ICgwLCBfdGFic2VxdWVuY2U0LmRlZmF1bHQpKGVsZW1lbnRzLCBfY29udGV4dCwgc29ydEVsZW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtZW50cyA9IHNvcnRFbGVtZW50cyhlbGVtZW50cywgX2NvbnRleHQpO1xuICB9XG5cbiAgaWYgKGluY2x1ZGVDb250ZXh0KSB7XG4gICAgLy8gaWYgd2UgaW5jbHVkZSB0aGUgY29udGV4dCBpdHNlbGYsIGl0IGhhcyB0byBiZSB0aGUgZmlyc3RcbiAgICAvLyBlbGVtZW50IG9mIHRoZSBzZXF1ZW5jZVxuICAgIGVsZW1lbnRzID0gbW92ZUNvbnRleHRUb0JlZ2lubmluZyhlbGVtZW50cywgX2NvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRzO1xufTtcblxudmFyIF90YWJiYWJsZSA9IHJlcXVpcmUoJy4vdGFiYmFibGUnKTtcblxudmFyIF90YWJiYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJiYWJsZSk7XG5cbnZhciBfbm9kZUFycmF5ID0gcmVxdWlyZSgnLi4vdXRpbC9ub2RlLWFycmF5Jyk7XG5cbnZhciBfbm9kZUFycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX25vZGVBcnJheSk7XG5cbnZhciBfcGxhdGZvcm0gPSByZXF1aXJlKCcuLi91dGlsL3BsYXRmb3JtJyk7XG5cbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xuXG52YXIgX3RhYnNlcXVlbmNlID0gcmVxdWlyZSgnLi90YWJzZXF1ZW5jZS5zb3J0LWFyZWEnKTtcblxudmFyIF90YWJzZXF1ZW5jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJzZXF1ZW5jZSk7XG5cbnZhciBfdGFic2VxdWVuY2UzID0gcmVxdWlyZSgnLi90YWJzZXF1ZW5jZS5zb3J0LXNoYWRvd2VkJyk7XG5cbnZhciBfdGFic2VxdWVuY2U0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFic2VxdWVuY2UzKTtcblxudmFyIF90YWJzZXF1ZW5jZTUgPSByZXF1aXJlKCcuL3RhYnNlcXVlbmNlLnNvcnQtdGFiaW5kZXgnKTtcblxudmFyIF90YWJzZXF1ZW5jZTYgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90YWJzZXF1ZW5jZTUpO1xuXG52YXIgX3N1cHBvcnRzMiA9IHJlcXVpcmUoJy4uL3N1cHBvcnRzL3N1cHBvcnRzJyk7XG5cbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHN1cHBvcnRzID0gdm9pZCAwO1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2VkaXRpbmcuaHRtbCNzZXF1ZW50aWFsLWZvY3VzLW5hdmlnYXRpb24tYW5kLXRoZS10YWJpbmRleC1hdHRyaWJ1dGVcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvUEYvYXJpYS1wcmFjdGljZXMvI2tleWJvYXJkXG5cbmZ1bmN0aW9uIG1vdmVDb250ZXh0VG9CZWdpbm5pbmcoZWxlbWVudHMsIGNvbnRleHQpIHtcbiAgdmFyIHBvcyA9IGVsZW1lbnRzLmluZGV4T2YoY29udGV4dCk7XG4gIGlmIChwb3MgPiAwKSB7XG4gICAgdmFyIHRtcCA9IGVsZW1lbnRzLnNwbGljZShwb3MsIDEpO1xuICAgIHJldHVybiB0bXAuY29uY2F0KGVsZW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50cztcbn1cblxuZnVuY3Rpb24gc29ydEVsZW1lbnRzKGVsZW1lbnRzLCBfY29udGV4dCkge1xuICBpZiAoc3VwcG9ydHMudGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbikge1xuICAgIC8vIFNvbWUgYnJvd3NlcnMgc29ydCA8YXJlYT4gaW4gRE9NIG9yZGVyLCBzb21lIHBsYWNlIHRoZSA8YXJlYT5zXG4gICAgLy8gd2hlcmUgdGhlIDxpbWc+IHJlZmVyZWNpbmcgdGhlbSB3b3VsZCd2ZSBiZWVuIGluIERPTSBvcmRlci5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzVcbiAgICBlbGVtZW50cyA9ICgwLCBfdGFic2VxdWVuY2UyLmRlZmF1bHQpKGVsZW1lbnRzLCBfY29udGV4dCk7XG4gIH1cblxuICBlbGVtZW50cyA9ICgwLCBfdGFic2VxdWVuY2U2LmRlZmF1bHQpKGVsZW1lbnRzKTtcbiAgcmV0dXJuIGVsZW1lbnRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYnNlcXVlbmNlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcbi8vIG1vdmUgPGFyZWE+IGVsZW1lbnRzIHRvIHRoZSBsb2NhdGlvbiBvZiB0aGUgPGltZz4gZWxlbWVudHMgdGhhdCByZWZlcmVuY2UgdGhlbVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGNvbnRleHQpIHtcbiAgLy8gaW1hZ2VzIC0gdW5sZXNzIHRoZXkgYXJlIGZvY3VzYWJsZSB0aGVtc2VsdmVzLCBsaWtlbHkgbm90XG4gIC8vIHBhcnQgb2YgdGhlIGVsZW1lbnRzIGxpc3QsIHNvIHdlJ2xsIGhhdmUgdG8gZmluZCB0aGVtIGFuZFxuICAvLyBzb3J0IHRoZW0gaW50byB0aGUgZWxlbWVudHMgbGlzdCBtYW51YWxseVxuICB2YXIgdXNlbWFwcyA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCgnaW1nW3VzZW1hcF0nKTtcbiAgdmFyIG1hcHMgPSBuZXcgTWFwcyhjb250ZXh0KTtcblxuICAvLyByZW1vdmUgYWxsIDxhcmVhPiBlbGVtZW50cyBmcm9tIHRoZSBlbGVtZW50cyBsaXN0LFxuICAvLyBidXQgcHV0IHRoZW0gdGhlIG1hcCBmb3IgbGF0ZXIgcmV0cmlldmFsXG4gIHZhciBfZWxlbWVudHMgPSBtYXBzLmV4dHJhY3RBcmVhc0Zyb21MaXN0KGVsZW1lbnRzKTtcblxuICBpZiAoIXVzZW1hcHMubGVuZ3RoKSB7XG4gICAgLy8gdGhlIGNvbnRleHQgZG9lcyBub3QgY29udGFpbiBhbnkgPGFyZWE+cyBzbyBubyBuZWVkXG4gICAgLy8gdG8gcmVwbGFjZSBhbnl0aGluZywganVzdCByZW1vdmUgYW55IG1hcHNcbiAgICByZXR1cm4gX2VsZW1lbnRzO1xuICB9XG5cbiAgcmV0dXJuICgwLCBfbWVyZ2VEb21PcmRlcjIuZGVmYXVsdCkoe1xuICAgIGxpc3Q6IF9lbGVtZW50cyxcbiAgICBlbGVtZW50czogdXNlbWFwcyxcbiAgICByZXNvbHZlRWxlbWVudDogZnVuY3Rpb24gcmVzb2x2ZUVsZW1lbnQoaW1hZ2UpIHtcbiAgICAgIHZhciBuYW1lID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCd1c2VtYXAnKS5zbGljZSgxKTtcbiAgICAgIHJldHVybiBtYXBzLmdldEFyZWFzRm9yKG5hbWUpO1xuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgX3RhYmJhYmxlID0gcmVxdWlyZSgnLi90YWJiYWJsZScpO1xuXG52YXIgX3RhYmJhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmJhYmxlKTtcblxudmFyIF9tZXJnZURvbU9yZGVyID0gcmVxdWlyZSgnLi4vdXRpbC9tZXJnZS1kb20tb3JkZXInKTtcblxudmFyIF9tZXJnZURvbU9yZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlRG9tT3JkZXIpO1xuXG52YXIgX2dldERvY3VtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9nZXQtZG9jdW1lbnQnKTtcblxudmFyIF9nZXREb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXREb2N1bWVudCk7XG5cbnZhciBfaW1hZ2VNYXAgPSByZXF1aXJlKCcuLi91dGlsL2ltYWdlLW1hcCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgTWFwcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWFwcyhjb250ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcHMpO1xuXG4gICAgdGhpcy5fZG9jdW1lbnQgPSAoMCwgX2dldERvY3VtZW50Mi5kZWZhdWx0KShjb250ZXh0KTtcbiAgICB0aGlzLm1hcHMgPSB7fTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNYXBzLCBbe1xuICAgIGtleTogJ2dldEFyZWFzRm9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXJlYXNGb3IobmFtZSkge1xuICAgICAgaWYgKCF0aGlzLm1hcHNbbmFtZV0pIHtcbiAgICAgICAgLy8gdGhlIG1hcCBpcyBub3QgZGVmaW5lZCB3aXRoaW4gdGhlIGNvbnRleHQsIHNvIHdlXG4gICAgICAgIC8vIGhhdmUgdG8gZ28gZmluZCBpdCBlbHNld2hlcmUgaW4gdGhlIGRvY3VtZW50XG4gICAgICAgIHRoaXMuYWRkTWFwQnlOYW1lKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5tYXBzW25hbWVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2FkZE1hcEJ5TmFtZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE1hcEJ5TmFtZShuYW1lKSB7XG4gICAgICB2YXIgbWFwID0gKDAsIF9pbWFnZU1hcC5nZXRNYXBCeU5hbWUpKG5hbWUsIHRoaXMuX2RvY3VtZW50KTtcbiAgICAgIGlmICghbWFwKSB7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIG1hcCwgdGhlIGltZ1t1c2VtYXBdIHdhc24ndCBkb2luZyBhbnl0aGluZyBhbnl3YXlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1hcHNbbWFwLm5hbWVdID0gKDAsIF90YWJiYWJsZTIuZGVmYXVsdCkoeyBjb250ZXh0OiBtYXAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZXh0cmFjdEFyZWFzRnJvbUxpc3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0QXJlYXNGcm9tTGlzdChlbGVtZW50cykge1xuICAgICAgLy8gcmVtb3ZlIGFsbCA8YXJlYT4gZWxlbWVudHMgZnJvbSB0aGUgZWxlbWVudHMgbGlzdCxcbiAgICAgIC8vIGJ1dCBwdXQgdGhlbSB0aGUgbWFwIGZvciBsYXRlciByZXRyaWV2YWxcbiAgICAgIHJldHVybiBlbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobm9kZU5hbWUgIT09ICdhcmVhJykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hcCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKCF0aGlzLm1hcHNbbWFwLm5hbWVdKSB7XG4gICAgICAgICAgdGhpcy5tYXBzW21hcC5uYW1lXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXBzW21hcC5uYW1lXS5wdXNoKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWFwcztcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJzZXF1ZW5jZS5zb3J0LWFyZWEuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGNvbnRleHQsIHNvcnRFbGVtZW50cykge1xuICB2YXIgc2hhZG93cyA9IG5ldyBTaGFkb3dzKGNvbnRleHQsIHNvcnRFbGVtZW50cyk7XG4gIHZhciBfZWxlbWVudHMgPSBzaGFkb3dzLmV4dHJhY3RFbGVtZW50cyhlbGVtZW50cyk7XG5cbiAgaWYgKF9lbGVtZW50cy5sZW5ndGggPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgIC8vIG5vIHNoYWRvd2VkIGNvbnRlbnQgZm91bmQsIG5vIG5lZWQgdG8gY29udGludWVcbiAgICByZXR1cm4gc29ydEVsZW1lbnRzKGVsZW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBzaGFkb3dzLnNvcnQoX2VsZW1lbnRzKTtcbn07XG5cbnZhciBfc2hhZG93SG9zdCA9IHJlcXVpcmUoJy4uL2dldC9zaGFkb3ctaG9zdCcpO1xuXG52YXIgX3NoYWRvd0hvc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2hhZG93SG9zdCk7XG5cbnZhciBfbWVyZ2VEb21PcmRlciA9IHJlcXVpcmUoJy4uL3V0aWwvbWVyZ2UtZG9tLW9yZGVyJyk7XG5cbnZhciBfbWVyZ2VEb21PcmRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZXJnZURvbU9yZGVyKTtcblxudmFyIF90YWJpbmRleFZhbHVlID0gcmVxdWlyZSgnLi4vdXRpbC90YWJpbmRleC12YWx1ZScpO1xuXG52YXIgX3RhYmluZGV4VmFsdWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdGFiaW5kZXhWYWx1ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBTaGFkb3dzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaGFkb3dzKGNvbnRleHQsIHNvcnRFbGVtZW50cykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaGFkb3dzKTtcblxuICAgIC8vIGRvY3VtZW50IGNvbnRleHQgd2UncmUgd29ya2luZyB3aXRoXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAvLyBjYWxsYmFjayB0aGF0IHNvcnRzIGFuIGFycmF5IG9mIGVsZW1lbnRzXG4gICAgdGhpcy5zb3J0RWxlbWVudHMgPSBzb3J0RWxlbWVudHM7XG4gICAgLy8gcmVmZXJlbmNlIHRvIGNyZWF0ZSB1bmlxdWUgSURzIGZvciBlYWNoIFNoYWRvd0hvc3RcbiAgICB0aGlzLmhvc3RDb3VudGVyID0gMTtcbiAgICAvLyByZWZlcmVuY2UgbWFwIGZvciBjaGlsZC1TaGFkb3dIb3N0cyBvZiBhIFNoYWRvd0hvc3RcbiAgICB0aGlzLmluSG9zdCA9IHt9O1xuICAgIC8vIHJlZmVyZW5jZSBtYXAgZm9yIGNoaWxkLVNoYWRvd0hvc3Qgb2YgdGhlIGRvY3VtZW50XG4gICAgdGhpcy5pbkRvY3VtZW50ID0gW107XG4gICAgLy8gcmVmZXJlbmNlIG1hcCBmb3IgU2hhZG93SG9zdHNcbiAgICB0aGlzLmhvc3RzID0ge307XG4gICAgLy8gcmVmZXJlbmNlIG1hcCBmb3IgdGFiYmFibGUgZWxlbWVudHMgb2YgYSBTaGFkb3dIb3N0XG4gICAgdGhpcy5lbGVtZW50cyA9IHt9O1xuICB9XG5cbiAgLy8gcmVtZW1iZXIgd2hpY2ggaG9zdHMgd2UgaGF2ZSB0byBzb3J0IHdpdGhpbiBsYXRlclxuXG5cbiAgX2NyZWF0ZUNsYXNzKFNoYWRvd3MsIFt7XG4gICAga2V5OiAnX3JlZ2lzdGVySG9zdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWdpc3Rlckhvc3QoaG9zdCkge1xuICAgICAgaWYgKGhvc3QuX3NvcnRpbmdJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2UgdGhlIFNoYWRvd0hvc3QgaWRlbnRpZmlhYmxlIChzZWUgY2xlYW51cCgpIGZvciB1bmRvKVxuICAgICAgaG9zdC5fc29ydGluZ0lkID0gJ3NoYWRvdy0nICsgdGhpcy5ob3N0Q291bnRlcisrO1xuICAgICAgdGhpcy5ob3N0c1tob3N0Ll9zb3J0aW5nSWRdID0gaG9zdDtcblxuICAgICAgLy8gaG9zdHMgbWF5IGNvbnRhaW4gb3RoZXIgaG9zdHNcbiAgICAgIHZhciBwYXJlbnRIb3N0ID0gKDAsIF9zaGFkb3dIb3N0Mi5kZWZhdWx0KSh7IGNvbnRleHQ6IGhvc3QgfSk7XG4gICAgICBpZiAocGFyZW50SG9zdCkge1xuICAgICAgICB0aGlzLl9yZWdpc3Rlckhvc3QocGFyZW50SG9zdCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVySG9zdFBhcmVudChob3N0LCBwYXJlbnRIb3N0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5Eb2N1bWVudC5wdXNoKGhvc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlbWVtYmVyIHdoaWNoIGhvc3QgaXMgdGhlIGNoaWxkIG9mIHdoaWNoIG90aGVyIGhvc3RcblxuICB9LCB7XG4gICAga2V5OiAnX3JlZ2lzdGVySG9zdFBhcmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWdpc3Rlckhvc3RQYXJlbnQoaG9zdCwgcGFyZW50KSB7XG4gICAgICBpZiAoIXRoaXMuaW5Ib3N0W3BhcmVudC5fc29ydGluZ0lkXSkge1xuICAgICAgICB0aGlzLmluSG9zdFtwYXJlbnQuX3NvcnRpbmdJZF0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbkhvc3RbcGFyZW50Ll9zb3J0aW5nSWRdLnB1c2goaG9zdCk7XG4gICAgfVxuXG4gICAgLy8gcmVtZW1iZXIgd2hpY2ggZWxlbWVudHMgYSBob3N0IGNvbnRhaW5zXG5cbiAgfSwge1xuICAgIGtleTogJ19yZWdpc3RlckVsZW1lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVnaXN0ZXJFbGVtZW50KGVsZW1lbnQsIGhvc3QpIHtcbiAgICAgIGlmICghdGhpcy5lbGVtZW50c1tob3N0Ll9zb3J0aW5nSWRdKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaG9zdC5fc29ydGluZ0lkXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsZW1lbnRzW2hvc3QuX3NvcnRpbmdJZF0ucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgc2hhZG93ZWQgZWxlbWVudHMgZnJvbSB0aGUgc2VxdWVuY2UgYW5kIHJlZ2lzdGVyXG4gICAgLy8gdGhlIFNoYWRvd0hvc3RzIHRoZXkgYmVsb25nIHRvIHNvIHdlIGtub3cgd2hhdCB0byBzb3J0XG4gICAgLy8gbGF0ZXIgb25cblxuICB9LCB7XG4gICAga2V5OiAnZXh0cmFjdEVsZW1lbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXh0cmFjdEVsZW1lbnRzKGVsZW1lbnRzKSB7XG4gICAgICByZXR1cm4gZWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBob3N0ID0gKDAsIF9zaGFkb3dIb3N0Mi5kZWZhdWx0KSh7IGNvbnRleHQ6IGVsZW1lbnQgfSk7XG4gICAgICAgIGlmICghaG9zdCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJIb3N0KGhvc3QpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlckVsZW1lbnQoZWxlbWVudCwgaG9zdCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIC8vIGluamVjdCBob3N0cyBpbnRvIHRoZSBzZXF1ZW5jZSwgc29ydCBldmVyeXRoaW5nLFxuICAgIC8vIGFuZCByZWNvdXJzaXZlbHkgcmVwbGFjZSBob3N0cyBieSBpdHMgZGVzY2VuZGFudHNcblxuICB9LCB7XG4gICAga2V5OiAnc29ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQoZWxlbWVudHMpIHtcbiAgICAgIHZhciBfZWxlbWVudHMgPSB0aGlzLl9pbmplY3RIb3N0cyhlbGVtZW50cyk7XG4gICAgICBfZWxlbWVudHMgPSB0aGlzLl9yZXBsYWNlSG9zdHMoX2VsZW1lbnRzKTtcbiAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgIHJldHVybiBfZWxlbWVudHM7XG4gICAgfVxuXG4gICAgLy8gbWVyZ2UgU2hhZG93SG9zdHMgaW50byB0aGUgZWxlbWVudCBsaXN0cyBvZiBvdGhlciBTaGFkb3dIb3N0c1xuICAgIC8vIG9yIHRoZSBkb2N1bWVudCwgdGhlbiBzb3J0IHRoZSBpbmRpdmlkdWFsIGxpc3RzXG5cbiAgfSwge1xuICAgIGtleTogJ19pbmplY3RIb3N0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbmplY3RIb3N0cyhlbGVtZW50cykge1xuICAgICAgT2JqZWN0LmtleXModGhpcy5ob3N0cykuZm9yRWFjaChmdW5jdGlvbiAoX3NvcnRpbmdJZCkge1xuICAgICAgICB2YXIgX2xpc3QgPSB0aGlzLmVsZW1lbnRzW19zb3J0aW5nSWRdO1xuICAgICAgICB2YXIgX2VsZW1lbnRzID0gdGhpcy5pbkhvc3RbX3NvcnRpbmdJZF07XG4gICAgICAgIHZhciBfY29udGV4dCA9IHRoaXMuaG9zdHNbX3NvcnRpbmdJZF0uc2hhZG93Um9vdDtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tfc29ydGluZ0lkXSA9IHRoaXMuX21lcmdlKF9saXN0LCBfZWxlbWVudHMsIF9jb250ZXh0KTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fbWVyZ2UoZWxlbWVudHMsIHRoaXMuaW5Eb2N1bWVudCwgdGhpcy5jb250ZXh0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfbWVyZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWVyZ2UobGlzdCwgZWxlbWVudHMsIGNvbnRleHQpIHtcbiAgICAgIHZhciBtZXJnZWQgPSAoMCwgX21lcmdlRG9tT3JkZXIyLmRlZmF1bHQpKHtcbiAgICAgICAgbGlzdDogbGlzdCxcbiAgICAgICAgZWxlbWVudHM6IGVsZW1lbnRzXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXMuc29ydEVsZW1lbnRzKG1lcmdlZCwgY29udGV4dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3JlcGxhY2VIb3N0cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXBsYWNlSG9zdHMoZWxlbWVudHMpIHtcbiAgICAgIHJldHVybiAoMCwgX21lcmdlRG9tT3JkZXIyLmRlZmF1bHQpKHtcbiAgICAgICAgbGlzdDogZWxlbWVudHMsXG4gICAgICAgIGVsZW1lbnRzOiB0aGlzLmluRG9jdW1lbnQsXG4gICAgICAgIHJlc29sdmVFbGVtZW50OiB0aGlzLl9yZXNvbHZlSG9zdEVsZW1lbnQuYmluZCh0aGlzKVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3Jlc29sdmVIb3N0RWxlbWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNvbHZlSG9zdEVsZW1lbnQoaG9zdCkge1xuICAgICAgdmFyIG1lcmdlZCA9ICgwLCBfbWVyZ2VEb21PcmRlcjIuZGVmYXVsdCkoe1xuICAgICAgICBsaXN0OiB0aGlzLmVsZW1lbnRzW2hvc3QuX3NvcnRpbmdJZF0sXG4gICAgICAgIGVsZW1lbnRzOiB0aGlzLmluSG9zdFtob3N0Ll9zb3J0aW5nSWRdLFxuICAgICAgICByZXNvbHZlRWxlbWVudDogdGhpcy5fcmVzb2x2ZUhvc3RFbGVtZW50LmJpbmQodGhpcylcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX3RhYmluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShob3N0KTtcbiAgICAgIGlmIChfdGFiaW5kZXggIT09IG51bGwgJiYgX3RhYmluZGV4ID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIFtob3N0XS5jb25jYXQobWVyZ2VkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfY2xlYW51cCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbnVwKCkge1xuICAgICAgLy8gcmVtb3ZlIHRob3NlIGlkZW50aWZlcnMgd2UgcHV0IG9uIHRoZSBTaGFkb3dIb3N0IHRvIGF2b2lkIHVzaW5nIE1hcCgpXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmhvc3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaG9zdHNba2V5XS5fc29ydGluZ0lkO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNoYWRvd3M7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFic2VxdWVuY2Uuc29ydC1zaGFkb3dlZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQudGFiSW5kZXhcbiAgLy8gZWxlbWVudHMgd2l0aCB0YWJJbmRleCBcIjBcIiAoaW5jbHVkaW5nIHRhYmJhYmxlRWxlbWVudHMgd2l0aG91dCB0YWJJbmRleCkgc2hvdWxkIGJlIG5hdmlnYXRlZCBpbiB0aGUgb3JkZXIgdGhleSBhcHBlYXIuXG4gIC8vIGVsZW1lbnRzIHdpdGggYSBwb3NpdGl2ZSB0YWJJbmRleDpcbiAgLy8gICBFbGVtZW50cyB0aGF0IGhhdmUgaWRlbnRpY2FsIHRhYkluZGV4ZXMgc2hvdWxkIGJlIG5hdmlnYXRlZCBpbiB0aGUgb3JkZXIgdGhleSBhcHBlYXIuXG4gIC8vICAgTmF2aWdhdGlvbiBwcm9jZWVkcyBmcm9tIHRoZSBsb3dlc3QgdGFiSW5kZXggdG8gdGhlIGhpZ2hlc3QgdGFiSW5kZXguXG5cbiAgLy8gTk9URTogc29ydCBpbXBsZW1lbnRhdGlvbiBtYXkgYmUgdW5zdGFibGUgYW5kIHRodXMgbWVzcyB1cCBET00gb3JkZXIsXG4gIC8vIHRoYXQncyB3aHkgd2UgYnVpbGQgYSBtYXAgdGhhdCdzIGJlaW5nIHNvcnRlZCBpbnN0ZWFkLiBJZiB3ZSB3ZXJlIGFibGUgdG8gcmVseVxuICAvLyBvbiBhIHN0YWJsZSBzb3J0aW5nIGFsZ29yaXRobSwgc29ydFRhYmluZGV4KCkgY291bGQgYmUgYXMgc2ltcGxlIGFzXG4gIC8vIGVsZW1lbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS50YWJJbmRleCAtIGIudGFiSW5kZXg7IH0pO1xuICAvLyBhdCB0aGlzIHRpbWUgQ2hyb21lIGRvZXMgbm90IHVzZSBhIHN0YWJsZSBzb3J0aW5nIGFsZ29yaXRobVxuICAvLyBzZWUgaHR0cDovL2Jsb2cucm9kbmV5cmVobS5kZS9hcmNoaXZlcy8xNC1Tb3J0aW5nLVdlcmUtRG9pbmctSXQtV3JvbmcuaHRtbCNzdGFiaWxpdHlcblxuICAvLyBOT1RFOiBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiBzZWVtZWQgbGlrZSBtb3JlIG92ZXJoZWFkIHRoYW4ganVzdCBzb3J0aW5nIHRoaXMgd2l0aCBidWNrZXRzXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cbiAgdmFyIG1hcCA9IHt9O1xuICB2YXIgaW5kZXhlcyA9IFtdO1xuICB2YXIgbm9ybWFsID0gZWxlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgLy8gaW4gVHJpZGVudCBhbmQgR2Vja28gU1ZHRWxlbWVudCBkb2VzIG5vdCBrbm93IGFib3V0IHRoZSB0YWJJbmRleCBwcm9wZXJ0eVxuICAgIHZhciB0YWJJbmRleCA9IGVsZW1lbnQudGFiSW5kZXg7XG4gICAgaWYgKHRhYkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhYkluZGV4ID0gKDAsIF90YWJpbmRleFZhbHVlMi5kZWZhdWx0KShlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBleHRyYWN0IGVsZW1lbnRzIHRoYXQgZG9uJ3QgbmVlZCBzb3J0aW5nXG4gICAgaWYgKHRhYkluZGV4IDw9IDAgfHwgdGFiSW5kZXggPT09IG51bGwgfHwgdGFiSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCFtYXBbdGFiSW5kZXhdKSB7XG4gICAgICAvLyBjcmVhdGUgc29ydGFibGUgYnVja2V0IGZvciBkb20tb3JkZXItcHJlc2VydmF0aW9uIG9mIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgdGFiSW5kZXhcbiAgICAgIG1hcFt0YWJJbmRleF0gPSBbXTtcbiAgICAgIC8vIG1haW50YWluIGEgbGlzdCBvZiB1bmlxdWUgdGFiSW5kZXhlc1xuICAgICAgaW5kZXhlcy5wdXNoKHRhYkluZGV4KTtcbiAgICB9XG5cbiAgICAvLyBzb3J0IGVsZW1lbnQgaW50byB0aGUgcHJvcGVyIGJ1Y2tldFxuICAgIG1hcFt0YWJJbmRleF0ucHVzaChlbGVtZW50KTtcbiAgICAvLyBlbGVtZW50IG1vdmVkIHRvIHNvcnRpbmcgbWFwLCBzbyBub3QgXCJub3JtYWxcIiBhbnltb3JlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcblxuICAvLyBzb3J0IHRoZSB0YWJpbmRleCBhc2NlbmRpbmcsXG4gIC8vIHRoZW4gcmVzb2x2ZSB0aGVtIHRvIHRoZWlyIGFwcHJvcHJpYXRlIGJ1Y2tldHMsXG4gIC8vIHRoZW4gZmxhdHRlbiB0aGUgYXJyYXkgb2YgYXJyYXlzIHRvIGFuIGFycmF5XG4gIHZhciBfZWxlbWVudHMgPSBpbmRleGVzLnNvcnQoKS5tYXAoZnVuY3Rpb24gKHRhYkluZGV4KSB7XG4gICAgcmV0dXJuIG1hcFt0YWJJbmRleF07XG4gIH0pLnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkge1xuICAgIHJldHVybiBjdXJyZW50LmNvbmNhdChwcmV2aW91cyk7XG4gIH0sIG5vcm1hbCk7XG5cbiAgcmV0dXJuIF9lbGVtZW50cztcbn07XG5cbnZhciBfdGFiaW5kZXhWYWx1ZSA9IHJlcXVpcmUoJy4uL3V0aWwvdGFiaW5kZXgtdmFsdWUnKTtcblxudmFyIF90YWJpbmRleFZhbHVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYmluZGV4VmFsdWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhYnNlcXVlbmNlLnNvcnQtdGFiaW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghc3VwcG9ydHMpIHtcbiAgICBzdXBwb3J0cyA9ICgwLCBfc3VwcG9ydHMzLmRlZmF1bHQpKCk7XG4gIH1cblxuICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfVxuXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9lZGl0aW5nLmh0bWwjc2VxdWVudGlhbC1mb2N1cy1uYXZpZ2F0aW9uLWFuZC10aGUtdGFiaW5kZXgtYXR0cmlidXRlXG4gIHNlbGVjdG9yID0gJydcbiAgLy8gSUUxMSBzdXBwb3J0cy5jYW4gZm9jdXMgPHRhYmxlPiBhbmQgPHRkPlxuICArIChzdXBwb3J0cy5mb2N1c1RhYmxlID8gJ3RhYmxlLCB0ZCwnIDogJycpXG4gIC8vIElFMTEgc3VwcG9ydHMuY2FuIGZvY3VzIDxmaWVsZHNldD5cbiAgKyAoc3VwcG9ydHMuZm9jdXNGaWVsZHNldCA/ICdmaWVsZHNldCwnIDogJycpXG4gIC8vIE5hbWVzcGFjZSBwcm9ibGVtcyBvZiBbeGxpbms6aHJlZl0gZXhwbGFpbmVkIGluIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMzA0Nzg4OC81MTUxMjRcbiAgLy8gc3ZnIGFbKnxocmVmXSBkb2VzIG5vdCBtYXRjaCBpbiBJRTksIGJ1dCBzaW5jZSB3ZSdyZSBmaWx0ZXJpbmdcbiAgLy8gdGhyb3VnaCBpcy9mb2N1c2FibGUgd2UgY2FuIGluY2x1ZGUgYWxsIDxhPiBmcm9tIFNWR1xuICArICdzdmcgYSwnXG4gIC8vIG1heSBiZWhhdmUgYXMgJ3N2Zywgc3ZnICosJyBpbiBjaHJvbWUgYXMgKmV2ZXJ5KiBzdmcgZWxlbWVudCB3aXRoIGEgZm9jdXMgZXZlbnQgbGlzdGVuZXIgaXMgZm9jdXNhYmxlXG4gIC8vIG5hdmlnYXRpb25hbCBlbGVtZW50c1xuICArICdhW2hyZWZdLCdcbiAgLy8gdmFsaWRpdHkgZGV0ZXJtaW5lZCBieSBpcy92YWxpZC1hcmVhLmpzXG4gICsgJ2FyZWFbaHJlZl0sJ1xuICAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL2Rpc2FibGVkLmpzXG4gICsgJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBidXR0b24sJ1xuICAvLyBicm93c2luZyBjb250ZXh0IGNvbnRhaW5lcnNcbiAgKyAnaWZyYW1lLCBvYmplY3QsIGVtYmVkLCdcbiAgLy8gaW50ZXJhY3RpdmUgY29udGVudFxuICArICdrZXlnZW4sJyArIChzdXBwb3J0cy5mb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzID8gJ2F1ZGlvLCcgOiAnYXVkaW9bY29udHJvbHNdLCcpICsgKHN1cHBvcnRzLmZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHMgPyAndmlkZW8sJyA6ICd2aWRlb1tjb250cm9sc10sJykgKyAoc3VwcG9ydHMuZm9jdXNTdW1tYXJ5ID8gJ3N1bW1hcnksJyA6ICcnKVxuICAvLyB2YWxpZGl0eSBkZXRlcm1pbmVkIGJ5IGlzL3ZhbGlkLXRhYmluZGV4LmpzXG4gICsgJ1t0YWJpbmRleF0sJ1xuICAvLyBlZGl0aW5nIGhvc3RzXG4gICsgJ1tjb250ZW50ZWRpdGFibGVdJztcblxuICAvLyB3aGVyZSBTaGFkb3dET00gaXMgc3VwcG9ydGVkLCB3ZSBhbHNvIHdhbnQgdGhlIHNoYWRvd2VkIGZvY3VzYWJsZSBlbGVtZW50cyAodmlhIFwiPj4+XCIgb3IgXCIvZGVlcC9cIilcbiAgc2VsZWN0b3IgPSAoMCwgX3NlbGVjdEluU2hhZG93czIuZGVmYXVsdCkoc2VsZWN0b3IpO1xuXG4gIHJldHVybiBzZWxlY3Rvcjtcbn07XG5cbnZhciBfc2VsZWN0SW5TaGFkb3dzID0gcmVxdWlyZSgnLi4vdXRpbC9zZWxlY3QtaW4tc2hhZG93cycpO1xuXG52YXIgX3NlbGVjdEluU2hhZG93czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZWxlY3RJblNoYWRvd3MpO1xuXG52YXIgX3N1cHBvcnRzMiA9IHJlcXVpcmUoJy4uL3N1cHBvcnRzL3N1cHBvcnRzJyk7XG5cbnZhciBfc3VwcG9ydHMzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3VwcG9ydHMyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gTk9URTogdGhpcyBzZWxlY3RvciBNVVNUICpuZXZlciogYmUgdXNlZCBkaXJlY3RseSxcbi8vIGFsd2F5cyBnbyB0aHJvdWdoIHF1ZXJ5L2ZvY3VzYWJsZSBvciBpcy9mb2N1c2FibGUuanNcbi8vIHRoZXJlIGFyZSB0b28gbWFueSBlZGdlIGNhc2VzIHRoYXQgdGhleSBjb3VsZCBiZSBjb3ZlcmVkIGluXG4vLyBhIHNpbXBsZSBDU1Mgc2VsZWN0b3LigKZcblxudmFyIHN1cHBvcnRzID0gdm9pZCAwO1xuXG52YXIgc2VsZWN0b3IgPSB2b2lkIDA7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXNhYmxlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29tYmluYXRvciA9IHZvaWQgMDtcblxuICAvLyBzZWUgaHR0cHM6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1zY29waW5nLTEvI2RlZXAtY29tYmluYXRvclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTE3NTcyXG4gIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDYwNTFcbiAgdHJ5IHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sID4+PiA6Zmlyc3QtY2hpbGQnKTtcbiAgICBjb21iaW5hdG9yID0gJz4+Pic7XG4gIH0gY2F0Y2ggKG5vQXJyb3dBcnJvd0Fycm93KSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIG9sZCBzeW50YXggc3VwcG9ydGVkIGF0IGxlYXN0IHVwIHRvIENocm9tZSA0MVxuICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NjA1MVxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaHRtbCAvZGVlcC8gOmZpcnN0LWNoaWxkJyk7XG4gICAgICBjb21iaW5hdG9yID0gJy9kZWVwLyc7XG4gICAgfSBjYXRjaCAobm9EZWVwKSB7XG4gICAgICBjb21iaW5hdG9yID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbWJpbmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzcy1zaGFkb3ctcGllcmNpbmctZGVlcC1jb21iaW5hdG9yLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHRlc3RzKSB7XG4gIHZhciBkYXRhID0gYmVmb3JlKCk7XG5cbiAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgT2JqZWN0LmtleXModGVzdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmVzdWx0c1trZXldID0gdGVzdChkYXRhLCB0ZXN0c1trZXldKTtcbiAgfSk7XG5cbiAgYWZ0ZXIoZGF0YSk7XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcblxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGJlZm9yZSgpIHtcbiAgdmFyIGRhdGEgPSB7XG4gICAgLy8gcmVtZW1iZXIgd2hhdCBoYWQgZm9jdXMgdG8gcmVzdG9yZSBhZnRlciB0ZXN0XG4gICAgYWN0aXZlRWxlbWVudDogZG9jdW1lbnQuYWN0aXZlRWxlbWVudCxcbiAgICAvLyByZW1lbWJlciBzY3JvbGwgcG9zaXRpb25zIHRvIHJlc3RvcmUgYWZ0ZXIgdGVzdFxuICAgIHdpbmRvd1Njcm9sbFRvcDogd2luZG93LnNjcm9sbFRvcCxcbiAgICB3aW5kb3dTY3JvbGxMZWZ0OiB3aW5kb3cuc2Nyb2xsTGVmdCxcbiAgICBib2R5U2Nyb2xsVG9wOiBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICBib2R5U2Nyb2xsTGVmdDogZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0XG4gIH07XG5cbiAgLy8gd3JhcCB0ZXN0cyBpbiBhbiBlbGVtZW50IGhpZGRlbiBmcm9tIHNjcmVlbiByZWFkZXJzIHRvIHByZXZlbnQgdGhlbVxuICAvLyBmcm9tIGFubm91bmNpbmcgZm9jdXMsIHdoaWNoIGNhbiBiZSBxdWl0ZSBpcnJpdGF0aW5nIHRvIHRoZSB1c2VyXG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAncG9zaXRpb246YWJzb2x1dGU7IHBvc2l0aW9uOmZpeGVkOyB0b3A6MDsgbGVmdDotMnB4OyB3aWR0aDoxcHg7IGhlaWdodDoxcHg7IG92ZXJmbG93OmhpZGRlbjsnKTtcbiAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ29mZicpO1xuICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWJ1c3knLCAndHJ1ZScpO1xuICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblxuICB2YXIgX3dpbmRvdyA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuICB2YXIgX2RvY3VtZW50ID0gX3dpbmRvdy5kb2N1bWVudDtcblxuICBfZG9jdW1lbnQub3BlbigpO1xuICBfZG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHdyYXBwZXIgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIF9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuXG4gIGRhdGEuaWZyYW1lID0gaWZyYW1lO1xuICBkYXRhLndyYXBwZXIgPSB3cmFwcGVyO1xuICBkYXRhLndpbmRvdyA9IF93aW5kb3c7XG4gIGRhdGEuZG9jdW1lbnQgPSBfZG9jdW1lbnQ7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8vIG9wdGlvbnMuZWxlbWVudDpcbi8vICB7c3RyaW5nfSBlbGVtZW50IG5hbWVcbi8vICB7ZnVuY3Rpb259IGNhbGxiYWNrKHdyYXBwZXIsIGRvY3VtZW50KSB0byBnZW5lcmF0ZSBhbiBlbGVtZW50XG4vLyBvcHRpb25zLm11dGF0ZTogKG9wdGlvbmFsKVxuLy8gIHtmdW5jdGlvbn0gY2FsbGJhY2soZWxlbWVudCwgd3JhcHBlciwgZG9jdW1lbnQpIHRvIG1hbmlwdWxhdGUgZWxlbWVudCBwcmlvciB0byBmb2N1cy10ZXN0LlxuLy8gICAgICAgICAgICAgQ2FuIHJldHVybiBET01FbGVtZW50IHRvIGRlZmluZSBmb2N1cyB0YXJnZXQgKGRlZmF1bHQ6IGVsZW1lbnQpXG4vLyBvcHRpb25zLnZhbGlkYXRlOiAob3B0aW9uYWwpXG4vLyAge2Z1bmN0aW9ufSBjYWxsYmFjayhlbGVtZW50LCBmb2N1c1RhcmdldCwgZG9jdW1lbnQpIHRvIG1hbmlwdWxhdGUgdGVzdC1yZXN1bHRcbmZ1bmN0aW9uIHRlc3QoZGF0YSwgb3B0aW9ucykge1xuICAvLyBtYWtlIHN1cmUgd2Ugb3BlcmF0ZSBvbiBhIGNsZWFuIHNsYXRlXG4gIGRhdGEud3JhcHBlci5pbm5lckhUTUwgPSAnJztcbiAgLy8gY3JlYXRlIGR1bW15IGVsZW1lbnQgdG8gdGVzdCBmb2N1c2FiaWxpdHkgb2ZcbiAgdmFyIGVsZW1lbnQgPSB0eXBlb2Ygb3B0aW9ucy5lbGVtZW50ID09PSAnc3RyaW5nJyA/IGRhdGEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChvcHRpb25zLmVsZW1lbnQpIDogb3B0aW9ucy5lbGVtZW50KGRhdGEud3JhcHBlciwgZGF0YS5kb2N1bWVudCk7XG4gIC8vIGFsbG93IGNhbGxiYWNrIHRvIGZ1cnRoZXIgc3BlY2lmeSBkdW1teSBlbGVtZW50XG4gIC8vIGFuZCBvcHRpb25hbGx5IGRlZmluZSBlbGVtZW50IHRvIGZvY3VzXG4gIHZhciBmb2N1cyA9IG9wdGlvbnMubXV0YXRlICYmIG9wdGlvbnMubXV0YXRlKGVsZW1lbnQsIGRhdGEud3JhcHBlciwgZGF0YS5kb2N1bWVudCk7XG4gIGlmICghZm9jdXMgJiYgZm9jdXMgIT09IGZhbHNlKSB7XG4gICAgZm9jdXMgPSBlbGVtZW50O1xuICB9XG4gIC8vIGVsZW1lbnQgbmVlZHMgdG8gYmUgcGFydCBvZiB0aGUgRE9NIHRvIGJlIGZvY3VzYWJsZVxuICAhZWxlbWVudC5wYXJlbnROb2RlICYmIGRhdGEud3JhcHBlci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgLy8gdGVzdCBpZiB0aGUgZWxlbWVudCB3aXRoIGludmFsaWQgdGFiaW5kZXggY2FuIGJlIGZvY3VzZWRcbiAgZm9jdXMgJiYgZm9jdXMuZm9jdXMgJiYgZm9jdXMuZm9jdXMoKTtcbiAgLy8gdmFsaWRhdGUgdGVzdCdzIHJlc3VsdFxuICByZXR1cm4gb3B0aW9ucy52YWxpZGF0ZSA/IG9wdGlvbnMudmFsaWRhdGUoZWxlbWVudCwgZm9jdXMsIGRhdGEuZG9jdW1lbnQpIDogZGF0YS5kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1cztcbn1cblxuZnVuY3Rpb24gYWZ0ZXIoZGF0YSkge1xuICAvLyByZXN0b3JlIGZvY3VzIHRvIHdoYXQgaXQgd2FzIGJlZm9yZSB0ZXN0IGFuZCBjbGVhbnVwXG4gIGlmIChkYXRhLmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1ciAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLklFMTApIHtcbiAgICAgIC8vIElFMTAgZG9lcyBub3QgcmVkaXJlY3QgZm9jdXMgdG8gPGJvZHk+IHdoZW4gdGhlIGFjdGl2ZUVsZW1lbnQgaXMgcmVtb3ZlZFxuICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkYXRhLmFjdGl2ZUVsZW1lbnQgJiYgZGF0YS5hY3RpdmVFbGVtZW50LmZvY3VzICYmIGRhdGEuYWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkYXRhLmlmcmFtZSk7XG5cbiAgLy8gcmVzdG9yZSBzY3JvbGwgcG9zaXRpb25cbiAgd2luZG93LnNjcm9sbFRvcCA9IGRhdGEud2luZG93U2Nyb2xsVG9wO1xuICB3aW5kb3cuc2Nyb2xsTGVmdCA9IGRhdGEud2luZG93U2Nyb2xsTGVmdDtcbiAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPSBkYXRhLmJvZHlTY3JvbGxUb3A7XG4gIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCA9IGRhdGEuYm9keVNjcm9sbExlZnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZWN0LWZvY3VzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9naWYgPSByZXF1aXJlKCcuL21lZGlhL2dpZicpO1xuXG52YXIgX2dpZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9naWYpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPG1hcCBuYW1lPVwiaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIj4nICsgJzxhcmVhIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIiB0YWJpbmRleD1cIi0xXCIgYWx0PVwiXCIgc3JjPVwiJyArIF9naWYyLmRlZmF1bHQgKyAnXCI+JztcblxuICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2FyZWEnKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtYXJlYS1pbWctdGFiaW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dpZiA9IHJlcXVpcmUoJy4vbWVkaWEvZ2lmJyk7XG5cbnZhciBfZ2lmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dpZik7XG5cbnZhciBfcGxhdGZvcm0gPSByZXF1aXJlKCcuLi91dGlsL3BsYXRmb3JtJyk7XG5cbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW1nI2F0dHItdXNlbWFwXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPG1hcCBuYW1lPVwiaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIj4nICsgJzxhcmVhIGhyZWY9XCIjdm9pZFwiIHRhYmluZGV4PVwiLTFcIiBzaGFwZT1cInJlY3RcIiBjb29yZHM9XCI2MywxOSwxNDQsNDVcIj48L21hcD4nICsgJzxpbWcgdXNlbWFwPVwiI2ltYWdlLW1hcC10YWJpbmRleC10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJyArIF9naWYyLmRlZmF1bHQgKyAnXCI+JztcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBfZG9jdW1lbnQpIHtcbiAgICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPKSB7XG4gICAgICAvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XG4gICAgICAvLyBGaXJlZm94IGxvYWRzIHRoZSBEYXRhVVJJIGFzeW5jaHJvbm91c2x5LCBjYXVzaW5nIGEgZmFsc2UtbmVnYXRpdmVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBmb2N1cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcignYXJlYScpO1xuICAgIGZvY3VzLmZvY3VzKCk7XG4gICAgcmV0dXJuIF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmb2N1cztcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtYXJlYS10YWJpbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9tZWRpYS9naWYnKTtcblxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcblxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcblxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtYXJlYS1ocmVmLXRlc3RcIj4nICsgJzxhcmVhIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLWFyZWEtaHJlZi10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJyArIF9naWYyLmRlZmF1bHQgKyAnXCI+JztcblxuICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2FyZWEnKTtcbiAgfSxcbiAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBfZG9jdW1lbnQpIHtcbiAgICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPKSB7XG4gICAgICAvLyBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzM1XG4gICAgICAvLyBGaXJlZm94IGxvYWRzIHRoZSBEYXRhVVJJIGFzeW5jaHJvbm91c2x5LCBjYXVzaW5nIGEgZmFsc2UtbmVnYXRpdmVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZm9jdXNUYXJnZXQ7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWFyZWEtd2l0aG91dC1ocmVmLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9tcCA9IHJlcXVpcmUoJy4vbWVkaWEvbXAzJyk7XG5cbnZhciBfbXAyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbXApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdjYW4tZm9jdXMtYXVkaW8td2l0aG91dC1jb250cm9scycsXG4gIGVsZW1lbnQ6ICdhdWRpbycsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgLy8gaW52YWxpZCBtZWRpYSBmaWxlIGNhbiB0cmlnZ2VyIHdhcm5pbmcgaW4gY29uc29sZSwgZGF0YS11cmkgdG8gcHJldmVudCBIVFRQIHJlcXVlc3RcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcmMnLCBfbXAyLmRlZmF1bHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElFOSBtYXkgdGhyb3cgXCJFcnJvcjogTm90IGltcGxlbWVudGVkXCJcbiAgICB9XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWF1ZGlvLXdpdGhvdXQtY29udHJvbHMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dpZiA9IHJlcXVpcmUoJy4vbWVkaWEvZ2lmLmludmFsaWQnKTtcblxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gTk9URTogaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8zNVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLXVzZW1hcFxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAnZGl2JyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxtYXAgbmFtZT1cImJyb2tlbi1pbWFnZS1tYXAtdGVzdFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjYnJva2VuLWltYWdlLW1hcC10ZXN0XCIgYWx0PVwiXCIgc3JjPVwiJyArIF9naWYyLmRlZmF1bHQgKyAnXCI+JztcblxuICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2FyZWEnKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtYnJva2VuLWltYWdlLW1hcC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8vIENoaWxkcmVuIG9mIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoIGRpc3BsYXk6ZmxleCBhcmUgZm9jdXNhYmxlIGluIElFMTAtMTFcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogLXdlYmtpdC1mbGV4OyBkaXNwbGF5OiAtbXMtZmxleGJveDsgZGlzcGxheTogZmxleDsnKTtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8c3BhbiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrO1wiPmhlbGxvPC9zcGFuPic7XG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1jaGlsZHJlbi1vZi1mb2N1c2FibGUtZmxleGJveC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8vIGZpZWxkc2V0W3RhYmluZGV4PTBdW2Rpc2FibGVkXSBzaG91bGQgbm90IGJlIGZvY3VzYWJsZSwgYnV0IEJsaW5rIGFuZCBXZWJLaXQgZGlzYWdyZWVcbi8vIEBzcGVjaWZpY2F0aW9uIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9kaXNhYmxlZC1lbGVtZW50cy5odG1sI2NvbmNlcHQtZWxlbWVudC1kaXNhYmxlZFxuLy8gQGJyb3dzZXItaXNzdWUgQ2hyb21pdW0gaHR0cHM6Ly9jcmJ1Zy5jb20vNDUzODQ3XG4vLyBAYnJvd3Nlci1pc3N1ZSBXZWJLaXQgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0MTA4NlxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAnZmllbGRzZXQnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ2Rpc2FibGVkJyk7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWZpZWxkc2V0LWRpc2FibGVkLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2ZpZWxkc2V0JyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxsZWdlbmQ+bGVnZW5kPC9sZWdlbmQ+PHA+Y29udGVudDwvcD4nO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1maWVsZHNldC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8vIGVsZW1lbnRzIHdpdGggZGlzcGxheTpmbGV4IGFyZSBmb2N1c2FibGUgaW4gSUUxMC0xMVxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAnc3BhbicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogLXdlYmtpdC1mbGV4OyBkaXNwbGF5OiAtbXMtZmxleGJveDsgZGlzcGxheTogZmxleDsnKTtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8c3BhbiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrO1wiPmhlbGxvPC9zcGFuPic7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWZsZXhib3gtY29udGFpbmVyLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLy8gZm9ybVt0YWJpbmRleD0wXVtkaXNhYmxlZF0gc2hvdWxkIGJlIGZvY3VzYWJsZSBhcyB0aGVcbi8vIHNwZWNpZmljYXRpb24gZG9lc24ndCBrbm93IHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgb24gdGhlIGZvcm0gZWxlbWVudFxuLy8gQHNwZWNpZmljYXRpb24gaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjdGhlLWZvcm0tZWxlbWVudFxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAnZm9ybScsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAnZGlzYWJsZWQnKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtZm9ybS1kaXNhYmxlZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2lmID0gcmVxdWlyZSgnLi9tZWRpYS9naWYnKTtcblxudmFyIF9naWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2lmKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gTk9URTogaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8zNVxuLy8gZml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL21lZGlhbGl6ZS9hbGx5LmpzL2lzc3Vlcy8yMFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2ltZyNhdHRyLWlzbWFwXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdhJyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuaHJlZiA9ICcjdm9pZCc7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPGltZyBpc21hcCBzcmM9XCInICsgX2dpZjIuZGVmYXVsdCArICdcIiBhbHQ9XCJcIj4nO1xuICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1pbWctaXNtYXAuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dpZiA9IHJlcXVpcmUoJy4vbWVkaWEvZ2lmJyk7XG5cbnZhciBfZ2lmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dpZik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIE5PVEU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRpYWxpemUvYWxseS5qcy9pc3N1ZXMvMzVcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbWcjYXR0ci11c2VtYXBcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bWFwIG5hbWU9XCJpbWFnZS1tYXAtdGFiaW5kZXgtdGVzdFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjaW1hZ2UtbWFwLXRhYmluZGV4LXRlc3RcIiB0YWJpbmRleD1cIi0xXCIgYWx0PVwiXCIgJyArICdzcmM9XCInICsgX2dpZjIuZGVmYXVsdCArICdcIj4nO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignaW1nJyk7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWltZy11c2VtYXAtdGFiaW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiBmdW5jdGlvbiBlbGVtZW50KHdyYXBwZXIsIF9kb2N1bWVudCkge1xuICAgIHZhciBpZnJhbWUgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cbiAgICAvLyBpZnJhbWUgbXVzdCBiZSBwYXJ0IG9mIHRoZSBET00gYmVmb3JlIGFjY2Vzc2luZyB0aGUgY29udGVudFdpbmRvdyBpcyBwb3NzaWJsZVxuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgaWZyYW1lJ3MgZGVmYXVsdCBkb2N1bWVudCAoPGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5PjwvYm9keT48L2h0bWw+KVxuICAgIHZhciBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICAgIHJldHVybiBpZnJhbWU7XG4gIH0sXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGlmcmFtZSkge1xuICAgIGlmcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cbiAgICB2YXIgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICB2YXIgaW5wdXQgPSBpZnJhbWVEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGlmcmFtZURvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfSxcbiAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGlmcmFtZSkge1xuICAgIHZhciBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgIHZhciBmb2N1cyA9IGlmcmFtZURvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0Jyk7XG4gICAgcmV0dXJuIGlmcmFtZURvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1pbi1oaWRkZW4taWZyYW1lLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIF9wbGF0Zm9ybSA9IHJlcXVpcmUoJy4uL3V0aWwvcGxhdGZvcm0nKTtcblxudmFyIF9wbGF0Zm9ybTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wbGF0Zm9ybSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciByZXN1bHQgPSAhX3BsYXRmb3JtMi5kZWZhdWx0LmlzLldFQktJVDtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1pbi16ZXJvLWRpbWVuc2lvbi1vYmplY3QuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG4vLyBGaXJlZm94IGFsbG93cyAqYW55KiB2YWx1ZSBhbmQgdHJlYXRzIGludmFsaWQgdmFsdWVzIGxpa2UgdGFiaW5kZXg9XCItMVwiXG4vLyBAYnJvd3Nlci1pc3N1ZSBHZWNrbyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTI4MDU0XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJ2ludmFsaWQtdmFsdWUnKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtaW52YWxpZC10YWJpbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdsYWJlbCcsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgfSxcbiAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBfZG9jdW1lbnQpIHtcbiAgICAvLyBmb3JjZSBsYXlvdXQgaW4gQ2hyb21lIDQ5LCBvdGhlcndpc2UgdGhlIGVsZW1lbnQgd29uJ3QgYmUgZm9jdXNhYmxlXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICB2YXIgdmFyaWFibGVUb1ByZXZlbnREZWFkQ29kZUVsaW1pbmF0aW9uID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQ7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLWxhYmVsLXRhYmluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zdmcgPSByZXF1aXJlKCcuL21lZGlhL3N2ZycpO1xuXG52YXIgX3N2ZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBOb3RlOiBJRTEwIG9uIEJyb3dzZXJTdGFjayBkb2VzIG5vdCBsaWtlIHRoaXMgdGVzdFxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdvYmplY3QnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnaW1hZ2Uvc3ZnK3htbCcpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhJywgX3N2ZzIuZGVmYXVsdCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzIwMCcpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnNTAnKTtcbiAgICBlbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtb2JqZWN0LXN2Zy1oaWRkZW4uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3N2ZyA9IHJlcXVpcmUoJy4vbWVkaWEvc3ZnJyk7XG5cbnZhciBfc3ZnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N2Zyk7XG5cbnZhciBfcGxhdGZvcm0gPSByZXF1aXJlKCcuLi91dGlsL3BsYXRmb3JtJyk7XG5cbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBOb3RlOiBJRTEwIG9uIEJyb3dzZXJTdGFjayBkb2VzIG5vdCBsaWtlIHRoaXMgdGVzdFxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIG5hbWU6ICdjYW4tZm9jdXMtb2JqZWN0LXN2ZycsXG4gIGVsZW1lbnQ6ICdvYmplY3QnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnaW1hZ2Uvc3ZnK3htbCcpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhJywgX3N2ZzIuZGVmYXVsdCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzIwMCcpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnNTAnKTtcbiAgfSxcbiAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBfZG9jdW1lbnQpIHtcbiAgICBpZiAoX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkdFQ0tPKSB7XG4gICAgICAvLyBGaXJlZm94IHNlZW1zIHRvIGJlIGhhbmRsaW5nIHRoZSBvYmplY3QgY3JlYXRpb24gYXN5bmNocm9ub3VzbHkgYW5kIHRoZXJlYnkgcHJvZHVjZXMgYSBmYWxzZSBuZWdhdGl2ZSB0ZXN0IHJlc3VsdC5cbiAgICAgIC8vIEJlY2F1c2Ugd2Uga25vdyBGaXJlZm94IGlzIGFibGUgdG8gZm9jdXMgb2JqZWN0IGVsZW1lbnRzIHJlZmVyZW5jaW5nIFNWR3MsIHdlIHNpbXBseSBjaGVhdCBieSBzbmlmZmluZyB0aGUgdXNlciBhZ2VudCBzdHJpbmdcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWxlbWVudDtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtb2JqZWN0LXN2Zy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBfcGxhdGZvcm0gPSByZXF1aXJlKCcuLi91dGlsL3BsYXRmb3JtJyk7XG5cbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBFdmVyeSBFbnZpcm9ubWVudCBleGNlcHQgSUU5IGNvbnNpZGVycyBTV0Ygb2JqZWN0cyBmb2N1c2FibGVcbnZhciByZXN1bHQgPSAhX3BsYXRmb3JtMi5kZWZhdWx0LmlzLklFOTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1vYmplY3Qtc3dmLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9naWYgPSByZXF1aXJlKCcuL21lZGlhL2dpZicpO1xuXG52YXIgX2dpZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9naWYpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAnPG1hcCBuYW1lPVwiZm9jdXMtcmVkaXJlY3QtaW1nLXVzZW1hcFwiPjxhcmVhIGhyZWY9XCIjdm9pZFwiIHNoYXBlPVwicmVjdFwiIGNvb3Jkcz1cIjYzLDE5LDE0NCw0NVwiPjwvbWFwPicgKyAnPGltZyB1c2VtYXA9XCIjZm9jdXMtcmVkaXJlY3QtaW1nLXVzZW1hcFwiIGFsdD1cIlwiICcgKyAnc3JjPVwiJyArIF9naWYyLmRlZmF1bHQgKyAnXCI+JztcblxuICAgIC8vIGZvY3VzIHRoZSA8aW1nPiwgbm90IHRoZSA8ZGl2PlxuICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICB9LFxuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgIHZhciB0YXJnZXQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2FyZWEnKTtcbiAgICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRhcmdldDtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtcmVkaXJlY3QtaW1nLXVzZW1hcC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbi8vIHNlZSBodHRwczovL2pzYmluLmNvbS9uZW5pcmlzYWdlL2VkaXQ/aHRtbCxqcyxjb25zb2xlLG91dHB1dFxuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdmaWVsZHNldCcsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8bGVnZW5kPmxlZ2VuZDwvbGVnZW5kPjxpbnB1dCB0YWJpbmRleD1cIi0xXCI+PGlucHV0IHRhYmluZGV4PVwiMFwiPic7XG4gICAgLy8gdGFrZSBjYXJlIG9mIGZvY3VzIGluIHZhbGlkYXRlKCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZWxlbWVudCwgZm9jdXNUYXJnZXQsIF9kb2N1bWVudCkge1xuICAgIHZhciBmb2N1c2FibGUgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3RhYmluZGV4PVwiLTFcIl0nKTtcbiAgICB2YXIgdGFiYmFibGUgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3RhYmluZGV4PVwiMFwiXScpO1xuXG4gICAgLy8gRmlyZWZveCByZXF1aXJlcyB0aGlzIHRlc3QgdG8gZm9jdXMgdGhlIDxmaWVsZHNldD4gZmlyc3QsIHdoaWxlIHRoaXMgaXMgbm90IG5lY2Vzc2FyeSBpblxuICAgIC8vIGh0dHBzOi8vanNiaW4uY29tL25lbmlyaXNhZ2UvZWRpdD9odG1sLGpzLGNvbnNvbGUsb3V0cHV0XG4gICAgZWxlbWVudC5mb2N1cygpO1xuXG4gICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdsZWdlbmQnKS5mb2N1cygpO1xuICAgIHJldHVybiBfZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZm9jdXNhYmxlICYmICdmb2N1c2FibGUnIHx8IF9kb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0YWJiYWJsZSAmJiAndGFiYmFibGUnIHx8ICcnO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1yZWRpcmVjdC1sZWdlbmQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOiAxMDBweDsgaGVpZ2h0OiA1MHB4OyBvdmVyZmxvdzogYXV0bzsnKTtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDUwMHB4OyBoZWlnaHQ6IDQwcHg7XCI+c2Nyb2xsYWJsZSBjb250ZW50PC9kaXY+JztcbiAgICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc2Nyb2xsLWJvZHkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOiAxMDBweDsgaGVpZ2h0OiA1MHB4OycpO1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxkaXYgc3R5bGU9XCJ3aWR0aDogNTAwcHg7IGhlaWdodDogNDBweDtcIj5zY3JvbGxhYmxlIGNvbnRlbnQ8L2Rpdj4nO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1zY3JvbGwtY29udGFpbmVyLXdpdGhvdXQtb3ZlcmZsb3cuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL2FsbHkuanMvaXNzdWVzLzIxXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ3dpZHRoOiAxMDBweDsgaGVpZ2h0OiA1MHB4OyBvdmVyZmxvdzogYXV0bzsnKTtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICc8ZGl2IHN0eWxlPVwid2lkdGg6IDUwMHB4OyBoZWlnaHQ6IDQwcHg7XCI+c2Nyb2xsYWJsZSBjb250ZW50PC9kaXY+JztcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc2Nyb2xsLWNvbnRhaW5lci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkZXRhaWxzJyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gJzxzdW1tYXJ5PmZvbzwvc3VtbWFyeT48cD5jb250ZW50PC9wPic7XG4gICAgcmV0dXJuIGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXN1bW1hcnkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3N2ZyA9IHJlcXVpcmUoJy4vaGVscGVyL3N2ZycpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAoMCwgX3N2Zy5nZW5lcmF0ZSkoJzx0ZXh0IGZvY3VzYWJsZT1cInRydWVcIj5hPC90ZXh0PicpO1xuICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RleHQnKTtcbiAgfSxcbiAgdmFsaWRhdGU6IF9zdmcudmFsaWRhdGVcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXN2Zy1mb2N1c2FibGUtYXR0cmlidXRlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zdmcgPSByZXF1aXJlKCcuL2hlbHBlci9zdmcnKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAnZGl2JyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gKDAsIF9zdmcuZ2VuZXJhdGUpKCc8Zm9yZWlnbk9iamVjdCB0YWJpbmRleD1cIi0xXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgLz48L2ZvcmVpZ25PYmplY3Q+Jyk7XG4gICAgLy8gU2FmYXJpIDgncyBxdWVyc1NlbGVjdG9yKCkgY2FuJ3QgaWRlbnRpZnkgZm9yZWlnbk9iamVjdCwgYnV0IGdldEVsZW1lbnR5QnlUYWdOYW1lKCkgY2FuXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcignZm9yZWlnbk9iamVjdCcpIHx8IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ZvcmVpZ25PYmplY3QnKVswXTtcbiAgfSxcbiAgdmFsaWRhdGU6IF9zdmcudmFsaWRhdGVcblxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc3ZnLWZvcmVpZ25vYmplY3QtdGFiaW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgX3BsYXRmb3JtID0gcmVxdWlyZSgnLi4vdXRpbC9wbGF0Zm9ybScpO1xuXG52YXIgX3BsYXRmb3JtMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BsYXRmb3JtKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gRmlyZWZveCBzZWVtcyB0byBiZSBoYW5kbGluZyB0aGUgU1ZHLWRvY3VtZW50LWluLWlmcmFtZSBjcmVhdGlvbiBhc3luY2hyb25vdXNseVxuLy8gYW5kIHRoZXJlYnkgcHJvZHVjZXMgYSBmYWxzZSBuZWdhdGl2ZSB0ZXN0IHJlc3VsdC4gVGh1cyB0aGUgdGVzdCBpcyBwb2ludGxlc3Ncbi8vIGFuZCB3ZSByZXNvcnQgdG8gVUEgc25pZmZpbmcgb25jZSBhZ2Fpbi5cbi8vIHNlZSBodHRwOi8vanNiaW4uY29tL3Z1bmFkb2hva28vMS9lZGl0P2pzLGNvbnNvbGUsb3V0cHV0XG5cbnZhciByZXN1bHQgPSBCb29sZWFuKF9wbGF0Zm9ybTIuZGVmYXVsdC5pcy5HRUNLTyAmJiB0eXBlb2YgU1ZHRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgU1ZHRWxlbWVudC5wcm90b3R5cGUuZm9jdXMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXN2Zy1pbi1pZnJhbWUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3N2ZyA9IHJlcXVpcmUoJy4vaGVscGVyL3N2ZycpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAoMCwgX3N2Zy5nZW5lcmF0ZSkoJzx0ZXh0IHRhYmluZGV4PVwiLTFcIj5hPC90ZXh0PicpO1xuICAgIHJldHVybiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RleHQnKTtcbiAgfSxcbiAgdmFsaWRhdGU6IF9zdmcudmFsaWRhdGVcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXN2Zy1uZWdhdGl2ZS10YWJpbmRleC1hdHRyaWJ1dGUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3N2ZyA9IHJlcXVpcmUoJy4vaGVscGVyL3N2ZycpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gIGVsZW1lbnQ6ICdkaXYnLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSAoMCwgX3N2Zy5nZW5lcmF0ZSkoJzx0ZXh0IHRhYmluZGV4PVwiMFwiPmE8L3RleHQ+Jyk7XG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGV4dCcpO1xuICB9LFxuICB2YWxpZGF0ZTogX3N2Zy52YWxpZGF0ZVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc3ZnLXRhYmluZGV4LWF0dHJpYnV0ZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfc3ZnID0gcmVxdWlyZSgnLi9oZWxwZXIvc3ZnJyk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ2RpdicsXG4gIG11dGF0ZTogZnVuY3Rpb24gbXV0YXRlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9ICgwLCBfc3ZnLmdlbmVyYXRlKShbJzxnIGlkPVwiYWxseS10ZXN0LXRhcmdldFwiPjxhIHhsaW5rOmhyZWY9XCIjdm9pZFwiPjx0ZXh0Pmxpbms8L3RleHQ+PC9hPjwvZz4nLCAnPHVzZSB4bGluazpocmVmPVwiI2FsbHktdGVzdC10YXJnZXRcIiB4PVwiMFwiIHk9XCIwXCIgdGFiaW5kZXg9XCItMVwiIC8+J10uam9pbignJykpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQucXVlcnlTZWxlY3RvcigndXNlJyk7XG4gIH0sXG4gIHZhbGlkYXRlOiBfc3ZnLnZhbGlkYXRlXG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy1zdmctdXNlLXRhYmluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zdmcgPSByZXF1aXJlKCcuL2hlbHBlci9zdmcnKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAnZGl2JyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gKDAsIF9zdmcuZ2VuZXJhdGUpKCcnKTtcbiAgICByZXR1cm4gZWxlbWVudC5maXJzdENoaWxkO1xuICB9LFxuICB2YWxpZGF0ZTogX3N2Zy52YWxpZGF0ZVxufTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9jdXMtc3ZnLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLy8gRmlyZWZveCBhbGxvd3MgKmFueSogdmFsdWUgYW5kIHRyZWF0cyBpbnZhbGlkIHZhbHVlcyBsaWtlIHRhYmluZGV4PVwiLTFcIlxuLy8gQGJyb3dzZXItaXNzdWUgR2Vja28gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyODA1NFxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAnZGl2JyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICczeCcpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy10YWJpbmRleC10cmFpbGluZy1jaGFyYWN0ZXJzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgZWxlbWVudDogJ3RhYmxlJyxcbiAgbXV0YXRlOiBmdW5jdGlvbiBtdXRhdGUoZWxlbWVudCwgd3JhcHBlciwgX2RvY3VtZW50KSB7XG4gICAgLy8gSUU5IGhhcyBhIHByb2JsZW0gcmVwbGFjaW5nIFRCT0RZIGNvbnRlbnRzIHdpdGggaW5uZXJIVE1MLlxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84MDk3MDU1LzUxNTEyNFxuICAgIC8vIGVsZW1lbnQuaW5uZXJIVE1MID0gJzx0cj48dGQ+Y2VsbDwvdGQ+PC90cj4nO1xuICAgIHZhciBmcmFnbWVudCA9IF9kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgZnJhZ21lbnQuaW5uZXJIVE1MID0gJzx0cj48dGQ+Y2VsbDwvdGQ+PC90cj4nO1xuICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy10YWJsZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbXAgPSByZXF1aXJlKCcuL21lZGlhL21wNCcpO1xuXG52YXIgX21wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21wKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBlbGVtZW50OiAndmlkZW8nLFxuICBtdXRhdGU6IGZ1bmN0aW9uIG11dGF0ZShlbGVtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGludmFsaWQgbWVkaWEgZmlsZSBjYW4gdHJpZ2dlciB3YXJuaW5nIGluIGNvbnNvbGUsIGRhdGEtdXJpIHRvIHByZXZlbnQgSFRUUCByZXF1ZXN0XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnc3JjJywgX21wMi5kZWZhdWx0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBJRTkgbWF5IHRocm93IFwiRXJyb3I6IE5vdCBpbXBsZW1lbnRlZFwiXG4gICAgfVxuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2N1cy12aWRlby13aXRob3V0LWNvbnRyb2xzLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2VuZXJhdGUgPSBnZW5lcmF0ZTtcbmV4cG9ydHMuZm9jdXMgPSBmb2N1cztcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcblxudmFyIF9mb2N1cyA9IHJlcXVpcmUoJy4uLy4uL2VsZW1lbnQvZm9jdXMuc3ZnLWZvcmVpZ24tb2JqZWN0LWhhY2snKTtcblxudmFyIF9mb2N1czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1cyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdlbmVyYXRlKGVsZW1lbnQpIHtcbiAgcmV0dXJuICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIj4nICsgZWxlbWVudCArICc8L3N2Zz4nO1xufVxuXG5mdW5jdGlvbiBmb2N1cyhlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LmZvY3VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuZm9jdXMuY2FsbChlbGVtZW50KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgICgwLCBfZm9jdXMyLmRlZmF1bHQpKGVsZW1lbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKGVsZW1lbnQsIGZvY3VzVGFyZ2V0LCBfZG9jdW1lbnQpIHtcbiAgZm9jdXMoZm9jdXNUYXJnZXQpO1xuICByZXR1cm4gX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZvY3VzVGFyZ2V0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ZnLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL1paWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlonO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1naWYuaW52YWxpZC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3Jztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2lmLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9naWYgPSByZXF1aXJlKCcuL2dpZicpO1xuXG52YXIgX2dpZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9naWYpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfZ2lmMi5kZWZhdWx0O1xuLy8gZXhwb3J0IGRlZmF1bHQgJ2RhdGE6YXVkaW8vbXAzO2Jhc2U2NCxhdWRpby1mb2N1cy10ZXN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tcDMuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dpZiA9IHJlcXVpcmUoJy4vZ2lmJyk7XG5cbnZhciBfZ2lmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dpZik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9naWYyLmRlZmF1bHQ7XG4vLyBleHBvcnQgZGVmYXVsdCAnZGF0YTp2aWRlby9tcDQ7YmFzZTY0LHZpZGVvLWZvY3VzLXRlc3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1wNC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSAnZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhodGInICsgJ0c1ek9uaHNhVzVyUFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eE9UazVMM2hzYVc1cklpQnBaRDBpYzNabklqNDhkR1Y0ZENCNFBTSXhNQ0lnZVQwaU1qQWlJR2xrUFNKJyArICd6ZG1jdGJHbHVheTEwWlhoMElqNTBaWGgwUEM5MFpYaDBQand2YzNablBnPT0nO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdmcuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3ZlcnNpb24gPSByZXF1aXJlKCcuLi92ZXJzaW9uJyk7XG5cbnZhciBfdmVyc2lvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92ZXJzaW9uKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gcmVhZExvY2FsU3RvcmFnZShrZXkpIHtcbiAgLy8gYWxsb3cgcmVhZGluZyBmcm9tIHN0b3JhZ2UgdG8gcmV0cmlldmUgcHJldmlvdXMgc3VwcG9ydCByZXN1bHRzXG4gIC8vIGV2ZW4gd2hpbGUgdGhlIGRvY3VtZW50IGRvZXMgbm90IGhhdmUgZm9jdXNcbiAgdmFyIGRhdGEgPSB2b2lkIDA7XG5cbiAgdHJ5IHtcbiAgICBkYXRhID0gd2luZG93LmxvY2FsU3RvcmFnZSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICBkYXRhID0gZGF0YSA/IEpTT04ucGFyc2UoZGF0YSkgOiB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRhdGEgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufSAvKlxuICAgICAgRmFjaWxpdHkgdG8gY2FjaGUgdGVzdCByZXN1bHRzIGluIGxvY2FsU3RvcmFnZS5cbiAgXG4gICAgICBVU0FHRTpcbiAgICAgICAgY2FjaGUuZ2V0KCdrZXknKTtcbiAgICAgICAgY2FjaGUuc2V0KCdrZXknLCAndmFsdWUnKTtcbiAgICovXG5cbmZ1bmN0aW9uIHdyaXRlTG9jYWxTdG9yYWdlKGtleSwgdmFsdWUpIHtcbiAgaWYgKCFkb2N1bWVudC5oYXNGb2N1cygpKSB7XG4gICAgLy8gaWYgdGhlIGRvY3VtZW50IGRvZXMgbm90IGhhdmUgZm9jdXMgd2hlbiB0ZXN0cyBhcmUgZXhlY3V0ZWQsIGZvY3VzKCkgbWF5XG4gICAgLy8gbm90IGJlIGhhbmRsZWQgcHJvcGVybHkgYW5kIGV2ZW50cyBtYXkgbm90IGJlIGRpc3BhdGNoZWQgaW1tZWRpYXRlbHkuXG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBkb2N1bWVudCBpcyByZWxvYWRlZCB3aGlsZSBEZXZlbG9wZXIgVG9vbHMgaGF2ZSBmb2N1cy5cbiAgICB0cnkge1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBpZ25vcmVcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICB0cnkge1xuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UgJiYgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlnbm9yZVxuICB9XG59XG5cbnZhciB1c2VyQWdlbnQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCB8fCAnJztcbnZhciBjYWNoZUtleSA9ICdhbGx5LXN1cHBvcnRzLWNhY2hlJztcbnZhciBjYWNoZSA9IHJlYWRMb2NhbFN0b3JhZ2UoY2FjaGVLZXkpO1xuXG4vLyB1cGRhdGUgdGhlIGNhY2hlIGlmIGFsbHkgb3IgdGhlIHVzZXIgYWdlbnQgY2hhbmdlZCAobmV3ZXIgdmVyc2lvbiwgZXRjKVxuaWYgKGNhY2hlLnVzZXJBZ2VudCAhPT0gdXNlckFnZW50IHx8IGNhY2hlLnZlcnNpb24gIT09IF92ZXJzaW9uMi5kZWZhdWx0KSB7XG4gIGNhY2hlID0ge307XG59XG5cbmNhY2hlLnVzZXJBZ2VudCA9IHVzZXJBZ2VudDtcbmNhY2hlLnZlcnNpb24gPSBfdmVyc2lvbjIuZGVmYXVsdDtcblxuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlcykge1xuICAgIE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBjYWNoZVtrZXldID0gdmFsdWVzW2tleV07XG4gICAgfSk7XG5cbiAgICBjYWNoZS50aW1lID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgIHdyaXRlTG9jYWxTdG9yYWdlKGNhY2hlS2V5LCBjYWNoZSk7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1cHBvcnRzLWNhY2hlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoc3VwcG9ydHNDYWNoZSkge1xuICAgIHJldHVybiBzdXBwb3J0c0NhY2hlO1xuICB9XG5cbiAgc3VwcG9ydHNDYWNoZSA9IF9zdXBwb3J0c0NhY2hlMi5kZWZhdWx0LmdldCgpO1xuICBpZiAoIXN1cHBvcnRzQ2FjaGUudGltZSkge1xuICAgIF9zdXBwb3J0c0NhY2hlMi5kZWZhdWx0LnNldChleGVjdXRlVGVzdHMoKSk7XG4gICAgc3VwcG9ydHNDYWNoZSA9IF9zdXBwb3J0c0NhY2hlMi5kZWZhdWx0LmdldCgpO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzQ2FjaGU7XG59O1xuXG52YXIgX2RldGVjdEZvY3VzID0gcmVxdWlyZSgnLi9kZXRlY3QtZm9jdXMnKTtcblxudmFyIF9kZXRlY3RGb2N1czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXRlY3RGb2N1cyk7XG5cbnZhciBfc3VwcG9ydHNDYWNoZSA9IHJlcXVpcmUoJy4vc3VwcG9ydHMtY2FjaGUnKTtcblxudmFyIF9zdXBwb3J0c0NhY2hlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N1cHBvcnRzQ2FjaGUpO1xuXG52YXIgX2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IgPSByZXF1aXJlKCcuL2Nzcy1zaGFkb3ctcGllcmNpbmctZGVlcC1jb21iaW5hdG9yJyk7XG5cbnZhciBfY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yKTtcblxudmFyIF9mb2N1c0FyZWFJbWdUYWJpbmRleCA9IHJlcXVpcmUoJy4vZm9jdXMtYXJlYS1pbWctdGFiaW5kZXgnKTtcblxudmFyIF9mb2N1c0FyZWFJbWdUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0FyZWFJbWdUYWJpbmRleCk7XG5cbnZhciBfZm9jdXNBcmVhVGFiaW5kZXggPSByZXF1aXJlKCcuL2ZvY3VzLWFyZWEtdGFiaW5kZXgnKTtcblxudmFyIF9mb2N1c0FyZWFUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0FyZWFUYWJpbmRleCk7XG5cbnZhciBfZm9jdXNBcmVhV2l0aG91dEhyZWYgPSByZXF1aXJlKCcuL2ZvY3VzLWFyZWEtd2l0aG91dC1ocmVmJyk7XG5cbnZhciBfZm9jdXNBcmVhV2l0aG91dEhyZWYyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNBcmVhV2l0aG91dEhyZWYpO1xuXG52YXIgX2ZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMgPSByZXF1aXJlKCcuL2ZvY3VzLWF1ZGlvLXdpdGhvdXQtY29udHJvbHMnKTtcblxudmFyIF9mb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHMpO1xuXG52YXIgX2ZvY3VzQnJva2VuSW1hZ2VNYXAgPSByZXF1aXJlKCcuL2ZvY3VzLWJyb2tlbi1pbWFnZS1tYXAnKTtcblxudmFyIF9mb2N1c0Jyb2tlbkltYWdlTWFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzQnJva2VuSW1hZ2VNYXApO1xuXG52YXIgX2ZvY3VzQ2hpbGRyZW5PZkZvY3VzYWJsZUZsZXhib3ggPSByZXF1aXJlKCcuL2ZvY3VzLWNoaWxkcmVuLW9mLWZvY3VzYWJsZS1mbGV4Ym94Jyk7XG5cbnZhciBfZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0NoaWxkcmVuT2ZGb2N1c2FibGVGbGV4Ym94KTtcblxudmFyIF9mb2N1c0ZpZWxkc2V0RGlzYWJsZWQgPSByZXF1aXJlKCcuL2ZvY3VzLWZpZWxkc2V0LWRpc2FibGVkJyk7XG5cbnZhciBfZm9jdXNGaWVsZHNldERpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzRmllbGRzZXREaXNhYmxlZCk7XG5cbnZhciBfZm9jdXNGaWVsZHNldCA9IHJlcXVpcmUoJy4vZm9jdXMtZmllbGRzZXQnKTtcblxudmFyIF9mb2N1c0ZpZWxkc2V0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzRmllbGRzZXQpO1xuXG52YXIgX2ZvY3VzRmxleGJveENvbnRhaW5lciA9IHJlcXVpcmUoJy4vZm9jdXMtZmxleGJveC1jb250YWluZXInKTtcblxudmFyIF9mb2N1c0ZsZXhib3hDb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNGbGV4Ym94Q29udGFpbmVyKTtcblxudmFyIF9mb2N1c0Zvcm1EaXNhYmxlZCA9IHJlcXVpcmUoJy4vZm9jdXMtZm9ybS1kaXNhYmxlZCcpO1xuXG52YXIgX2ZvY3VzRm9ybURpc2FibGVkMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzRm9ybURpc2FibGVkKTtcblxudmFyIF9mb2N1c0ltZ0lzbWFwID0gcmVxdWlyZSgnLi9mb2N1cy1pbWctaXNtYXAnKTtcblxudmFyIF9mb2N1c0ltZ0lzbWFwMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzSW1nSXNtYXApO1xuXG52YXIgX2ZvY3VzSW1nVXNlbWFwVGFiaW5kZXggPSByZXF1aXJlKCcuL2ZvY3VzLWltZy11c2VtYXAtdGFiaW5kZXgnKTtcblxudmFyIF9mb2N1c0ltZ1VzZW1hcFRhYmluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzSW1nVXNlbWFwVGFiaW5kZXgpO1xuXG52YXIgX2ZvY3VzSW5IaWRkZW5JZnJhbWUgPSByZXF1aXJlKCcuL2ZvY3VzLWluLWhpZGRlbi1pZnJhbWUnKTtcblxudmFyIF9mb2N1c0luSGlkZGVuSWZyYW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzSW5IaWRkZW5JZnJhbWUpO1xuXG52YXIgX2ZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0ID0gcmVxdWlyZSgnLi9mb2N1cy1pbi16ZXJvLWRpbWVuc2lvbi1vYmplY3QnKTtcblxudmFyIF9mb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0luWmVyb0RpbWVuc2lvbk9iamVjdCk7XG5cbnZhciBfZm9jdXNJbnZhbGlkVGFiaW5kZXggPSByZXF1aXJlKCcuL2ZvY3VzLWludmFsaWQtdGFiaW5kZXgnKTtcblxudmFyIF9mb2N1c0ludmFsaWRUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0ludmFsaWRUYWJpbmRleCk7XG5cbnZhciBfZm9jdXNMYWJlbFRhYmluZGV4ID0gcmVxdWlyZSgnLi9mb2N1cy1sYWJlbC10YWJpbmRleCcpO1xuXG52YXIgX2ZvY3VzTGFiZWxUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c0xhYmVsVGFiaW5kZXgpO1xuXG52YXIgX2ZvY3VzT2JqZWN0U3ZnSGlkZGVuID0gcmVxdWlyZSgnLi9mb2N1cy1vYmplY3Qtc3ZnLWhpZGRlbicpO1xuXG52YXIgX2ZvY3VzT2JqZWN0U3ZnSGlkZGVuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzT2JqZWN0U3ZnSGlkZGVuKTtcblxudmFyIF9mb2N1c09iamVjdFN2ZyA9IHJlcXVpcmUoJy4vZm9jdXMtb2JqZWN0LXN2ZycpO1xuXG52YXIgX2ZvY3VzT2JqZWN0U3ZnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzT2JqZWN0U3ZnKTtcblxudmFyIF9mb2N1c09iamVjdFN3ZiA9IHJlcXVpcmUoJy4vZm9jdXMtb2JqZWN0LXN3ZicpO1xuXG52YXIgX2ZvY3VzT2JqZWN0U3dmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzT2JqZWN0U3dmKTtcblxudmFyIF9mb2N1c1JlZGlyZWN0SW1nVXNlbWFwID0gcmVxdWlyZSgnLi9mb2N1cy1yZWRpcmVjdC1pbWctdXNlbWFwJyk7XG5cbnZhciBfZm9jdXNSZWRpcmVjdEltZ1VzZW1hcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1JlZGlyZWN0SW1nVXNlbWFwKTtcblxudmFyIF9mb2N1c1JlZGlyZWN0TGVnZW5kID0gcmVxdWlyZSgnLi9mb2N1cy1yZWRpcmVjdC1sZWdlbmQnKTtcblxudmFyIF9mb2N1c1JlZGlyZWN0TGVnZW5kMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzUmVkaXJlY3RMZWdlbmQpO1xuXG52YXIgX2ZvY3VzU2Nyb2xsQm9keSA9IHJlcXVpcmUoJy4vZm9jdXMtc2Nyb2xsLWJvZHknKTtcblxudmFyIF9mb2N1c1Njcm9sbEJvZHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNTY3JvbGxCb2R5KTtcblxudmFyIF9mb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdyA9IHJlcXVpcmUoJy4vZm9jdXMtc2Nyb2xsLWNvbnRhaW5lci13aXRob3V0LW92ZXJmbG93Jyk7XG5cbnZhciBfZm9jdXNTY3JvbGxDb250YWluZXJXaXRob3V0T3ZlcmZsb3cyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNTY3JvbGxDb250YWluZXJXaXRob3V0T3ZlcmZsb3cpO1xuXG52YXIgX2ZvY3VzU2Nyb2xsQ29udGFpbmVyID0gcmVxdWlyZSgnLi9mb2N1cy1zY3JvbGwtY29udGFpbmVyJyk7XG5cbnZhciBfZm9jdXNTY3JvbGxDb250YWluZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNTY3JvbGxDb250YWluZXIpO1xuXG52YXIgX2ZvY3VzU3VtbWFyeSA9IHJlcXVpcmUoJy4vZm9jdXMtc3VtbWFyeScpO1xuXG52YXIgX2ZvY3VzU3VtbWFyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N1bW1hcnkpO1xuXG52YXIgX2ZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlID0gcmVxdWlyZSgnLi9mb2N1cy1zdmctZm9jdXNhYmxlLWF0dHJpYnV0ZScpO1xuXG52YXIgX2ZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlKTtcblxudmFyIF9mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlID0gcmVxdWlyZSgnLi9mb2N1cy1zdmctdGFiaW5kZXgtYXR0cmlidXRlJyk7XG5cbnZhciBfZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlKTtcblxudmFyIF9mb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGUgPSByZXF1aXJlKCcuL2ZvY3VzLXN2Zy1uZWdhdGl2ZS10YWJpbmRleC1hdHRyaWJ1dGUnKTtcblxudmFyIF9mb2N1c1N2Z05lZ2F0aXZlVGFiaW5kZXhBdHRyaWJ1dGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlKTtcblxudmFyIF9mb2N1c1N2Z1VzZVRhYmluZGV4ID0gcmVxdWlyZSgnLi9mb2N1cy1zdmctdXNlLXRhYmluZGV4Jyk7XG5cbnZhciBfZm9jdXNTdmdVc2VUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z1VzZVRhYmluZGV4KTtcblxudmFyIF9mb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleCA9IHJlcXVpcmUoJy4vZm9jdXMtc3ZnLWZvcmVpZ25vYmplY3QtdGFiaW5kZXgnKTtcblxudmFyIF9mb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleCk7XG5cbnZhciBfZm9jdXNTdmdJbklmcmFtZSA9IHJlcXVpcmUoJy4vZm9jdXMtc3ZnLWluLWlmcmFtZScpO1xuXG52YXIgX2ZvY3VzU3ZnSW5JZnJhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNTdmdJbklmcmFtZSk7XG5cbnZhciBfZm9jdXNTdmcgPSByZXF1aXJlKCcuL2ZvY3VzLXN2ZycpO1xuXG52YXIgX2ZvY3VzU3ZnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZvY3VzU3ZnKTtcblxudmFyIF9mb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzID0gcmVxdWlyZSgnLi9mb2N1cy10YWJpbmRleC10cmFpbGluZy1jaGFyYWN0ZXJzJyk7XG5cbnZhciBfZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mb2N1c1RhYmluZGV4VHJhaWxpbmdDaGFyYWN0ZXJzKTtcblxudmFyIF9mb2N1c1RhYmxlID0gcmVxdWlyZSgnLi9mb2N1cy10YWJsZScpO1xuXG52YXIgX2ZvY3VzVGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNUYWJsZSk7XG5cbnZhciBfZm9jdXNWaWRlb1dpdGhvdXRDb250cm9scyA9IHJlcXVpcmUoJy4vZm9jdXMtdmlkZW8td2l0aG91dC1jb250cm9scycpO1xuXG52YXIgX2ZvY3VzVmlkZW9XaXRob3V0Q29udHJvbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9jdXNWaWRlb1dpdGhvdXRDb250cm9scyk7XG5cbnZhciBfdGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbiA9IHJlcXVpcmUoJy4vdGFic2VxdWVuY2UtYXJlYS1hdC1pbWctcG9zaXRpb24nKTtcblxudmFyIF90YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3RhYnNlcXVlbmNlQXJlYUF0SW1nUG9zaXRpb24pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgdGVzdENhbGxiYWNrcyA9IHtcbiAgY3NzU2hhZG93UGllcmNpbmdEZWVwQ29tYmluYXRvcjogX2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IyLmRlZmF1bHQsXG4gIGZvY3VzSW5aZXJvRGltZW5zaW9uT2JqZWN0OiBfZm9jdXNJblplcm9EaW1lbnNpb25PYmplY3QyLmRlZmF1bHQsXG4gIGZvY3VzT2JqZWN0U3dmOiBfZm9jdXNPYmplY3RTd2YyLmRlZmF1bHQsXG4gIGZvY3VzU3ZnSW5JZnJhbWU6IF9mb2N1c1N2Z0luSWZyYW1lMi5kZWZhdWx0LFxuICB0YWJzZXF1ZW5jZUFyZWFBdEltZ1Bvc2l0aW9uOiBfdGFic2VxdWVuY2VBcmVhQXRJbWdQb3NpdGlvbjIuZGVmYXVsdFxufTtcblxudmFyIHRlc3REZXNjcmlwdGlvbnMgPSB7XG4gIGZvY3VzQXJlYUltZ1RhYmluZGV4OiBfZm9jdXNBcmVhSW1nVGFiaW5kZXgyLmRlZmF1bHQsXG4gIGZvY3VzQXJlYVRhYmluZGV4OiBfZm9jdXNBcmVhVGFiaW5kZXgyLmRlZmF1bHQsXG4gIGZvY3VzQXJlYVdpdGhvdXRIcmVmOiBfZm9jdXNBcmVhV2l0aG91dEhyZWYyLmRlZmF1bHQsXG4gIGZvY3VzQXVkaW9XaXRob3V0Q29udHJvbHM6IF9mb2N1c0F1ZGlvV2l0aG91dENvbnRyb2xzMi5kZWZhdWx0LFxuICBmb2N1c0Jyb2tlbkltYWdlTWFwOiBfZm9jdXNCcm9rZW5JbWFnZU1hcDIuZGVmYXVsdCxcbiAgZm9jdXNDaGlsZHJlbk9mRm9jdXNhYmxlRmxleGJveDogX2ZvY3VzQ2hpbGRyZW5PZkZvY3VzYWJsZUZsZXhib3gyLmRlZmF1bHQsXG4gIGZvY3VzRmllbGRzZXREaXNhYmxlZDogX2ZvY3VzRmllbGRzZXREaXNhYmxlZDIuZGVmYXVsdCxcbiAgZm9jdXNGaWVsZHNldDogX2ZvY3VzRmllbGRzZXQyLmRlZmF1bHQsXG4gIGZvY3VzRmxleGJveENvbnRhaW5lcjogX2ZvY3VzRmxleGJveENvbnRhaW5lcjIuZGVmYXVsdCxcbiAgZm9jdXNGb3JtRGlzYWJsZWQ6IF9mb2N1c0Zvcm1EaXNhYmxlZDIuZGVmYXVsdCxcbiAgZm9jdXNJbWdJc21hcDogX2ZvY3VzSW1nSXNtYXAyLmRlZmF1bHQsXG4gIGZvY3VzSW1nVXNlbWFwVGFiaW5kZXg6IF9mb2N1c0ltZ1VzZW1hcFRhYmluZGV4Mi5kZWZhdWx0LFxuICBmb2N1c0luSGlkZGVuSWZyYW1lOiBfZm9jdXNJbkhpZGRlbklmcmFtZTIuZGVmYXVsdCxcbiAgZm9jdXNJbnZhbGlkVGFiaW5kZXg6IF9mb2N1c0ludmFsaWRUYWJpbmRleDIuZGVmYXVsdCxcbiAgZm9jdXNMYWJlbFRhYmluZGV4OiBfZm9jdXNMYWJlbFRhYmluZGV4Mi5kZWZhdWx0LFxuICBmb2N1c09iamVjdFN2ZzogX2ZvY3VzT2JqZWN0U3ZnMi5kZWZhdWx0LFxuICBmb2N1c09iamVjdFN2Z0hpZGRlbjogX2ZvY3VzT2JqZWN0U3ZnSGlkZGVuMi5kZWZhdWx0LFxuICBmb2N1c1JlZGlyZWN0SW1nVXNlbWFwOiBfZm9jdXNSZWRpcmVjdEltZ1VzZW1hcDIuZGVmYXVsdCxcbiAgZm9jdXNSZWRpcmVjdExlZ2VuZDogX2ZvY3VzUmVkaXJlY3RMZWdlbmQyLmRlZmF1bHQsXG4gIGZvY3VzU2Nyb2xsQm9keTogX2ZvY3VzU2Nyb2xsQm9keTIuZGVmYXVsdCxcbiAgZm9jdXNTY3JvbGxDb250YWluZXJXaXRob3V0T3ZlcmZsb3c6IF9mb2N1c1Njcm9sbENvbnRhaW5lcldpdGhvdXRPdmVyZmxvdzIuZGVmYXVsdCxcbiAgZm9jdXNTY3JvbGxDb250YWluZXI6IF9mb2N1c1Njcm9sbENvbnRhaW5lcjIuZGVmYXVsdCxcbiAgZm9jdXNTdW1tYXJ5OiBfZm9jdXNTdW1tYXJ5Mi5kZWZhdWx0LFxuICBmb2N1c1N2Z0ZvY3VzYWJsZUF0dHJpYnV0ZTogX2ZvY3VzU3ZnRm9jdXNhYmxlQXR0cmlidXRlMi5kZWZhdWx0LFxuICBmb2N1c1N2Z1RhYmluZGV4QXR0cmlidXRlOiBfZm9jdXNTdmdUYWJpbmRleEF0dHJpYnV0ZTIuZGVmYXVsdCxcbiAgZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlOiBfZm9jdXNTdmdOZWdhdGl2ZVRhYmluZGV4QXR0cmlidXRlMi5kZWZhdWx0LFxuICBmb2N1c1N2Z1VzZVRhYmluZGV4OiBfZm9jdXNTdmdVc2VUYWJpbmRleDIuZGVmYXVsdCxcbiAgZm9jdXNTdmdGb3JlaWdub2JqZWN0VGFiaW5kZXg6IF9mb2N1c1N2Z0ZvcmVpZ25vYmplY3RUYWJpbmRleDIuZGVmYXVsdCxcbiAgZm9jdXNTdmc6IF9mb2N1c1N2ZzIuZGVmYXVsdCxcbiAgZm9jdXNUYWJpbmRleFRyYWlsaW5nQ2hhcmFjdGVyczogX2ZvY3VzVGFiaW5kZXhUcmFpbGluZ0NoYXJhY3RlcnMyLmRlZmF1bHQsXG4gIGZvY3VzVGFibGU6IF9mb2N1c1RhYmxlMi5kZWZhdWx0LFxuICBmb2N1c1ZpZGVvV2l0aG91dENvbnRyb2xzOiBfZm9jdXNWaWRlb1dpdGhvdXRDb250cm9sczIuZGVmYXVsdFxufTtcblxuZnVuY3Rpb24gZXhlY3V0ZVRlc3RzKCkge1xuICB2YXIgcmVzdWx0cyA9ICgwLCBfZGV0ZWN0Rm9jdXMyLmRlZmF1bHQpKHRlc3REZXNjcmlwdGlvbnMpO1xuICBPYmplY3Qua2V5cyh0ZXN0Q2FsbGJhY2tzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXN1bHRzW2tleV0gPSB0ZXN0Q2FsbGJhY2tzW2tleV0oKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbnZhciBzdXBwb3J0c0NhY2hlID0gbnVsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdXBwb3J0cy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBfcGxhdGZvcm0gPSByZXF1aXJlKCcuLi91dGlsL3BsYXRmb3JtJyk7XG5cbnZhciBfcGxhdGZvcm0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBodHRwczovL2pzYmluLmNvbS92YWZhYmEvMy9lZGl0P2h0bWwsanMsY29uc29sZSxvdXRwdXRcbnZhciByZXN1bHQgPSBfcGxhdGZvcm0yLmRlZmF1bHQuaXMuR0VDS08gfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLlRSSURFTlQgfHwgX3BsYXRmb3JtMi5kZWZhdWx0LmlzLkVER0U7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFic2VxdWVuY2UtYXJlYS1hdC1pbWctcG9zaXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmaW5kSW5kZXg7XG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGNhbGxiYWNrKSB7XG4gIC8vIGF0dGVtcHQgdG8gdXNlIG5hdGl2ZSBvciBwb2x5ZmlsbGVkIEFycmF5I2ZpbmRJbmRleCBmaXJzdFxuICBpZiAoYXJyYXkuZmluZEluZGV4KSB7XG4gICAgcmV0dXJuIGFycmF5LmZpbmRJbmRleChjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIC8vIHNob3J0Y3V0IGlmIHRoZSBhcnJheSBpcyBlbXB0eVxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLy8gb3RoZXJ3aXNlIGxvb3Agb3ZlciBhcnJheVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNhbGxiYWNrKGFycmF5W2ldLCBpLCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS1maW5kLWluZGV4LmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0UGFyZW50Q29tcGFyYXRvciA9IGdldFBhcmVudENvbXBhcmF0b3I7XG5cbi8vIE5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gaXMgYXZhaWxhYmxlIHNpbmNlIElFOVxuLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cbi8vIGNhbGxiYWNrIHJldHVybnMgdHJ1ZSB3aGVuIGVsZW1lbnQgaXMgY29udGFpbmVkIGJ5IHBhcmVudCBvciBpcyB0aGUgcGFyZW50IHN1aXRlZCBmb3IgdXNlIHdpdGggQXJyYXkuc29tZSgpXG4vKlxuICBVU0FHRTpcbiAgICB2YXIgaXNDaGlsZE9mID0gZ2V0UGFyZW50Q29tcGFyYXRvcih7cGFyZW50OiBzb21lTm9kZX0pO1xuICAgIGxpc3RPZkVsZW1lbnRzLnNvbWUoaXNDaGlsZE9mKVxuKi9cblxuZnVuY3Rpb24gZ2V0UGFyZW50Q29tcGFyYXRvcigpIHtcbiAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgcGFyZW50ID0gX3JlZi5wYXJlbnQsXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgaW5jbHVkZVNlbGYgPSBfcmVmLmluY2x1ZGVTZWxmO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNDaGlsZE9mKG5vZGUpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKGluY2x1ZGVTZWxmICYmIG5vZGUgPT09IHBhcmVudCB8fCBwYXJlbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24obm9kZSkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzUGFyZW50T2Yobm9kZSkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4oaW5jbHVkZVNlbGYgJiYgZWxlbWVudCA9PT0gbm9kZSB8fCBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlORURfQlkpO1xuICAgIH07XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1dGlsL2NvbXBhcmUtcG9zaXRpb24jZ2V0UGFyZW50Q29tcGFyYXRvciByZXF1aXJlZCBlaXRoZXIgb3B0aW9ucy5wYXJlbnQgb3Igb3B0aW9ucy5lbGVtZW50Jyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wYXJlLXBvc2l0aW9uLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKF9yZWYpIHtcbiAgdmFyIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICBfcmVmJGxhYmVsID0gX3JlZi5sYWJlbCxcbiAgICAgIGxhYmVsID0gX3JlZiRsYWJlbCA9PT0gdW5kZWZpbmVkID8gJ2NvbnRleHQtdG8tZWxlbWVudCcgOiBfcmVmJGxhYmVsLFxuICAgICAgcmVzb2x2ZURvY3VtZW50ID0gX3JlZi5yZXNvbHZlRG9jdW1lbnQsXG4gICAgICBkZWZhdWx0VG9Eb2N1bWVudCA9IF9yZWYuZGVmYXVsdFRvRG9jdW1lbnQ7XG5cbiAgdmFyIGVsZW1lbnQgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkoY29udGV4dClbMF07XG5cbiAgaWYgKHJlc29sdmVEb2N1bWVudCAmJiBlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIGlmICghZWxlbWVudCAmJiBkZWZhdWx0VG9Eb2N1bWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGxhYmVsICsgJyByZXF1aXJlcyB2YWxpZCBvcHRpb25zLmNvbnRleHQnKTtcbiAgfVxuXG4gIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBlbGVtZW50Lm5vZGVUeXBlICE9PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGxhYmVsICsgJyByZXF1aXJlcyBvcHRpb25zLmNvbnRleHQgdG8gYmUgYW4gRWxlbWVudCcpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG52YXIgX25vZGVBcnJheSA9IHJlcXVpcmUoJy4uL3V0aWwvbm9kZS1hcnJheScpO1xuXG52YXIgX25vZGVBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ub2RlQXJyYXkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnRleHQtdG8tZWxlbWVudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBlbGVtZW50TWF0Y2hlcztcblxuLy8gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyBtYXkgYmUgYXZhaWxhYmxlIGF0IGEgZGlmZmVyZW50IG5hbWVcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9FbGVtZW50L21hdGNoZXNcblxudmFyIG5hbWVzID0gWydtYXRjaGVzJywgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicsICdtb3pNYXRjaGVzU2VsZWN0b3InLCAnbXNNYXRjaGVzU2VsZWN0b3InXTtcbnZhciBuYW1lID0gbnVsbDtcblxuZnVuY3Rpb24gZmluZE1ldGhvZE5hbWUoZWxlbWVudCkge1xuICBuYW1lcy5zb21lKGZ1bmN0aW9uIChfbmFtZSkge1xuICAgIGlmICghZWxlbWVudFtfbmFtZV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBuYW1lID0gX25hbWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlcyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICBpZiAoIW5hbWUpIHtcbiAgICBmaW5kTWV0aG9kTmFtZShlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W25hbWVdKHNlbGVjdG9yKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWxlbWVudC1tYXRjaGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB0cnkge1xuICAgIC8vIHdvcmtzIG9uIDxvYmplY3Q+IGFuZCA8aWZyYW1lPlxuICAgIHJldHVybiBub2RlLmNvbnRlbnREb2N1bWVudFxuICAgIC8vIHdvcmtzIG9uIDxvYmplY3Q+IGFuZCA8aWZyYW1lPlxuICAgIHx8IG5vZGUuY29udGVudFdpbmRvdyAmJiBub2RlLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnRcbiAgICAvLyB3b3JrcyBvbiA8b2JqZWN0PiBhbmQgPGlmcmFtZT4gdGhhdCBjb250YWluIFNWR1xuICAgIHx8IG5vZGUuZ2V0U1ZHRG9jdW1lbnQgJiYgbm9kZS5nZXRTVkdEb2N1bWVudCgpIHx8IG51bGw7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBTZWN1cml0eUVycm9yOiBGYWlsZWQgdG8gcmVhZCB0aGUgJ2NvbnRlbnREb2N1bWVudCcgcHJvcGVydHkgZnJvbSAnSFRNTE9iamVjdEVsZW1lbnQnXG4gICAgLy8gYWxzbyBJRSBtYXkgdGhyb3cgbWVtYmVyIG5vdCBmb3VuZCBleGNlcHRpb24gZS5nLiBvbiA8b2JqZWN0IHR5cGU9XCJpbWFnZS9wbmdcIj5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1jb250ZW50LWRvY3VtZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQ7XG4gIH1cblxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1kb2N1bWVudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRGcmFtZUVsZW1lbnQ7XG5cbnZhciBfZ2V0Q29udGVudERvY3VtZW50ID0gcmVxdWlyZSgnLi9nZXQtY29udGVudC1kb2N1bWVudCcpO1xuXG52YXIgX2dldENvbnRlbnREb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRDb250ZW50RG9jdW1lbnQpO1xuXG52YXIgX2dldFdpbmRvdyA9IHJlcXVpcmUoJy4vZ2V0LXdpbmRvdycpO1xuXG52YXIgX2dldFdpbmRvdzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRXaW5kb3cpO1xuXG52YXIgX3NlbGVjdEluU2hhZG93cyA9IHJlcXVpcmUoJy4vc2VsZWN0LWluLXNoYWRvd3MnKTtcblxudmFyIF9zZWxlY3RJblNoYWRvd3MyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2VsZWN0SW5TaGFkb3dzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHNlbGVjdG9yID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBmaW5kRG9jdW1lbnRIb3N0RWxlbWVudChfd2luZG93KSB7XG4gIGlmICghc2VsZWN0b3IpIHtcbiAgICBzZWxlY3RvciA9ICgwLCBfc2VsZWN0SW5TaGFkb3dzMi5kZWZhdWx0KSgnb2JqZWN0LCBpZnJhbWUnKTtcbiAgfVxuXG4gIGlmIChfd2luZG93Ll9mcmFtZUVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBfd2luZG93Ll9mcmFtZUVsZW1lbnQ7XG4gIH1cblxuICBfd2luZG93Ll9mcmFtZUVsZW1lbnQgPSBudWxsO1xuXG4gIHZhciBwb3RlbnRpYWxIb3N0cyA9IF93aW5kb3cucGFyZW50LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICBbXS5zb21lLmNhbGwocG90ZW50aWFsSG9zdHMsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIF9kb2N1bWVudCA9ICgwLCBfZ2V0Q29udGVudERvY3VtZW50Mi5kZWZhdWx0KShlbGVtZW50KTtcbiAgICBpZiAoX2RvY3VtZW50ICE9PSBfd2luZG93LmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgX3dpbmRvdy5fZnJhbWVFbGVtZW50ID0gZWxlbWVudDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIF93aW5kb3cuX2ZyYW1lRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0RnJhbWVFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIF93aW5kb3cgPSAoMCwgX2dldFdpbmRvdzIuZGVmYXVsdCkoZWxlbWVudCk7XG4gIGlmICghX3dpbmRvdy5wYXJlbnQgfHwgX3dpbmRvdy5wYXJlbnQgPT09IF93aW5kb3cpIHtcbiAgICAvLyBpZiB0aGVyZSBpcyBubyBwYXJlbnQgYnJvd3NpbmcgY29udGV4dCxcbiAgICAvLyB3ZSdyZSBub3QgZ29pbmcgdG8gZ2V0IGEgZnJhbWVFbGVtZW50IGVpdGhlciB3YXlcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvZnJhbWVFbGVtZW50XG4gICAgLy8gZG9lcyBub3Qgd29yayB3aXRoaW4gPGVtYmVkPiBhbnl3aGVyZSwgYW5kIG5vdCB3aXRoaW4gaW4gPG9iamVjdD4gaW4gSUVcbiAgICByZXR1cm4gX3dpbmRvdy5mcmFtZUVsZW1lbnQgfHwgZmluZERvY3VtZW50SG9zdEVsZW1lbnQoX3dpbmRvdyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtZnJhbWUtZWxlbWVudC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBfZG9jdW1lbnQgPSAoMCwgX2dldERvY3VtZW50Mi5kZWZhdWx0KShub2RlKTtcbiAgcmV0dXJuIF9kb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG59O1xuXG52YXIgX2dldERvY3VtZW50ID0gcmVxdWlyZSgnLi9nZXQtZG9jdW1lbnQnKTtcblxudmFyIF9nZXREb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXREb2N1bWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0LXdpbmRvdy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldE1hcEJ5TmFtZSA9IGdldE1hcEJ5TmFtZTtcbmV4cG9ydHMuZ2V0TWFwT2ZJbWFnZSA9IGdldE1hcE9mSW1hZ2U7XG5leHBvcnRzLmdldEltYWdlT2ZBcmVhID0gZ2V0SW1hZ2VPZkFyZWE7XG5cbnZhciBfY3NzID0gcmVxdWlyZSgnY3NzLmVzY2FwZScpO1xuXG52YXIgX2NzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jc3MpO1xuXG52YXIgX2dldERvY3VtZW50ID0gcmVxdWlyZSgnLi4vdXRpbC9nZXQtZG9jdW1lbnQnKTtcblxudmFyIF9nZXREb2N1bWVudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXREb2N1bWVudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldE1hcEJ5TmFtZShuYW1lLCBfZG9jdW1lbnQpIHtcbiAgLy8gYXBwYXJlbnRseSBnZXRFbGVtZW50c0J5TmFtZSgpIGFsc28gY29uc2lkZXJzIGlkIGF0dHJpYnV0ZSBpbiBJRSAmIG9wZXJhXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9nZXRFbGVtZW50c0J5TmFtZVxuICB2YXIgbWFwID0gX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21hcFtuYW1lPVwiJyArICgwLCBfY3NzMi5kZWZhdWx0KShuYW1lKSArICdcIl0nKTtcbiAgcmV0dXJuIG1hcCB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRNYXBPZkltYWdlKGVsZW1lbnQpIHtcbiAgdmFyIHVzZW1hcCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd1c2VtYXAnKTtcbiAgaWYgKCF1c2VtYXApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBfZG9jdW1lbnQgPSAoMCwgX2dldERvY3VtZW50Mi5kZWZhdWx0KShlbGVtZW50KTtcbiAgcmV0dXJuIGdldE1hcEJ5TmFtZSh1c2VtYXAuc2xpY2UoMSksIF9kb2N1bWVudCk7XG59XG5cbmZ1bmN0aW9uIGdldEltYWdlT2ZBcmVhKGVsZW1lbnQpIHtcbiAgdmFyIG1hcCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcblxuICBpZiAoIW1hcC5uYW1lIHx8IG1hcC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnbWFwJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTk9URTogaW1hZ2UgbWFwcyBjYW4gYWxzbyBiZSBhcHBsaWVkIHRvIDxvYmplY3Q+IHdpdGggaW1hZ2UgY29udGVudCxcbiAgLy8gYnV0IG5vIGJyb3dzZXIgc3VwcG9ydHMgdGhpcyBhdCB0aGUgbW9tZW50XG5cbiAgLy8gSFRNTDUgc3BlY2lmaWVzIEhUTUxNYXBFbGVtZW50LmltYWdlcyB0byBiZSBhbiBIVE1MQ29sbGVjdGlvbiBvZiBhbGxcbiAgLy8gPGltZz4gYW5kIDxvYmplY3Q+IHJlZmVyZW5jaW5nIHRoZSA8bWFwPiBlbGVtZW50LCBidXQgbm8gYnJvd3NlciBpbXBsZW1lbnRzIHRoaXNcbiAgLy8gICBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZW1iZWRkZWQtY29udGVudC0wLmh0bWwjdGhlLW1hcC1lbGVtZW50XG4gIC8vICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxNYXBFbGVtZW50XG4gIC8vIHRoZSBpbWFnZSBtdXN0IGJlIHZhbGlkIGFuZCBsb2FkZWQgZm9yIHRoZSBtYXAgdG8gdGFrZSBlZmZlY3RcbiAgdmFyIF9kb2N1bWVudCA9ICgwLCBfZ2V0RG9jdW1lbnQyLmRlZmF1bHQpKGVsZW1lbnQpO1xuICByZXR1cm4gX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZ1t1c2VtYXA9XCIjJyArICgwLCBfY3NzMi5kZWZhdWx0KShtYXAubmFtZSkgKyAnXCJdJykgfHwgbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLW1hcC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xudmFyIF9jb25zb2xlID0ge1xuICBsb2c6IG5vb3AsXG4gIGRlYnVnOiBub29wLFxuICBpbmZvOiBub29wLFxuICB3YXJuOiBub29wLFxuICBlcnJvcjogbm9vcFxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnID8gY29uc29sZSA6IF9jb25zb2xlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXIuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIGxpc3QgPSBfcmVmLmxpc3QsXG4gICAgICBlbGVtZW50cyA9IF9yZWYuZWxlbWVudHMsXG4gICAgICByZXNvbHZlRWxlbWVudCA9IF9yZWYucmVzb2x2ZUVsZW1lbnQ7XG5cbiAgLy8gb3BlcmF0ZSBvbiBhIGNvcHkgc28gd2UgZG9uJ3QgbXV0YXRlIHRoZSBvcmlnaW5hbCBhcnJheVxuICB2YXIgX2xpc3QgPSBsaXN0LnNsaWNlKDApO1xuICAvLyBtYWtlIHN1cmUgdGhlIGVsZW1lbnRzIHdlJ3JlIGluamVjdGluZyBhcmUgcHJvdmlkZWQgaW4gRE9NIG9yZGVyXG4gIHZhciBfZWxlbWVudHMgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkoZWxlbWVudHMpLnNsaWNlKDApO1xuICAoMCwgX3NvcnREb21PcmRlcjIuZGVmYXVsdCkoX2VsZW1lbnRzKTtcbiAgLy8gZmluZCB0aGUgb2Zmc2V0cyB3aXRoaW4gdGhlIHRhcmdldCBhcnJheSAobGlzdCkgYXQgd2hpY2ggdG8gaW5qZWN0XG4gIC8vIGVhY2ggaW5kaXZpZHVhbCBlbGVtZW50IChmcm9tIGVsZW1lbnRzKVxuICB2YXIgaW5zZXJ0aW9ucyA9IGZpbmRJbnNlcnRpb25PZmZzZXRzKF9saXN0LCBfZWxlbWVudHMsIHJlc29sdmVFbGVtZW50KTtcbiAgLy8gYWN0dWFsbHkgaW5qZWN0IHRoZSBlbGVtZW50cyBpbnRvIHRoZSB0YXJnZXQgYXJyYXkgYXQgdGhlIGlkZW50aWZpZWQgcG9zaXRpb25zXG4gIGluc2VydEVsZW1lbnRzQXRPZmZzZXRzKF9saXN0LCBpbnNlcnRpb25zKTtcbiAgcmV0dXJuIF9saXN0O1xufTtcblxudmFyIF9hcnJheUZpbmRJbmRleCA9IHJlcXVpcmUoJy4uL3V0aWwvYXJyYXktZmluZC1pbmRleCcpO1xuXG52YXIgX2FycmF5RmluZEluZGV4MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5RmluZEluZGV4KTtcblxudmFyIF9ub2RlQXJyYXkgPSByZXF1aXJlKCcuL25vZGUtYXJyYXknKTtcblxudmFyIF9ub2RlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9kZUFycmF5KTtcblxudmFyIF9zb3J0RG9tT3JkZXIgPSByZXF1aXJlKCcuL3NvcnQtZG9tLW9yZGVyJyk7XG5cbnZhciBfc29ydERvbU9yZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NvcnREb21PcmRlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldEZpcnN0U3VjY2Vzc29yT2Zmc2V0KGxpc3QsIHRhcmdldCkge1xuICAvLyBmaW5kIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgY29tZXMgQUZURVIgdGhlIHRhcmdldCBlbGVtZW50XG4gIHJldHVybiAoMCwgX2FycmF5RmluZEluZGV4Mi5kZWZhdWx0KShsaXN0LCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiB0YXJnZXQuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudCkgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgfSk7XG59XG4vLyBzb3J0IGEgbGlzdCBvZiBlbGVtZW50cyBpbnRvIGFub3RoZXIgbGlzdCBvZiBlbGVtZW50cyBpbiBET00gb3JkZXJcblxuLypcbiAgVVNBR0U6XG4gICAgbWVyZ2VEb21PcmRlcih7XG4gICAgICAvLyBET00gb3JkZXJlZCBhcnJheSBvZiBlbGVtZW50cyB0byB1c2UgYXMgYmFzZSBvZiBtZXJnZVxuICAgICAgbGlzdDogW10sXG4gICAgICAvLyB1bm9yZGVyZWQgYXJyYXkgb2YgZWxlbWVudHMgdG8gbWVyZ2UgaW50byBiYXNlIGxpc3RcbiAgICAgIGVsZW1lbnRzOiBbXSxcbiAgICAgIC8vIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlc29sdmUgYW4gZWxlbWVudFxuICAgICAgcmVzb2x2ZUVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gcmV0dXJuIG51bGwgdG8gc2tpcFxuICAgICAgICAvLyByZXR1cm4gZWxlbWVudCB0byByZXBsYWNlIGluc2VydGlvblxuICAgICAgICAvLyByZXR1cm4gW2VsZW1lbnQxLCBlbGVtZW50Miwg4oCmXSB0byByZXBsYWNlIGluc2VydGlvbiB3aXRoIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgfSxcbiAgICB9KVxuKi9cblxuZnVuY3Rpb24gZmluZEluc2VydGlvbk9mZnNldHMobGlzdCwgZWxlbWVudHMsIHJlc29sdmVFbGVtZW50KSB7XG4gIC8vIGluc3RlYWQgb2YgbXV0YXRpbmcgdGhlIGVsZW1lbnRzIGxpc3QgZGlyZWN0bHksIHJlbWVtYmVyIHBvc2l0aW9uIGFuZCBtYXBcbiAgLy8gdG8gaW5qZWN0IGxhdGVyLCB3aGVuIHdlIGNhbiBkbyB0aGlzIG1vcmUgZWZmaWNpZW50bHlcbiAgdmFyIGluc2VydGlvbnMgPSBbXTtcbiAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciByZXBsYWNlID0gdHJ1ZTtcbiAgICB2YXIgb2Zmc2V0ID0gbGlzdC5pbmRleE9mKGVsZW1lbnQpO1xuXG4gICAgaWYgKG9mZnNldCA9PT0gLTEpIHtcbiAgICAgIC8vIGVsZW1lbnQgaXMgbm90IGluIHRhcmdldCBsaXN0XG4gICAgICBvZmZzZXQgPSBnZXRGaXJzdFN1Y2Nlc3Nvck9mZnNldChsaXN0LCBlbGVtZW50KTtcbiAgICAgIHJlcGxhY2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xuICAgICAgLy8gdGhlcmUgaXMgbm8gc3VjY2Vzc29yIGluIHRoZSB0YWJzZXF1ZW5jZSxcbiAgICAgIC8vIG1lYW5pbmcgdGhlIGltYWdlIG11c3QgYmUgdGhlIGxhc3QgZWxlbWVudFxuICAgICAgb2Zmc2V0ID0gbGlzdC5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgdGhlIGNvbnN1bWVyIHRvIHJlcGxhY2UgdGhlIGluamVjdGVkIGVsZW1lbnRcbiAgICB2YXIgaW5qZWN0aW9ucyA9ICgwLCBfbm9kZUFycmF5Mi5kZWZhdWx0KShyZXNvbHZlRWxlbWVudCA/IHJlc29sdmVFbGVtZW50KGVsZW1lbnQpIDogZWxlbWVudCk7XG4gICAgaWYgKCFpbmplY3Rpb25zLmxlbmd0aCkge1xuICAgICAgLy8gd2UgY2FuJ3QgaW5qZWN0IHplcm8gZWxlbWVudHNcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnNlcnRpb25zLnB1c2goe1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgICAgZWxlbWVudHM6IGluamVjdGlvbnNcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGluc2VydGlvbnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydEVsZW1lbnRzQXRPZmZzZXRzKGxpc3QsIGluc2VydGlvbnMpIHtcbiAgLy8gcmVtZW1iZXIgdGhlIG51bWJlciBvZiBlbGVtZW50cyB3ZSBoYXZlIGFscmVhZHkgaW5qZWN0ZWRcbiAgLy8gc28gd2UgYWNjb3VudCBmb3IgdGhlIGNhdXNlZCBpbmRleCBvZmZzZXRcbiAgdmFyIGluc2VydGVkID0gMDtcbiAgLy8gbWFrZSBzdXJlIHRoYXQgd2UgaW5zZXJ0IHRoZSBlbGVtZW50cyBpbiBzZXF1ZW5jZSxcbiAgLy8gb3RoZXJ3aXNlIHRoZSBvZmZzZXQgY29tcGVuc2F0aW9uIHdvbid0IHdvcmtcbiAgaW5zZXJ0aW9ucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEub2Zmc2V0IC0gYi5vZmZzZXQ7XG4gIH0pO1xuICBpbnNlcnRpb25zLmZvckVhY2goZnVuY3Rpb24gKGluc2VydGlvbikge1xuICAgIC8vIGFycmF5LnNwbGljZSBoYXMgYW4gYW5ub3lpbmcgZnVuY3Rpb24gc2lnbmF0dXJlIDooXG4gICAgdmFyIHJlbW92ZSA9IGluc2VydGlvbi5yZXBsYWNlID8gMSA6IDA7XG4gICAgdmFyIGFyZ3MgPSBbaW5zZXJ0aW9uLm9mZnNldCArIGluc2VydGVkLCByZW1vdmVdLmNvbmNhdChpbnNlcnRpb24uZWxlbWVudHMpO1xuICAgIGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIGFyZ3MpO1xuICAgIGluc2VydGVkICs9IGluc2VydGlvbi5lbGVtZW50cy5sZW5ndGggLSByZW1vdmU7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLWRvbS1vcmRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICBpZiAoIWlucHV0KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgLy8gaW5zdGFuY2VvZiBOb2RlIC0gZG9lcyBub3Qgd29yayB3aXRoIGlmcmFtZXNcbiAgaWYgKGlucHV0Lm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gW2lucHV0XTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgaW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGlucHV0KTtcbiAgfVxuXG4gIGlmIChpbnB1dC5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXS5zbGljZS5jYWxsKGlucHV0LCAwKTtcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuZXhwZWN0ZWQgaW5wdXQgJyArIFN0cmluZyhpbnB1dCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyBpbnB1dCBtYXkgYmUgdW5kZWZpbmVkLCBzZWxlY3Rvci10cmluZywgTm9kZSwgTm9kZUxpc3QsIEhUTUxDb2xsZWN0aW9uLCBhcnJheSBvZiBOb2Rlc1xuLy8geWVzLCB0byBzb21lIGV4dGVudCB0aGlzIGlzIGEgYmFkIHJlcGxpY2Egb2YgalF1ZXJ5J3MgY29uc3RydWN0b3IgZnVuY3Rpb25cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vZGUtYXJyYXkuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BsYXRmb3JtMiA9IHJlcXVpcmUoJ3BsYXRmb3JtJyk7XG5cbnZhciBfcGxhdGZvcm0zID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcGxhdGZvcm0yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLy8gZGVlcCBjbG9uZSBvZiBvcmlnaW5hbCBwbGF0Zm9ybVxudmFyIHBsYXRmb3JtID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShfcGxhdGZvcm0zLmRlZmF1bHQpKTtcblxuLy8gb3BlcmF0aW5nIHN5c3RlbVxuXG4vLyBzdWdhciBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3BsYXRmb3JtLmpzXG4vLyBtYWtlIHN1cmUgdG8gQUxXQVlTIHJlZmVyZW5jZSB0aGUgbGF5b3V0IGVuZ2luZSxcbi8vIGV2ZW4gaWYgaXQgaXMgbm90IG5lY2Vzc2FyeSBmb3IgdGhlIGNvbmRpdGlvbixcbi8vIGFzIHRoaXMgbWFrZXMgZ3JlcHBpbmcgZm9yIHRoaXMgc3R1ZmYgc2ltcGxlclxuXG52YXIgb3MgPSBwbGF0Zm9ybS5vcy5mYW1pbHkgfHwgJyc7XG52YXIgQU5EUk9JRCA9IG9zID09PSAnQW5kcm9pZCc7XG52YXIgV0lORE9XUyA9IG9zLnNsaWNlKDAsIDcpID09PSAnV2luZG93cyc7XG52YXIgT1NYID0gb3MgPT09ICdPUyBYJztcbnZhciBJT1MgPSBvcyA9PT0gJ2lPUyc7XG5cbi8vIGxheW91dFxudmFyIEJMSU5LID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnQmxpbmsnO1xudmFyIEdFQ0tPID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnR2Vja28nO1xudmFyIFRSSURFTlQgPSBwbGF0Zm9ybS5sYXlvdXQgPT09ICdUcmlkZW50JztcbnZhciBFREdFID0gcGxhdGZvcm0ubGF5b3V0ID09PSAnRWRnZUhUTUwnO1xudmFyIFdFQktJVCA9IHBsYXRmb3JtLmxheW91dCA9PT0gJ1dlYktpdCc7XG5cbi8vIGJyb3dzZXIgdmVyc2lvbiAobm90IGxheW91dCBlbmdpbmUgdmVyc2lvbiEpXG52YXIgdmVyc2lvbiA9IHBhcnNlRmxvYXQocGxhdGZvcm0udmVyc2lvbik7XG52YXIgbWFqb3JWZXJzaW9uID0gTWF0aC5mbG9vcih2ZXJzaW9uKTtcbnBsYXRmb3JtLm1ham9yVmVyc2lvbiA9IG1ham9yVmVyc2lvbjtcblxucGxhdGZvcm0uaXMgPSB7XG4gIC8vIG9wZXJhdGluZyBzeXN0ZW1cbiAgQU5EUk9JRDogQU5EUk9JRCxcbiAgV0lORE9XUzogV0lORE9XUyxcbiAgT1NYOiBPU1gsXG4gIElPUzogSU9TLFxuICAvLyBsYXlvdXRcbiAgQkxJTks6IEJMSU5LLCAvLyBcIkNocm9tZVwiLCBcIkNocm9tZSBNb2JpbGVcIiwgXCJPcGVyYVwiXG4gIEdFQ0tPOiBHRUNLTywgLy8gXCJGaXJlZm94XCJcbiAgVFJJREVOVDogVFJJREVOVCwgLy8gXCJJbnRlcm5ldCBFeHBsb3JlclwiXG4gIEVER0U6IEVER0UsIC8vIFwiTWljcm9zb2Z0IEVkZ2VcIlxuICBXRUJLSVQ6IFdFQktJVCwgLy8gXCJTYWZhcmlcIlxuICAvLyBJTlRFUk5FVCBFWFBMT1JFUlNcbiAgSUU5OiBUUklERU5UICYmIG1ham9yVmVyc2lvbiA9PT0gOSxcbiAgSUUxMDogVFJJREVOVCAmJiBtYWpvclZlcnNpb24gPT09IDEwLFxuICBJRTExOiBUUklERU5UICYmIG1ham9yVmVyc2lvbiA9PT0gMTFcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHBsYXRmb3JtO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGF0Zm9ybS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICBpZiAodHlwZW9mIHNoYWRvd1ByZWZpeCAhPT0gJ3N0cmluZycpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSAoMCwgX2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IyLmRlZmF1bHQpKCk7XG4gICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICBzaGFkb3dQcmVmaXggPSAnLCBodG1sICcgKyBvcGVyYXRvciArICcgJztcbiAgICB9XG4gIH1cblxuICBpZiAoIXNoYWRvd1ByZWZpeCkge1xuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3RvciArIHNoYWRvd1ByZWZpeCArIHNlbGVjdG9yLnJlcGxhY2UoL1xccyosXFxzKi9nLCAnLCcpLnNwbGl0KCcsJykuam9pbihzaGFkb3dQcmVmaXgpO1xufTtcblxudmFyIF9jc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yID0gcmVxdWlyZSgnLi4vc3VwcG9ydHMvY3NzLXNoYWRvdy1waWVyY2luZy1kZWVwLWNvbWJpbmF0b3InKTtcblxudmFyIF9jc3NTaGFkb3dQaWVyY2luZ0RlZXBDb21iaW5hdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Nzc1NoYWRvd1BpZXJjaW5nRGVlcENvbWJpbmF0b3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgc2hhZG93UHJlZml4ID0gdm9pZCAwO1xuLy8gY29udmVydCBhIENTUyBzZWxlY3RvciBzbyB0aGF0IGl0IGFsc28gcGllcmNlcyBTaGFkb3dET01cbi8vIHRha2VzIFwiLmEsICNiXCIgYW5kIHR1cm5zIGl0IGludG8gXCIuYSwgI2IsIGh0bWwgPj4+IC5hLCBodG1sID4+PiAjYlwiXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VsZWN0LWluLXNoYWRvd3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICByZXR1cm4gZWxlbWVudHMuc29ydChjb21wYXJlRG9tUG9zaXRpb24pO1xufTtcblxuLy8gc29ydHMgYSBsaXN0IG9mIGVsZW1lbnRzIGFjY29yZGluZyB0byB0aGVpciBvcmRlciBpbiB0aGUgRE9NXG5cbmZ1bmN0aW9uIGNvbXBhcmVEb21Qb3NpdGlvbihhLCBiKSB7XG4gIHJldHVybiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkcgPyAtMSA6IDE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3J0LWRvbS1vcmRlci5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIGlmICghKDAsIF92YWxpZFRhYmluZGV4Mi5kZWZhdWx0KShlbGVtZW50KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gRWRnZSAxNCBoYXMgYSBjYXBpdGFsaXphdGlvbiBwcm9ibGVtIG9uIFNWRyBlbGVtZW50cyxcbiAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzkyODIwNTgvXG4gIHZhciBoYXNUYWJpbmRleCA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICB2YXIgYXR0cmlidXRlTmFtZSA9IGhhc1RhYmluZGV4ID8gJ3RhYmluZGV4JyA6ICd0YWJJbmRleCc7XG5cbiAgLy8gQGJyb3dzZXItaXNzdWUgR2Vja28gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTEyODA1NFxuICB2YXIgdGFiaW5kZXggPSBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSwgMTApO1xuICByZXR1cm4gaXNOYU4odGFiaW5kZXgpID8gLTEgOiB0YWJpbmRleDtcbn07XG5cbnZhciBfdmFsaWRUYWJpbmRleCA9IHJlcXVpcmUoJy4uL2lzL3ZhbGlkLXRhYmluZGV4Jyk7XG5cbnZhciBfdmFsaWRUYWJpbmRleDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92YWxpZFRhYmluZGV4KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWJpbmRleC12YWx1ZS5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgYXR0cmlidXRlID0gX3JlZi5hdHRyaWJ1dGUsXG4gICAgICB0ZW1wb3JhcnlWYWx1ZSA9IF9yZWYudGVtcG9yYXJ5VmFsdWUsXG4gICAgICBzYXZlVmFsdWUgPSBfcmVmLnNhdmVWYWx1ZTtcblxuICB2YXIgdGVtcG9yYXJ5QXR0cmlidXRlID0gJ2RhdGEtY2FjaGVkLScgKyBhdHRyaWJ1dGU7XG5cbiAgaWYgKHRlbXBvcmFyeVZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX3ZhbHVlID0gc2F2ZVZhbHVlIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUodGVtcG9yYXJ5QXR0cmlidXRlLCBfdmFsdWUgfHwgJycpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdGVtcG9yYXJ5VmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfdmFsdWUyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUodGVtcG9yYXJ5QXR0cmlidXRlKTtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUpO1xuICAgIGlmIChfdmFsdWUyID09PSAnJykge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBfdmFsdWUyKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8gaGVscGVyIHRvIHR1cm5cbi8vICA8ZGl2IHNvbWUtYXR0cmlidXRlPVwib3JpZ2luYWxcIj5cbi8vIGludG9cbi8vICA8ZGl2IHNvbWUtYXR0cmlidXRlPVwibmV3XCIgZGF0YS1jYWNoZWQtc29tZS1hdHRyaWJ1dGU9XCJvcmlnaW5hbFwiPlxuLy8gYW5kIGJhY2tcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvZ2dsZS1hdHRyaWJ1dGUtdmFsdWUuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgIGF0dHJpYnV0ZSA9IF9yZWYuYXR0cmlidXRlO1xuXG4gIHZhciB0ZW1wb3JhcnlBdHRyaWJ1dGUgPSAnZGF0YS1jYWNoZWQtJyArIGF0dHJpYnV0ZTtcbiAgdmFyIHRlbXBvcmFyeUF0dHJpYnV0ZVZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUodGVtcG9yYXJ5QXR0cmlidXRlKTtcblxuICBpZiAodGVtcG9yYXJ5QXR0cmlidXRlVmFsdWUgPT09IG51bGwpIHtcbiAgICB2YXIgX3ZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICBpZiAoX3ZhbHVlID09PSBudWxsKSB7XG4gICAgICAvLyBjYW4ndCByZW1vdmUgd2hhdCdzIG5vdCB0aGVyZVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHRlbXBvcmFyeUF0dHJpYnV0ZSwgX3ZhbHVlIHx8ICcnKTtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfdmFsdWUyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUodGVtcG9yYXJ5QXR0cmlidXRlKTtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSh0ZW1wb3JhcnlBdHRyaWJ1dGUpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgX3ZhbHVlMik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8gaGVscGVyIHRvIHR1cm5cbi8vICA8ZGl2IHNvbWUtYXR0cmlidXRlPVwib3JpZ2luYWxcIj5cbi8vIGludG9cbi8vICA8ZGl2IGRhdGEtY2FjaGVkLXNvbWUtYXR0cmlidXRlPVwib3JpZ2luYWxcIj5cbi8vIGFuZCBiYWNrXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2dnbGUtYXR0cmlidXRlLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLy8gdGhpcyBmaWxlIGlzIG92ZXJ3cml0dGVuIGJ5IGBucG0gcnVuIGJ1aWxkOnByZWBcbnZhciB2ZXJzaW9uID0gJzEuNC4xJztcbmV4cG9ydHMuZGVmYXVsdCA9IHZlcnNpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICByZXR1cm4gdGV4dC5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbiAoX3RleHQpIHtcbiAgICB2YXIgdG9rZW5zID0gX3RleHQuc3BsaXQoJysnKTtcbiAgICB2YXIgX21vZGlmaWVycyA9IHJlc29sdmVNb2RpZmllcnModG9rZW5zLnNsaWNlKDAsIC0xKSk7XG4gICAgdmFyIF9rZXlDb2RlcyA9IHJlc29sdmVLZXkodG9rZW5zLnNsaWNlKC0xKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleUNvZGVzOiBfa2V5Q29kZXMsXG4gICAgICBtb2RpZmllcnM6IF9tb2RpZmllcnMsXG4gICAgICBtYXRjaE1vZGlmaWVyczogbWF0Y2hNb2RpZmllcnMuYmluZChudWxsLCBfbW9kaWZpZXJzKVxuICAgIH07XG4gIH0pO1xufTtcblxudmFyIF9rZXljb2RlID0gcmVxdWlyZSgnLi4vbWFwL2tleWNvZGUnKTtcblxudmFyIF9rZXljb2RlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2tleWNvZGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbW9kaWZpZXIgPSB7XG4gIGFsdDogJ2FsdEtleScsXG4gIGN0cmw6ICdjdHJsS2V5JyxcbiAgbWV0YTogJ21ldGFLZXknLFxuICBzaGlmdDogJ3NoaWZ0S2V5J1xufTtcbi8qXG4gIGRlY29kZXMgYSBrZXkgYmluZGluZyB0b2tlbiB0byBhIEphdmFTY3JpcHQgc3RydWN0dXJlXG5cbiAgcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzOlxuICAgIHtcbiAgICAgIC8vIGtleSBuYW1lIHRyYW5zbGF0ZWQgdG8ga2V5Q29kZSAocG9zc2libHkgbW9yZSB0aGFuIG9uZSlcbiAgICAgIGtleUNvZGVzOiBbPG51bWJlcj5dLFxuICAgICAgLy8gdHJhbnNsYXRlZCBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVyczoge1xuICAgICAgICBhbHRLZXk6IG51bGwsICAgLy8gaWdub3JlXG4gICAgICAgIGN0cktleTogZmFsc2UsICAvLyBleHBlY3Qgbm90IHByZXNzZWRcbiAgICAgICAgbWV0YUtleTogdHJ1ZSwgIC8vIGV4cGVjdCBwcmVzc2VkXG4gICAgICAgIHNoaWZ0S2V5OiB0cnVlLCAvLyBleHBlY3QgcHJlc3NlZFxuICAgICAgfSxcbiAgICAgIC8vIGNhbGxiYWNrIHRoYXQgcmV0dXJucyB0cnVlIGlmIGV2ZW50J3NcbiAgICAgIC8vIG1vZGlmaWVyIGtleXMgbWF0Y2ggdGhlIGV4cGVjdGVkIHN0YXRlXG4gICAgICBtYXRjaE1vZGlmaWVyczogZnVuY3Rpb24oZXZlbnQpe30sXG4gICAgfVxuKi9cblxudmFyIG1vZGlmaWVyU2VxdWVuY2UgPSBPYmplY3Qua2V5cyhtb2RpZmllcikubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBtb2RpZmllcltuYW1lXTtcbn0pO1xuXG5mdW5jdGlvbiBjcmVhdGVFeHBlY3RlZE1vZGlmaWVycyhpZ25vcmVNb2RpZmllcnMpIHtcbiAgdmFyIHZhbHVlID0gaWdub3JlTW9kaWZpZXJzID8gbnVsbCA6IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIGFsdEtleTogdmFsdWUsXG4gICAgY3RybEtleTogdmFsdWUsXG4gICAgbWV0YUtleTogdmFsdWUsXG4gICAgc2hpZnRLZXk6IHZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIHZhciBpZ25vcmVNb2RpZmllcnMgPSBtb2RpZmllcnMuaW5kZXhPZignKicpICE9PSAtMTtcbiAgdmFyIGV4cGVjdGVkID0gY3JlYXRlRXhwZWN0ZWRNb2RpZmllcnMoaWdub3JlTW9kaWZpZXJzKTtcblxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBpZiAodG9rZW4gPT09ICcqJykge1xuICAgICAgLy8gd2UndmUgYWxyZWFkeSBjb3ZlcmVkIHRoZSBhbGwtaW4gb3BlcmF0b3JcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB3ZSB3YW50IHRoZSBtb2RpZmllciBwcmVzc2VkXG4gICAgdmFyIHZhbHVlID0gdHJ1ZTtcbiAgICB2YXIgb3BlcmF0b3IgPSB0b2tlbi5zbGljZSgwLCAxKTtcbiAgICBpZiAob3BlcmF0b3IgPT09ICc/Jykge1xuICAgICAgLy8gd2UgZG9uJ3QgY2FyZSBpZiB0aGUgbW9kaWZpZXIgaXMgcHJlc3NlZFxuICAgICAgdmFsdWUgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICchJykge1xuICAgICAgLy8gd2UgZG8gbm90IHdhbnQgdGhlIG1vZGlmaWVyIHByZXNzZWRcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAvLyBjb21wZW5zYXRlIGZvciB0aGUgbW9kaWZpZXIncyBvcGVyYXRvclxuICAgICAgdG9rZW4gPSB0b2tlbi5zbGljZSgxKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlOYW1lID0gbW9kaWZpZXJbdG9rZW5dO1xuICAgIGlmICghcHJvcGVydHlOYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIG1vZGlmaWVyIFwiJyArIHRva2VuICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgZXhwZWN0ZWRbcHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICB9KTtcblxuICByZXR1cm4gZXhwZWN0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVLZXkoa2V5KSB7XG4gIHZhciBjb2RlID0gX2tleWNvZGUyLmRlZmF1bHRba2V5XSB8fCBwYXJzZUludChrZXksIDEwKTtcbiAgaWYgKCFjb2RlIHx8IHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJyB8fCBpc05hTihjb2RlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24ga2V5IFwiJyArIGtleSArICdcIicpO1xuICB9XG5cbiAgcmV0dXJuIFtjb2RlXS5jb25jYXQoX2tleWNvZGUyLmRlZmF1bHQuX2FsaWFzW2NvZGVdIHx8IFtdKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hNb2RpZmllcnMoZXhwZWN0ZWQsIGV2ZW50KSB7XG4gIC8vIHJldHVybnMgdHJ1ZSBvbiBtYXRjaFxuICByZXR1cm4gIW1vZGlmaWVyU2VxdWVuY2Uuc29tZShmdW5jdGlvbiAocHJvcCkge1xuICAgIC8vIHJldHVybnMgdHJ1ZSBvbiBtaXNtYXRjaFxuICAgIHJldHVybiB0eXBlb2YgZXhwZWN0ZWRbcHJvcF0gPT09ICdib29sZWFuJyAmJiBCb29sZWFuKGV2ZW50W3Byb3BdKSAhPT0gZXhwZWN0ZWRbcHJvcF07XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleS5iaW5kaW5nLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbWFwID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgYmluZGluZ3MgPSB7fTtcblxuICB2YXIgY29udGV4dCA9ICgwLCBfbm9kZUFycmF5Mi5kZWZhdWx0KShtYXAuY29udGV4dClbMF0gfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBkZWxldGUgbWFwLmNvbnRleHQ7XG4gIHZhciBmaWx0ZXIgPSAoMCwgX25vZGVBcnJheTIuZGVmYXVsdCkobWFwLmZpbHRlcik7XG4gIGRlbGV0ZSBtYXAuZmlsdGVyO1xuXG4gIHZhciBtYXBLZXlzID0gT2JqZWN0LmtleXMobWFwKTtcbiAgaWYgKCFtYXBLZXlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3doZW4va2V5IHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBvcHRpb24ga2V5Jyk7XG4gIH1cblxuICB2YXIgcmVnaXN0ZXJCaW5kaW5nID0gZnVuY3Rpb24gcmVnaXN0ZXJCaW5kaW5nKGV2ZW50KSB7XG4gICAgZXZlbnQua2V5Q29kZXMuZm9yRWFjaChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgaWYgKCFiaW5kaW5nc1tjb2RlXSkge1xuICAgICAgICBiaW5kaW5nc1tjb2RlXSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBiaW5kaW5nc1tjb2RlXS5wdXNoKGV2ZW50KTtcbiAgICB9KTtcbiAgfTtcblxuICBtYXBLZXlzLmZvckVhY2goZnVuY3Rpb24gKHRleHQpIHtcbiAgICBpZiAodHlwZW9mIG1hcFt0ZXh0XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd2hlbi9rZXkgcmVxdWlyZXMgb3B0aW9uW1wiJyArIHRleHQgKyAnXCJdIHRvIGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICB2YXIgYWRkQ2FsbGJhY2sgPSBmdW5jdGlvbiBhZGRDYWxsYmFjayhldmVudCkge1xuICAgICAgZXZlbnQuY2FsbGJhY2sgPSBtYXBbdGV4dF07XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfTtcblxuICAgICgwLCBfa2V5Mi5kZWZhdWx0KSh0ZXh0KS5tYXAoYWRkQ2FsbGJhY2spLmZvckVhY2gocmVnaXN0ZXJCaW5kaW5nKTtcbiAgfSk7XG5cbiAgdmFyIGhhbmRsZUtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZmlsdGVyLmxlbmd0aCkge1xuICAgICAgLy8gaWdub3JlIGVsZW1lbnRzIHdpdGhpbiB0aGUgZXhlbXB0ZWQgc3ViLXRyZWVzXG4gICAgICB2YXIgaXNQYXJlbnRPZkVsZW1lbnQgPSAoMCwgX2NvbXBhcmVQb3NpdGlvbi5nZXRQYXJlbnRDb21wYXJhdG9yKSh7IGVsZW1lbnQ6IGV2ZW50LnRhcmdldCwgaW5jbHVkZVNlbGY6IHRydWUgfSk7XG4gICAgICBpZiAoZmlsdGVyLnNvbWUoaXNQYXJlbnRPZkVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5ID0gZXZlbnQua2V5Q29kZSB8fCBldmVudC53aGljaDtcbiAgICBpZiAoIWJpbmRpbmdzW2tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBiaW5kaW5nc1trZXldLmZvckVhY2goZnVuY3Rpb24gKF9ldmVudCkge1xuICAgICAgaWYgKCFfZXZlbnQubWF0Y2hNb2RpZmllcnMoZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX2V2ZW50LmNhbGxiYWNrLmNhbGwoY29udGV4dCwgZXZlbnQsIGRpc2VuZ2FnZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgY29udGV4dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93biwgZmFsc2UpO1xuXG4gIHZhciBkaXNlbmdhZ2UgPSBmdW5jdGlvbiBkaXNlbmdhZ2UoKSB7XG4gICAgY29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93biwgZmFsc2UpO1xuICB9O1xuXG4gIHJldHVybiB7IGRpc2VuZ2FnZTogZGlzZW5nYWdlIH07XG59O1xuXG52YXIgX2tleSA9IHJlcXVpcmUoJy4va2V5LmJpbmRpbmcnKTtcblxudmFyIF9rZXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfa2V5KTtcblxudmFyIF9ub2RlQXJyYXkgPSByZXF1aXJlKCcuLi91dGlsL25vZGUtYXJyYXknKTtcblxudmFyIF9ub2RlQXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbm9kZUFycmF5KTtcblxudmFyIF9jb21wYXJlUG9zaXRpb24gPSByZXF1aXJlKCcuLi91dGlsL2NvbXBhcmUtcG9zaXRpb24nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8vIEJ1ZyAyODY5MzMgLSBLZXkgZXZlbnRzIGluIHRoZSBhdXRvY29tcGxldGUgcG9wdXAgc2hvdWxkIGJlIGhpZGRlbiBmcm9tIHBhZ2Ugc2NyaXB0c1xuLy8gQGJyb3dzZXItaXNzdWUgR2Vja28gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Mjg2OTMzXG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoaXMgZmlsZSB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGJ5IEBkcnVkcnUgKGh0dHBzOi8vZ2l0aHViLmNvbS9kcnVkcnUvYW5zaV91cCksIE1JVCwgMjAxMVxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQU5TSV9DT0xPUlMgPSBbW3sgY29sb3I6IFwiMCwgMCwgMFwiLCBcImNsYXNzXCI6IFwiYW5zaS1ibGFja1wiIH0sIHsgY29sb3I6IFwiMTg3LCAwLCAwXCIsIFwiY2xhc3NcIjogXCJhbnNpLXJlZFwiIH0sIHsgY29sb3I6IFwiMCwgMTg3LCAwXCIsIFwiY2xhc3NcIjogXCJhbnNpLWdyZWVuXCIgfSwgeyBjb2xvcjogXCIxODcsIDE4NywgMFwiLCBcImNsYXNzXCI6IFwiYW5zaS15ZWxsb3dcIiB9LCB7IGNvbG9yOiBcIjAsIDAsIDE4N1wiLCBcImNsYXNzXCI6IFwiYW5zaS1ibHVlXCIgfSwgeyBjb2xvcjogXCIxODcsIDAsIDE4N1wiLCBcImNsYXNzXCI6IFwiYW5zaS1tYWdlbnRhXCIgfSwgeyBjb2xvcjogXCIwLCAxODcsIDE4N1wiLCBcImNsYXNzXCI6IFwiYW5zaS1jeWFuXCIgfSwgeyBjb2xvcjogXCIyNTUsMjU1LDI1NVwiLCBcImNsYXNzXCI6IFwiYW5zaS13aGl0ZVwiIH1dLCBbeyBjb2xvcjogXCI4NSwgODUsIDg1XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1ibGFja1wiIH0sIHsgY29sb3I6IFwiMjU1LCA4NSwgODVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LXJlZFwiIH0sIHsgY29sb3I6IFwiMCwgMjU1LCAwXCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1ncmVlblwiIH0sIHsgY29sb3I6IFwiMjU1LCAyNTUsIDg1XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC15ZWxsb3dcIiB9LCB7IGNvbG9yOiBcIjg1LCA4NSwgMjU1XCIsIFwiY2xhc3NcIjogXCJhbnNpLWJyaWdodC1ibHVlXCIgfSwgeyBjb2xvcjogXCIyNTUsIDg1LCAyNTVcIiwgXCJjbGFzc1wiOiBcImFuc2ktYnJpZ2h0LW1hZ2VudGFcIiB9LCB7IGNvbG9yOiBcIjg1LCAyNTUsIDI1NVwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQtY3lhblwiIH0sIHsgY29sb3I6IFwiMjU1LCAyNTUsIDI1NVwiLCBcImNsYXNzXCI6IFwiYW5zaS1icmlnaHQtd2hpdGVcIiB9XV07XG5cbnZhciBBbnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBfY3JlYXRlQ2xhc3MoQW5zZXIsIG51bGwsIFt7XG4gICAgICAgIGtleTogXCJlc2NhcGVGb3JIdG1sXCIsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQW5zZXIuZXNjYXBlRm9ySHRtbFxuICAgICAgICAgKiBFc2NhcGUgdGhlIGlucHV0IEhUTUwuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZG9lcyB0aGUgbWluaW11bSBlc2NhcGluZyBvZiB0ZXh0IHRvIG1ha2UgaXQgY29tcGxpYW50IHdpdGggSFRNTC5cbiAgICAgICAgICogSW4gcGFydGljdWxhciwgdGhlICcmJywnPCcsIGFuZCAnPicgY2hhcmFjdGVycyBhcmUgZXNjYXBlZC4gVGhpcyBzaG91bGRcbiAgICAgICAgICogYmUgcnVuIHByaW9yIHRvIGBhbnNpVG9IdG1sYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgQW5zZXIuZXNjYXBlRm9ySHRtbFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dCAoY29udGFpbmluZyB0aGUgQU5TSSBzbmlwcGV0cykuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBlc2NhcGVkIGh0bWwuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXNjYXBlRm9ySHRtbCh0eHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5zZXIoKS5lc2NhcGVGb3JIdG1sKHR4dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQW5zZXIubGlua2lmeVxuICAgICAgICAgKiBBZGRzIHRoZSBsaW5rcyBpbiB0aGUgSFRNTC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyByZXBsYWNlcyBhbnkgbGlua3MgaW4gdGhlIHRleHQgd2l0aCBhbmNob3IgdGFncyB0aGF0IGRpc3BsYXkgdGhlXG4gICAgICAgICAqIGxpbmsuIFRoZSBsaW5rcyBzaG91bGQgaGF2ZSBhdCBsZWFzdCBvbmUgd2hpdGVzcGFjZSBjaGFyYWN0ZXJcbiAgICAgICAgICogc3Vycm91bmRpbmcgaXQuIEFsc28sIHlvdSBzaG91bGQgYXBwbHkgdGhpcyBhZnRlciB5b3UgaGF2ZSBydW5cbiAgICAgICAgICogYGFuc2lUb0h0bWxgIG9uIHRoZSB0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBBbnNlci5saW5raWZ5XG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBjb250YWluaW5nIHRoZSA8YT4gdGFncyAodW5lc2NhcGVkKS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJsaW5raWZ5XCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsaW5raWZ5KHR4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbnNlcigpLmxpbmtpZnkodHh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnNlci5hbnNpVG9IdG1sXG4gICAgICAgICAqIFRoaXMgcmVwbGFjZXMgQU5TSSB0ZXJtaW5hbCBlc2NhcGUgY29kZXMgd2l0aCBTUEFOIHRhZ3MgdGhhdCB3cmFwIHRoZVxuICAgICAgICAgKiBjb250ZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIG9ubHkgaW50ZXJwcmV0cyBBTlNJIFNHUiAoU2VsZWN0IEdyYXBoaWMgUmVuZGl0aW9uKSBjb2Rlc1xuICAgICAgICAgKiB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBpbiBIVE1MLlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgY3Vyc29yIG1vdmVtZW50IGNvZGVzIGFyZSBpZ25vcmVkIGFuZCBoaWRkZW4gZnJvbSBvdXRwdXQuXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHN0eWxlIHVzZXMgY29sb3JzIHRoYXQgYXJlIHZlcnkgY2xvc2UgdG8gdGhlIHByZXNjcmliZWRcbiAgICAgICAgICogc3RhbmRhcmQuIFRoZSBzdGFuZGFyZCBhc3N1bWVzIHRoYXQgdGhlIHRleHQgd2lsbCBoYXZlIGEgYmxhY2tcbiAgICAgICAgICogYmFja2dyb3VuZC4gVGhlc2UgY29sb3JzIGFyZSBzZXQgYXMgaW5saW5lIHN0eWxlcyBvbiB0aGUgU1BBTiB0YWdzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBbm90aGVyIG9wdGlvbiBpcyB0byBzZXQgYHVzZV9jbGFzc2VzOiB0cnVlYCBpbiB0aGUgb3B0aW9ucyBhcmd1bWVudC5cbiAgICAgICAgICogVGhpcyB3aWxsIGluc3RlYWQgc2V0IGNsYXNzZXMgb24gdGhlIHNwYW5zIHNvIHRoZSBjb2xvcnMgY2FuIGJlIHNldCB2aWFcbiAgICAgICAgICogQ1NTLiBUaGUgY2xhc3MgbmFtZXMgdXNlZCBhcmUgb2YgdGhlIGZvcm1hdCBgYW5zaS0qLWZnL2JnYCBhbmRcbiAgICAgICAgICogYGFuc2ktYnJpZ2h0LSotZmcvYmdgIHdoZXJlIGAqYCBpcyB0aGUgY29sb3IgbmFtZSxcbiAgICAgICAgICogaS5lIGJsYWNrL3JlZC9ncmVlbi95ZWxsb3cvYmx1ZS9tYWdlbnRhL2N5YW4vd2hpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIEFuc2VyLmFuc2lUb0h0bWxcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgYW5zaVRvSFRNTCBtZXRob2QuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBIVE1MIG91dHB1dC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhbnNpVG9IdG1sXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbnNpVG9IdG1sKHR4dCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbnNlcigpLmFuc2lUb0h0bWwodHh0LCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnNlci5hbnNpVG9Kc29uXG4gICAgICAgICAqIENvbnZlcnRzIEFOU0kgaW5wdXQgaW50byBKU09OIG91dHB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgQW5zZXIuYW5zaVRvSnNvblxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBhbnNpVG9IVE1MIG1ldGhvZC5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEhUTUwgb3V0cHV0LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFuc2lUb0pzb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuc2lUb0pzb24odHh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFuc2VyKCkuYW5zaVRvSnNvbih0eHQsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuc2VyLmFuc2lUb1RleHRcbiAgICAgICAgICogQ29udmVydHMgQU5TSSBpbnB1dCBpbnRvIHRleHQgb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBBbnNlci5hbnNpVG9UZXh0XG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdGV4dCBvdXRwdXQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYW5zaVRvVGV4dFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5zaVRvVGV4dCh0eHQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW5zZXIoKS5hbnNpVG9UZXh0KHR4dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQW5zZXJcbiAgICAgICAgICogVGhlIGBBbnNlcmAgY2xhc3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIEFuc2VyXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7QW5zZXJ9XG4gICAgICAgICAqL1xuXG4gICAgfV0pO1xuXG4gICAgZnVuY3Rpb24gQW5zZXIoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbnNlcik7XG5cbiAgICAgICAgdGhpcy5mZyA9IHRoaXMuYmcgPSB0aGlzLmZnX3RydWVjb2xvciA9IHRoaXMuYmdfdHJ1ZWNvbG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5icmlnaHQgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldHVwUGFsZXR0ZVxuICAgICAqIFNldHMgdXAgdGhlIHBhbGV0dGUuXG4gICAgICpcbiAgICAgKiBAbmFtZSBzZXR1cFBhbGV0dGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKEFuc2VyLCBbe1xuICAgICAgICBrZXk6IFwic2V0dXBQYWxldHRlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFBhbGV0dGUoKSB7XG4gICAgICAgICAgICB0aGlzLlBBTEVUVEVfQ09MT1JTID0gW107XG5cbiAgICAgICAgICAgIC8vIEluZGV4IDAuLjE1IDogU3lzdGVtIGNvbG9yXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuUEFMRVRURV9DT0xPUlMucHVzaChBTlNJX0NPTE9SU1tpXVtqXS5jb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbmRleCAxNi4uMjMxIDogUkdCIDZ4Nng2XG4gICAgICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9qYXNvbm0yMy8yODY4OTgxI2ZpbGUteHRlcm0tMjU2Y29sb3IteWFtbFxuICAgICAgICAgICAgdmFyIGxldmVscyA9IFswLCA5NSwgMTM1LCAxNzUsIDIxNSwgMjU1XTtcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSBmdW5jdGlvbiBmb3JtYXQociwgZywgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZXZlbHNbcl0gKyBcIiwgXCIgKyBsZXZlbHNbZ10gKyBcIiwgXCIgKyBsZXZlbHNbYl07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHIgPSB2b2lkIDAsXG4gICAgICAgICAgICAgICAgZyA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBiID0gdm9pZCAwO1xuICAgICAgICAgICAgZm9yICh2YXIgX3IgPSAwOyBfciA8IDY7ICsrX3IpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZyA9IDA7IF9nIDwgNjsgKytfZykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IDA7IF9iIDwgNjsgKytfYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5QQUxFVFRFX0NPTE9SUy5wdXNoKGZvcm1hdChfciwgX2csIF9iKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluZGV4IDIzMi4uMjU1IDogR3JheXNjYWxlXG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSA4O1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDI0OyArK19pLCBsZXZlbCArPSAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuUEFMRVRURV9DT0xPUlMucHVzaChmb3JtYXQobGV2ZWwsIGxldmVsLCBsZXZlbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGVzY2FwZUZvckh0bWxcbiAgICAgICAgICogRXNjYXBlcyB0aGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgZXNjYXBlRm9ySHRtbFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGVzY3BhZWQgSFRNTCBvdXRwdXQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZXNjYXBlRm9ySHRtbFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXNjYXBlRm9ySHRtbCh0eHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0eHQucmVwbGFjZSgvWyY8Pl0vZ20sIGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyID09IFwiJlwiID8gXCImYW1wO1wiIDogc3RyID09IFwiPFwiID8gXCImbHQ7XCIgOiBzdHIgPT0gXCI+XCIgPyBcIiZndDtcIiA6IFwiXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsaW5raWZ5XG4gICAgICAgICAqIEFkZHMgSFRNTCBsaW5rIGVsZW1lbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBsaW5raWZ5XG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgSFRNTCBvdXRwdXQgY29udGFpbmluZyBsaW5rIGVsZW1lbnRzLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImxpbmtpZnlcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxpbmtpZnkodHh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHh0LnJlcGxhY2UoLyhodHRwcz86XFwvXFwvW15cXHNdKykvZ20sIGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8YSBocmVmPVxcXCJcIiArIHN0ciArIFwiXFxcIj5cIiArIHN0ciArIFwiPC9hPlwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogYW5zaVRvSHRtbFxuICAgICAgICAgKiBDb252ZXJ0cyBBTlNJIGlucHV0IGludG8gSFRNTCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIGFuc2lUb0h0bWxcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCBvdCB0aGUgYHByb2Nlc3NgIG1ldGhvZC5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEhUTUwgb3V0cHV0LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFuc2lUb0h0bWxcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuc2lUb0h0bWwodHh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzKHR4dCwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogYW5zaVRvSnNvblxuICAgICAgICAgKiBDb252ZXJ0cyBBTlNJIGlucHV0IGludG8gSFRNTCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIGFuc2lUb0pzb25cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eHQgVGhlIGlucHV0IHRleHQuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIHBhc3NlZCBvdCB0aGUgYHByb2Nlc3NgIG1ldGhvZC5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIEpTT04gb3V0cHV0LlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFuc2lUb0pzb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuc2lUb0pzb24odHh0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIG9wdGlvbnMuanNvbiA9IHRydWU7XG4gICAgICAgICAgICBvcHRpb25zLmNsZWFyTGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzcyh0eHQsIG9wdGlvbnMsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFuc2lUb1RleHRcbiAgICAgICAgICogQ29udmVydHMgQU5TSSBpbnB1dCBpbnRvIEhUTUwgb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBhbnNpVG9UZXh0XG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgdGV4dCBvdXRwdXQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYW5zaVRvVGV4dFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5zaVRvVGV4dCh0eHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3ModHh0LCB7fSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByb2Nlc3NcbiAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBpbnB1dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG5hbWUgcHJvY2Vzc1xuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHR4dCBUaGUgaW5wdXQgdGV4dC5cbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IHBhc3NlZCB0byBgcHJvY2Vzc0NodW5rYCBtZXRob2QsIGV4dGVuZGVkIHdpdGg6XG4gICAgICAgICAqXG4gICAgICAgICAqICAtIGBqc29uYCAoQm9vbGVhbik6IElmIGB0cnVlYCwgdGhlIHJlc3VsdCB3aWxsIGJlIGFuIG9iamVjdC5cbiAgICAgICAgICogIC0gYHVzZV9jbGFzc2VzYCAoQm9vbGVhbik6IElmIGB0cnVlYCwgSFRNTCBjbGFzc2VzIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIEhUTUwgb3V0cHV0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IG1hcmt1cFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInByb2Nlc3NcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3ModHh0LCBvcHRpb25zLCBtYXJrdXApIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciByYXdfdGV4dF9jaHVua3MgPSB0eHQuc3BsaXQoL1xcMDMzXFxbLyk7XG4gICAgICAgICAgICB2YXIgZmlyc3RfY2h1bmsgPSByYXdfdGV4dF9jaHVua3Muc2hpZnQoKTsgLy8gdGhlIGZpcnN0IGNodW5rIGlzIG5vdCB0aGUgcmVzdWx0IG9mIHRoZSBzcGxpdFxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLmNsZWFyTGluZSA9IC9cXHIvLnRlc3QodHh0KTsgLy8gY2hlY2sgZm9yIENhcnJpYWdlIFJldHVyblxuICAgICAgICAgICAgdmFyIGNvbG9yX2NodW5rcyA9IHJhd190ZXh0X2NodW5rcy5tYXAoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb2Nlc3NDaHVuayhjaHVuaywgb3B0aW9ucywgbWFya3VwKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmpzb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBzZWxmLnByb2Nlc3NDaHVua0pzb24oXCJcIik7XG4gICAgICAgICAgICAgICAgZmlyc3QuY29udGVudCA9IGZpcnN0X2NodW5rO1xuICAgICAgICAgICAgICAgIGZpcnN0LmNsZWFyTGluZSA9IG9wdGlvbnMuY2xlYXJMaW5lO1xuICAgICAgICAgICAgICAgIGNvbG9yX2NodW5rcy51bnNoaWZ0KGZpcnN0KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZW1vdmVfZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JfY2h1bmtzID0gY29sb3JfY2h1bmtzLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFjLmlzRW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcl9jaHVua3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG9yX2NodW5rcy51bnNoaWZ0KGZpcnN0X2NodW5rKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yX2NodW5rcy5qb2luKFwiXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByb2Nlc3NDaHVua0pzb25cbiAgICAgICAgICogUHJvY2Vzc2VzIHRoZSBjdXJyZW50IGNodW5rIGludG8ganNvbiBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBuYW1lIHByb2Nlc3NDaHVua0pzb25cbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgICAgICpcbiAgICAgICAgICogIC0gYGpzb25gIChCb29sZWFuKTogSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgYW4gb2JqZWN0LlxuICAgICAgICAgKiAgLSBgdXNlX2NsYXNzZXNgIChCb29sZWFuKTogSWYgYHRydWVgLCBIVE1MIGNsYXNzZXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgSFRNTCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFya3VwIElmIGZhbHNlLCB0aGUgY29sb3JzIHdpbGwgbm90IGJlIHBhcnNlZC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0IG9iamVjdDpcbiAgICAgICAgICpcbiAgICAgICAgICogIC0gYGNvbnRlbnRgIChTdHJpbmcpOiBUaGUgdGV4dC5cbiAgICAgICAgICogIC0gYGZnYCAoU3RyaW5nfG51bGwpOiBUaGUgZm9yZWdyb3VuZCBjb2xvci5cbiAgICAgICAgICogIC0gYGJnYCAoU3RyaW5nfG51bGwpOiBUaGUgYmFja2dyb3VuZCBjb2xvci5cbiAgICAgICAgICogIC0gYGZnX3RydWVjb2xvcmAgKFN0cmluZ3xudWxsKTogVGhlIGZvcmVncm91bmQgdHJ1ZSBjb2xvciAoaWYgMTZtIGNvbG9yIGlzIGVuYWJsZWQpLlxuICAgICAgICAgKiAgLSBgYmdfdHJ1ZWNvbG9yYCAoU3RyaW5nfG51bGwpOiBUaGUgYmFja2dyb3VuZCB0cnVlIGNvbG9yIChpZiAxNm0gY29sb3IgaXMgZW5hYmxlZCkuXG4gICAgICAgICAqICAtIGBjbGVhckxpbmVgIChCb29sZWFuKTogYHRydWVgIGlmIGEgY2FycmlhZ2VSZXR1cm4gXFxyIHdhcyBmb3VudCBhdCBlbmQgb2YgbGluZS5cbiAgICAgICAgICogIC0gYHdhc19wcm9jZXNzZWRgIChCb2xlYW4pOiBgdHJ1ZWAgaWYgdGhlIGNvbG9ycyB3ZXJlIHByb2Nlc3NlZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICAgICAqICAtIGBpc0VtcHR5YCAoRnVuY3Rpb24pOiBBIGZ1bmN0aW9uIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGNvbnRlbnQgaXMgZW1wdHksIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInByb2Nlc3NDaHVua0pzb25cIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NDaHVua0pzb24odGV4dCwgb3B0aW9ucywgbWFya3VwKSB7XG5cbiAgICAgICAgICAgIC8vIEFyZSB3ZSB1c2luZyBjbGFzc2VzIG9yIHN0eWxlcz9cbiAgICAgICAgICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyA9PSBcInVuZGVmaW5lZFwiID8ge30gOiBvcHRpb25zO1xuICAgICAgICAgICAgdmFyIHVzZV9jbGFzc2VzID0gb3B0aW9ucy51c2VfY2xhc3NlcyA9IHR5cGVvZiBvcHRpb25zLnVzZV9jbGFzc2VzICE9IFwidW5kZWZpbmVkXCIgJiYgb3B0aW9ucy51c2VfY2xhc3NlcztcbiAgICAgICAgICAgIHZhciBrZXkgPSBvcHRpb25zLmtleSA9IHVzZV9jbGFzc2VzID8gXCJjbGFzc1wiIDogXCJjb2xvclwiO1xuXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRleHQsXG4gICAgICAgICAgICAgICAgZmc6IG51bGwsXG4gICAgICAgICAgICAgICAgYmc6IG51bGwsXG4gICAgICAgICAgICAgICAgZmdfdHJ1ZWNvbG9yOiBudWxsLFxuICAgICAgICAgICAgICAgIGJnX3RydWVjb2xvcjogbnVsbCxcbiAgICAgICAgICAgICAgICBjbGVhckxpbmU6IG9wdGlvbnMuY2xlYXJMaW5lLFxuICAgICAgICAgICAgICAgIGRlY29yYXRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgd2FzX3Byb2Nlc3NlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFyZXN1bHQuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBFYWNoIFwiY2h1bmtcIiBpcyB0aGUgdGV4dCBhZnRlciB0aGUgQ1NJIChFU0MgKyBcIltcIikgYW5kIGJlZm9yZSB0aGUgbmV4dCBDU0kvRU9GLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgcmVnZXggbWF0Y2hlcyBmb3VyIGdyb3VwcyB3aXRoaW4gYSBjaHVuay5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgZmlyc3QgYW5kIHRoaXJkIGdyb3VwcyBtYXRjaCBjb2RlIHR5cGUuXG4gICAgICAgICAgICAvLyBXZSBzdXBwb3J0ZWQgb25seSBTR1IgY29tbWFuZC4gSXQgaGFzIGVtcHR5IGZpcnN0IGdyb3VwIGFuZCBcIm1cIiBpbiB0aGlyZC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgc2Vjb25kIGdyb3VwIG1hdGNoZXMgYWxsIG9mIHRoZSBudW1iZXIrc2VtaWNvbG9uIGNvbW1hbmQgc2VxdWVuY2VzXG4gICAgICAgICAgICAvLyBiZWZvcmUgdGhlIFwibVwiIChvciBvdGhlciB0cmFpbGluZykgY2hhcmFjdGVyLlxuICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHRoZSBncmFwaGljcyBvciBTR1IgY29tbWFuZHMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhlIGxhc3QgZ3JvdXAgaXMgdGhlIHRleHQgKGluY2x1ZGluZyBuZXdsaW5lcykgdGhhdCBpcyBjb2xvcmVkIGJ5XG4gICAgICAgICAgICAvLyB0aGUgb3RoZXIgZ3JvdXBcInMgY29tbWFuZHMuXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IHRleHQubWF0Y2goL14oWyFcXHgzYy1cXHgzZl0qKShbXFxkO10qKShbXFx4MjAtXFx4MmNdKltcXHg0MC1cXHg3ZV0pKFtcXHNcXFNdKikvbSk7XG5cbiAgICAgICAgICAgIGlmICghbWF0Y2hlcykgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICAgICAgdmFyIG9yaWdfdHh0ID0gcmVzdWx0LmNvbnRlbnQgPSBtYXRjaGVzWzRdO1xuICAgICAgICAgICAgdmFyIG51bXMgPSBtYXRjaGVzWzJdLnNwbGl0KFwiO1wiKTtcblxuICAgICAgICAgICAgLy8gV2UgY3VycmVudGx5IHN1cHBvcnQgb25seSBcIlNHUlwiIChTZWxlY3QgR3JhcGhpYyBSZW5kaXRpb24pXG4gICAgICAgICAgICAvLyBTaW1wbHkgaWdub3JlIGlmIG5vdCBhIFNHUiBjb21tYW5kLlxuICAgICAgICAgICAgaWYgKG1hdGNoZXNbMV0gIT09IFwiXCIgfHwgbWF0Y2hlc1szXSAhPT0gXCJtXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1hcmt1cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gbnVsbDtcblxuICAgICAgICAgICAgd2hpbGUgKG51bXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBudW1fc3RyID0gbnVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHZhciBudW0gPSBwYXJzZUludChudW1fc3RyKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc05hTihudW0pIHx8IG51bSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gc2VsZi5iZyA9IHNlbGYuZGVjb3JhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gXCJib2xkXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gXCJkaW1cIjtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5hYmxlIGNvZGUgMiB0byBnZXQgc3RyaW5nXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT0gMykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcIml0YWxpY1wiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gXCJ1bmRlcmxpbmVcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVjb3JhdGlvbiA9IFwiYmxpbmtcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gNykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcInJldmVyc2VcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRlY29yYXRpb24gPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmFibGUgY29kZSA5IHRvIGdldCBzdHJpa2V0aHJvdWdoXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5kZWNvcmF0aW9uID0gXCJzdHJpa2V0aHJvdWdoXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT0gMzkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPT0gNDkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5iZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmVncm91bmQgY29sb3JcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSAzMCAmJiBudW0gPCAzOCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gQU5TSV9DT0xPUlNbMF1bbnVtICUgMTBdW2tleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmVncm91bmQgYnJpZ2h0IGNvbG9yXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gOTAgJiYgbnVtIDwgOTgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IEFOU0lfQ09MT1JTWzFdW251bSAlIDEwXVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrZ3JvdW5kIGNvbG9yXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gNDAgJiYgbnVtIDwgNDgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5iZyA9IEFOU0lfQ09MT1JTWzBdW251bSAlIDEwXVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAvLyBCYWNrZ3JvdW5kIGJyaWdodCBjb2xvclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID49IDEwMCAmJiBudW0gPCAxMDgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5iZyA9IEFOU0lfQ09MT1JTWzFdW251bSAlIDEwXVtrZXldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtID09PSAzOCB8fCBudW0gPT09IDQ4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dGVuZCBjb2xvciAoMzg9ZmcsIDQ4PWJnKVxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNfZm9yZWdyb3VuZCA9IG51bSA9PT0gMzg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZSA9IG51bXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSBcIjVcIiAmJiBudW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFsZXR0ZSBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWxldHRlX2luZGV4ID0gcGFyc2VJbnQobnVtcy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFsZXR0ZV9pbmRleCA+PSAwICYmIHBhbGV0dGVfaW5kZXggPD0gMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlX2NsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5QQUxFVFRFX0NPTE9SUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0dXBQYWxldHRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNfZm9yZWdyb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZmcgPSB0aGlzLlBBTEVUVEVfQ09MT1JTW3BhbGV0dGVfaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gdGhpcy5QQUxFVFRFX0NPTE9SU1twYWxldHRlX2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrbGFzcyA9IHBhbGV0dGVfaW5kZXggPj0gMTYgPyBcImFuc2ktcGFsZXR0ZS1cIiArIHBhbGV0dGVfaW5kZXggOiBBTlNJX0NPTE9SU1twYWxldHRlX2luZGV4ID4gNyA/IDEgOiAwXVtwYWxldHRlX2luZGV4ICUgOF1bXCJjbGFzc1wiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19mb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IGtsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0ga2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09IFwiMlwiICYmIG51bXMubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBwYXJzZUludChudW1zLnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnID0gcGFyc2VJbnQobnVtcy5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHBhcnNlSW50KG51bXMuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIgPj0gMCAmJiByIDw9IDI1NSAmJiBnID49IDAgJiYgZyA8PSAyNTUgJiYgYiA+PSAwICYmIGIgPD0gMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IHIgKyBcIiwgXCIgKyBnICsgXCIsIFwiICsgYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VfY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzX2ZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZnID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmcgPSBjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc19mb3JlZ3JvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5mZyA9IFwiYW5zaS10cnVlY29sb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmZnX3RydWVjb2xvciA9IGNvbG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJnID0gXCJhbnNpLXRydWVjb2xvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYmdfdHJ1ZWNvbG9yID0gY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmZnID09PSBudWxsICYmIHNlbGYuYmcgPT09IG51bGwgJiYgc2VsZi5kZWNvcmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdC5mZyA9IHNlbGYuZmc7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmJnID0gc2VsZi5iZztcbiAgICAgICAgICAgICAgICByZXN1bHQuZmdfdHJ1ZWNvbG9yID0gc2VsZi5mZ190cnVlY29sb3I7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmJnX3RydWVjb2xvciA9IHNlbGYuYmdfdHJ1ZWNvbG9yO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kZWNvcmF0aW9uID0gc2VsZi5kZWNvcmF0aW9uO1xuICAgICAgICAgICAgICAgIHJlc3VsdC53YXNfcHJvY2Vzc2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2Vzc0NodW5rXG4gICAgICAgICAqIFByb2Nlc3NlcyB0aGUgY3VycmVudCBjaHVuayBvZiB0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBwcm9jZXNzQ2h1bmtcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRoZSBpbnB1dCB0ZXh0LlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgICAgICpcbiAgICAgICAgICogIC0gYGpzb25gIChCb29sZWFuKTogSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgYW4gb2JqZWN0LlxuICAgICAgICAgKiAgLSBgdXNlX2NsYXNzZXNgIChCb29sZWFuKTogSWYgYHRydWVgLCBIVE1MIGNsYXNzZXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgSFRNTCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWFya3VwIElmIGZhbHNlLCB0aGUgY29sb3JzIHdpbGwgbm90IGJlIHBhcnNlZC5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fFN0cmluZ30gVGhlIHJlc3VsdCAob2JqZWN0IGlmIGBqc29uYCBpcyB3YW50ZWQgYmFjayBvciBzdHJpbmcgb3RoZXJ3aXNlKS5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJwcm9jZXNzQ2h1bmtcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NDaHVuayh0ZXh0LCBvcHRpb25zLCBtYXJrdXApIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBqc29uQ2h1bmsgPSB0aGlzLnByb2Nlc3NDaHVua0pzb24odGV4dCwgb3B0aW9ucywgbWFya3VwKTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuanNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uQ2h1bms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNvbkNodW5rLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFqc29uQ2h1bmsud2FzX3Byb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uQ2h1bmsuY29udGVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHVzZV9jbGFzc2VzID0gb3B0aW9ucy51c2VfY2xhc3NlcztcblxuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICB2YXIgcmVuZGVyX2RhdGEgPSBmdW5jdGlvbiByZW5kZXJfZGF0YShkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudHMucHVzaChcImRhdGEtXCIgKyBrZXkgKyBcIj1cXFwiXCIgKyBfdGhpczIuZXNjYXBlRm9ySHRtbChkYXRhW2tleV0pICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHMubGVuZ3RoID4gMCA/IFwiIFwiICsgZnJhZ21lbnRzLmpvaW4oXCIgXCIpIDogXCJcIjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChqc29uQ2h1bmsuZmcpIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlX2NsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGpzb25DaHVuay5mZyArIFwiLWZnXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanNvbkNodW5rLmZnX3RydWVjb2xvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtcImFuc2ktdHJ1ZWNvbG9yLWZnXCJdID0ganNvbkNodW5rLmZnX3RydWVjb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25DaHVuay5mZ190cnVlY29sb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJjb2xvcjpyZ2IoXCIgKyBqc29uQ2h1bmsuZmcgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoanNvbkNodW5rLmJnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVzZV9jbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChqc29uQ2h1bmsuYmcgKyBcIi1iZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25DaHVuay5iZ190cnVlY29sb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbXCJhbnNpLXRydWVjb2xvci1iZ1wiXSA9IGpzb25DaHVuay5iZ190cnVlY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uQ2h1bmsuYmdfdHJ1ZWNvbG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwiYmFja2dyb3VuZC1jb2xvcjpyZ2IoXCIgKyBqc29uQ2h1bmsuYmcgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoanNvbkNodW5rLmRlY29yYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAodXNlX2NsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKFwiYW5zaS1cIiArIGpzb25DaHVuay5kZWNvcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb25DaHVuay5kZWNvcmF0aW9uID09PSBcImJvbGRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChcImZvbnQtd2VpZ2h0OmJvbGRcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbiA9PT0gXCJkaW1cIikge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChcIm9wYWNpdHk6MC41XCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbkNodW5rLmRlY29yYXRpb24gPT09IFwiaXRhbGljXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzLnB1c2goXCJmb250LXN0eWxlOml0YWxpY1wiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5kZXJsaW5lIGFuZCBibGluayBhcmUgdHJlYXRlZCBiZWxsb3dcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGpzb25DaHVuay5kZWNvcmF0aW9uID09PSBcInJldmVyc2VcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChcImZpbHRlcjppbnZlcnQoMTAwJSlcIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqc29uQ2h1bmsuZGVjb3JhdGlvbiA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChcInZpc2liaWxpdHk6aGlkZGVuXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoanNvbkNodW5rLmRlY29yYXRpb24gPT09IFwic3RyaWtldGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKFwidGV4dC1kZWNvcmF0aW9uOmxpbmUtdGhyb3VnaFwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChcInRleHQtZGVjb3JhdGlvbjpcIiArIGpzb25DaHVuay5kZWNvcmF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1c2VfY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIjxzcGFuIGNsYXNzPVxcXCJcIiArIGNsYXNzZXMuam9pbihcIiBcIikgKyBcIlxcXCJcIiArIHJlbmRlcl9kYXRhKGRhdGEpICsgXCI+XCIgKyBqc29uQ2h1bmsuY29udGVudCArIFwiPC9zcGFuPlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCI8c3BhbiBzdHlsZT1cXFwiXCIgKyBzdHlsZXMuam9pbihcIjtcIikgKyBcIlxcXCJcIiArIHJlbmRlcl9kYXRhKGRhdGEpICsgXCI+XCIgKyBqc29uQ2h1bmsuY29udGVudCArIFwiPC9zcGFuPlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEFuc2VyO1xufSgpO1xuXG47XG5cbm1vZHVsZS5leHBvcnRzID0gQW5zZXI7IiwiLyohIGh0dHBzOi8vbXRocy5iZS9jc3Nlc2NhcGUgdjEuNS4xIGJ5IEBtYXRoaWFzIHwgTUlUIGxpY2Vuc2UgKi9cbjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXHQvLyBodHRwczovL2dpdGh1Yi5jb20vdW1kanMvdW1kL2Jsb2IvbWFzdGVyL3JldHVybkV4cG9ydHMuanNcblx0aWYgKHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnKSB7XG5cdFx0Ly8gRm9yIE5vZGUuanMuXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJvb3QpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gRm9yIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoW10sIGZhY3RvcnkuYmluZChyb290LCByb290KSk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gRm9yIGJyb3dzZXIgZ2xvYmFscyAobm90IGV4cG9zaW5nIHRoZSBmdW5jdGlvbiBzZXBhcmF0ZWx5KS5cblx0XHRmYWN0b3J5KHJvb3QpO1xuXHR9XG59KHR5cGVvZiBnbG9iYWwgIT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0aGlzLCBmdW5jdGlvbihyb290KSB7XG5cblx0aWYgKHJvb3QuQ1NTICYmIHJvb3QuQ1NTLmVzY2FwZSkge1xuXHRcdHJldHVybiByb290LkNTUy5lc2NhcGU7XG5cdH1cblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3NlcmlhbGl6ZS1hbi1pZGVudGlmaWVyXG5cdHZhciBjc3NFc2NhcGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ2BDU1MuZXNjYXBlYCByZXF1aXJlcyBhbiBhcmd1bWVudC4nKTtcblx0XHR9XG5cdFx0dmFyIHN0cmluZyA9IFN0cmluZyh2YWx1ZSk7XG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVVbml0O1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHR2YXIgZmlyc3RDb2RlVW5pdCA9IHN0cmluZy5jaGFyQ29kZUF0KDApO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlVW5pdCA9IHN0cmluZy5jaGFyQ29kZUF0KGluZGV4KTtcblx0XHRcdC8vIE5vdGU6IHRoZXJl4oCZcyBubyBuZWVkIHRvIHNwZWNpYWwtY2FzZSBhc3RyYWwgc3ltYm9scywgc3Vycm9nYXRlXG5cdFx0XHQvLyBwYWlycywgb3IgbG9uZSBzdXJyb2dhdGVzLlxuXG5cdFx0XHQvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIE5VTEwgKFUrMDAwMCksIHRoZW4gdGhlIFJFUExBQ0VNRU5UIENIQVJBQ1RFUlxuXHRcdFx0Ly8gKFUrRkZGRCkuXG5cdFx0XHRpZiAoY29kZVVuaXQgPT0gMHgwMDAwKSB7XG5cdFx0XHRcdHJlc3VsdCArPSAnXFx1RkZGRCc7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgaW4gdGhlIHJhbmdlIFtcXDEtXFwxRl0gKFUrMDAwMSB0byBVKzAwMUYpIG9yIGlzXG5cdFx0XHRcdC8vIFUrMDA3RiwgW+KApl1cblx0XHRcdFx0KGNvZGVVbml0ID49IDB4MDAwMSAmJiBjb2RlVW5pdCA8PSAweDAwMUYpIHx8IGNvZGVVbml0ID09IDB4MDA3RiB8fFxuXHRcdFx0XHQvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGlzIGluIHRoZSByYW5nZSBbMC05XVxuXHRcdFx0XHQvLyAoVSswMDMwIHRvIFUrMDAzOSksIFvigKZdXG5cdFx0XHRcdChpbmRleCA9PSAwICYmIGNvZGVVbml0ID49IDB4MDAzMCAmJiBjb2RlVW5pdCA8PSAweDAwMzkpIHx8XG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgdGhlIHNlY29uZCBjaGFyYWN0ZXIgYW5kIGlzIGluIHRoZSByYW5nZSBbMC05XVxuXHRcdFx0XHQvLyAoVSswMDMwIHRvIFUrMDAzOSkgYW5kIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgYSBgLWAgKFUrMDAyRCksIFvigKZdXG5cdFx0XHRcdChcblx0XHRcdFx0XHRpbmRleCA9PSAxICYmXG5cdFx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDMwICYmIGNvZGVVbml0IDw9IDB4MDAzOSAmJlxuXHRcdFx0XHRcdGZpcnN0Q29kZVVuaXQgPT0gMHgwMDJEXG5cdFx0XHRcdClcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2VzY2FwZS1hLWNoYXJhY3Rlci1hcy1jb2RlLXBvaW50XG5cdFx0XHRcdHJlc3VsdCArPSAnXFxcXCcgKyBjb2RlVW5pdC50b1N0cmluZygxNikgKyAnICc7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgaXMgYSBgLWAgKFUrMDAyRCksIGFuZFxuXHRcdFx0XHQvLyB0aGVyZSBpcyBubyBzZWNvbmQgY2hhcmFjdGVyLCBb4oCmXVxuXHRcdFx0XHRpbmRleCA9PSAwICYmXG5cdFx0XHRcdGxlbmd0aCA9PSAxICYmXG5cdFx0XHRcdGNvZGVVbml0ID09IDB4MDAyRFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJlc3VsdCArPSAnXFxcXCcgKyBzdHJpbmcuY2hhckF0KGluZGV4KTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgbm90IGhhbmRsZWQgYnkgb25lIG9mIHRoZSBhYm92ZSBydWxlcyBhbmQgaXNcblx0XHRcdC8vIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBVKzAwODAsIGlzIGAtYCAoVSswMDJEKSBvciBgX2AgKFUrMDA1RiksIG9yXG5cdFx0XHQvLyBpcyBpbiBvbmUgb2YgdGhlIHJhbmdlcyBbMC05XSAoVSswMDMwIHRvIFUrMDAzOSksIFtBLVpdIChVKzAwNDEgdG9cblx0XHRcdC8vIFUrMDA1QSksIG9yIFthLXpdIChVKzAwNjEgdG8gVSswMDdBKSwgW+KApl1cblx0XHRcdGlmIChcblx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDgwIHx8XG5cdFx0XHRcdGNvZGVVbml0ID09IDB4MDAyRCB8fFxuXHRcdFx0XHRjb2RlVW5pdCA9PSAweDAwNUYgfHxcblx0XHRcdFx0Y29kZVVuaXQgPj0gMHgwMDMwICYmIGNvZGVVbml0IDw9IDB4MDAzOSB8fFxuXHRcdFx0XHRjb2RlVW5pdCA+PSAweDAwNDEgJiYgY29kZVVuaXQgPD0gMHgwMDVBIHx8XG5cdFx0XHRcdGNvZGVVbml0ID49IDB4MDA2MSAmJiBjb2RlVW5pdCA8PSAweDAwN0Fcblx0XHRcdCkge1xuXHRcdFx0XHQvLyB0aGUgY2hhcmFjdGVyIGl0c2VsZlxuXHRcdFx0XHRyZXN1bHQgKz0gc3RyaW5nLmNoYXJBdChpbmRleCk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cblx0XHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jZXNjYXBlLWEtY2hhcmFjdGVyXG5cdFx0XHRyZXN1bHQgKz0gJ1xcXFwnICsgc3RyaW5nLmNoYXJBdChpbmRleCk7XG5cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRpZiAoIXJvb3QuQ1NTKSB7XG5cdFx0cm9vdC5DU1MgPSB7fTtcblx0fVxuXG5cdHJvb3QuQ1NTLmVzY2FwZSA9IGNzc0VzY2FwZTtcblx0cmV0dXJuIGNzc0VzY2FwZTtcblxufSkpO1xuIiwidmFyIGUsdD0oZT1yZXF1aXJlKFwicXVlcnlzdHJpbmdcIikpJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmXCJkZWZhdWx0XCJpbiBlP2UuZGVmYXVsdDplLHI9L2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvO2Z1bmN0aW9uIG8oZSl7XCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPWcoZSkpO3ZhciBvPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbz1lLmF1dGgsYT1lLmhvc3RuYW1lLHM9ZS5wcm90b2NvbHx8XCJcIixjPWUucGF0aG5hbWV8fFwiXCIsaD1lLmhhc2h8fFwiXCIscD1lLnF1ZXJ5fHxcIlwiLG49ITE7bz1vP2VuY29kZVVSSUNvbXBvbmVudChvKS5yZXBsYWNlKC8lM0EvaSxcIjpcIikrXCJAXCI6XCJcIixlLmhvc3Q/bj1vK2UuaG9zdDphJiYobj1vKyh+YS5pbmRleE9mKFwiOlwiKT9cIltcIithK1wiXVwiOmEpLGUucG9ydCYmKG4rPVwiOlwiK2UucG9ydCkpLHAmJlwib2JqZWN0XCI9PXR5cGVvZiBwJiYocD10LmVuY29kZShwKSk7dmFyIGw9ZS5zZWFyY2h8fHAmJlwiP1wiK3B8fFwiXCI7cmV0dXJuIHMmJlwiOlwiIT09cy5zdWJzdHIoLTEpJiYocys9XCI6XCIpLGUuc2xhc2hlc3x8KCFzfHxyLnRlc3QocykpJiYhMSE9PW4/KG49XCIvL1wiKyhufHxcIlwiKSxjJiZcIi9cIiE9PWNbMF0mJihjPVwiL1wiK2MpKTpufHwobj1cIlwiKSxoJiZcIiNcIiE9PWhbMF0mJihoPVwiI1wiK2gpLGwmJlwiP1wiIT09bFswXSYmKGw9XCI/XCIrbCkse3Byb3RvY29sOnMsaG9zdDpuLHBhdGhuYW1lOmM9Yy5yZXBsYWNlKC9bPyNdL2csZW5jb2RlVVJJQ29tcG9uZW50KSxzZWFyY2g6bD1sLnJlcGxhY2UoXCIjXCIsXCIlMjNcIiksaGFzaDpofX0oZSx0LHIpO3JldHVyblwiXCIrby5wcm90b2NvbCtvLmhvc3Qrby5wYXRobmFtZStvLnNlYXJjaCtvLmhhc2h9dmFyIGE9XCJodHRwOi8vXCIscz1cIncud1wiLGM9YStzLGg9L14oW2EtejAtOS4rLV0qOlxcL1xcL1xcLykoW2EtejAtOS4rLV06XFwvKik/L2kscD0vaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87ZnVuY3Rpb24gbihlLHQpe3ZhciByPVwic3RyaW5nXCI9PXR5cGVvZiBlP2coZSk6ZTtlPVwib2JqZWN0XCI9PXR5cGVvZiBlP28oZSk6ZTt2YXIgcz1nKHQpLG49XCJcIjtyLnByb3RvY29sJiYhci5zbGFzaGVzJiYobj1yLnByb3RvY29sLGU9ZS5yZXBsYWNlKHIucHJvdG9jb2wsXCJcIiksbis9XCIvXCI9PT10WzBdfHxcIi9cIj09PWVbMF0/XCIvXCI6XCJcIiksbiYmcy5wcm90b2NvbCYmKG49XCJcIixzLnNsYXNoZXN8fChuPXMucHJvdG9jb2wsdD10LnJlcGxhY2Uocy5wcm90b2NvbCxcIlwiKSkpO3ZhciBsPWUubWF0Y2goaCk7bCYmIXMucHJvdG9jb2wmJihlPWUuc3Vic3RyKChuPWxbMV0rKGxbMl18fFwiXCIpKS5sZW5ndGgpLC9eXFwvXFwvW14vXS8udGVzdCh0KSYmKG49bi5zbGljZSgwLC0xKSkpO3ZhciBpPW5ldyBVUkwoZSxjK1wiL1wiKSxmPW5ldyBVUkwodCxpKS50b1N0cmluZygpLnJlcGxhY2UoYyxcIlwiKSx1PXMucHJvdG9jb2x8fHIucHJvdG9jb2w7cmV0dXJuIHUrPXIuc2xhc2hlc3x8cy5zbGFzaGVzP1wiLy9cIjpcIlwiLCFuJiZ1P2Y9Zi5yZXBsYWNlKGEsdSk6biYmKGY9Zi5yZXBsYWNlKGEsXCJcIikpLHAudGVzdChmKXx8fnQuaW5kZXhPZihcIi5cIil8fFwiL1wiPT09ZS5zbGljZSgtMSl8fFwiL1wiPT09dC5zbGljZSgtMSl8fFwiL1wiIT09Zi5zbGljZSgtMSl8fChmPWYuc2xpY2UoMCwtMSkpLG4mJihmPW4rKFwiL1wiPT09ZlswXT9mLnN1YnN0cigxKTpmKSksZn1mdW5jdGlvbiBsKCl7fWwucGFyc2U9ZyxsLmZvcm1hdD1vLGwucmVzb2x2ZT1uLGwucmVzb2x2ZU9iamVjdD1uO3ZhciBpPS9eaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS8sZj0vXiguKj8pKFsjP10uKikvLHU9L14oW2EtejAtOS4rLV0qOikoXFwvezAsM30pKC4qKS9pLG09L14oW2EtejAtOS4rLV0qOik/XFwvXFwvXFwvKi9pLHY9L14oW2EtejAtOS4rLV0qOikoXFwvezAsMn0pXFxbKC4qKVxcXSQvaTtmdW5jdGlvbiBkKGUpe3RyeXtyZXR1cm4gZGVjb2RlVVJJKGUpfWNhdGNoKHQpe3JldHVybiBlfX1mdW5jdGlvbiBnKGUscixhKXtpZih2b2lkIDA9PT1yJiYocj0hMSksdm9pZCAwPT09YSYmKGE9ITEpLGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlIGluc3RhbmNlb2YgbClyZXR1cm4gZTt2YXIgaD0oZT1lLnRyaW0oKSkubWF0Y2goZik7ZT1oP2QoaFsxXSkucmVwbGFjZSgvXFxcXC9nLFwiL1wiKStoWzJdOmQoZSkucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSx2LnRlc3QoZSkmJlwiL1wiIT09ZS5zbGljZSgtMSkmJihlKz1cIi9cIik7dmFyIHA9IS8oXmphdmFzY3JpcHQpLy50ZXN0KGUpJiZlLm1hdGNoKHUpLG49bS50ZXN0KGUpLGc9XCJcIjtwJiYoaS50ZXN0KHBbMV0pfHwoZz1wWzFdLnRvTG93ZXJDYXNlKCksZT1cIlwiK3BbMl0rcFszXSkscFsyXXx8KG49ITEsaS50ZXN0KHBbMV0pPyhnPXBbMV0sZT1cIlwiK3BbM10pOmU9XCIvL1wiK3BbM10pLDMhPT1wWzJdLmxlbmd0aCYmMSE9PXBbMl0ubGVuZ3RofHwoZz1wWzFdLGU9XCIvXCIrcFszXSkpO3ZhciBiLHk9KGg/aFsxXTplKS5tYXRjaCgvKDpbMC05XSspLyksaj1cIlwiO3kmJnlbMV0mJjM9PT15WzFdLmxlbmd0aCYmKGU9ZS5yZXBsYWNlKGo9eVsxXSxqK1wiMDBcIikpO3ZhciB3PW5ldyBsLHg9XCJcIixVPVwiXCI7dHJ5e2I9bmV3IFVSTChlKX1jYXRjaCh0KXt4PXQsZ3x8YXx8IS9eXFwvXFwvLy50ZXN0KGUpfHwvXlxcL1xcLy4rW0AuXS8udGVzdChlKXx8KFU9XCIvXCIsZT1lLnN1YnN0cigxKSk7dHJ5e2I9bmV3IFVSTChlLGMpfWNhdGNoKGUpe3JldHVybiB3LnByb3RvY29sPWcsdy5ocmVmPWcsd319dy5zbGFzaGVzPW4mJiFVLHcuaG9zdD1iLmhvc3Q9PT1zP1wiXCI6Yi5ob3N0LHcuaG9zdG5hbWU9Yi5ob3N0bmFtZT09PXM/XCJcIjpiLmhvc3RuYW1lLnJlcGxhY2UoLyhcXFt8XFxdKS9nLFwiXCIpLHcucHJvdG9jb2w9eD9nfHxudWxsOmIucHJvdG9jb2wsdy5zZWFyY2g9Yi5zZWFyY2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpLHcuaGFzaD1iLmhhc2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpO3ZhciBSPWUuc3BsaXQoXCIjXCIpOyF3LnNlYXJjaCYmflJbMF0uaW5kZXhPZihcIj9cIikmJih3LnNlYXJjaD1cIj9cIiksdy5oYXNofHxcIlwiIT09UlsxXXx8KHcuaGFzaD1cIiNcIiksdy5xdWVyeT1yP3QuZGVjb2RlKGIuc2VhcmNoLnN1YnN0cigxKSk6dy5zZWFyY2guc3Vic3RyKDEpLHcucGF0aG5hbWU9VStkKGIucGF0aG5hbWUpLnJlcGxhY2UoL1wiL2csXCIlMjJcIiksXCJhYm91dDpcIj09PXcucHJvdG9jb2wmJlwiYmxhbmtcIj09PXcucGF0aG5hbWUmJih3LnByb3RvY29sPVwiXCIsdy5wYXRobmFtZT1cIlwiKSx4JiZcIi9cIiE9PWVbMF0mJih3LnBhdGhuYW1lPXcucGF0aG5hbWUuc3Vic3RyKDEpKSxnJiYhaS50ZXN0KGcpJiZcIi9cIiE9PWUuc2xpY2UoLTEpJiZcIi9cIj09PXcucGF0aG5hbWUmJih3LnBhdGhuYW1lPVwiXCIpLHcucGF0aD13LnBhdGhuYW1lK3cuc2VhcmNoLHcuYXV0aD1bYi51c2VybmFtZSxiLnBhc3N3b3JkXS5tYXAoZGVjb2RlVVJJQ29tcG9uZW50KS5maWx0ZXIoQm9vbGVhbikuam9pbihcIjpcIiksdy5wb3J0PWIucG9ydCxqJiYody5ob3N0PXcuaG9zdC5yZXBsYWNlKGorXCIwMFwiLGopLHcucG9ydD13LnBvcnQuc2xpY2UoMCwtMikpLHcuaHJlZj1VP1wiXCIrdy5wYXRobmFtZSt3LnNlYXJjaCt3Lmhhc2g6byh3KTt2YXIgTz0vXihmaWxlKS8udGVzdCh3LmhyZWYpP1tcImhvc3RcIixcImhvc3RuYW1lXCJdOltdO3JldHVybiBPYmplY3Qua2V5cyh3KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe35PLmluZGV4T2YoZSl8fCh3W2VdPXdbZV18fG51bGwpfSksd31leHBvcnRzLnBhcnNlPWcsZXhwb3J0cy5mb3JtYXQ9byxleHBvcnRzLnJlc29sdmU9bixleHBvcnRzLnJlc29sdmVPYmplY3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZyhuKGUsdCkpfSxleHBvcnRzLlVybD1sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5PWZ1bmN0aW9uKG4pe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIG4pcmV0dXJuIHRoaXMudGhlbihuLG4pO3ZhciB0PXRoaXMuY29uc3RydWN0b3J8fFByb21pc2U7cmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbihyKXtyZXR1cm4gdC5yZXNvbHZlKG4oKSkudGhlbihmdW5jdGlvbigpe3JldHVybiByfSl9LGZ1bmN0aW9uKHIpe3JldHVybiB0LnJlc29sdmUobigpKS50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgcn0pfSl9OyIsIm1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGUsbil7cmV0dXJuIG49bnx8e30sbmV3IFByb21pc2UoZnVuY3Rpb24odCxyKXt2YXIgcz1uZXcgWE1MSHR0cFJlcXVlc3Qsbz1bXSx1PVtdLGk9e30sYT1mdW5jdGlvbigpe3JldHVybntvazoyPT0ocy5zdGF0dXMvMTAwfDApLHN0YXR1c1RleHQ6cy5zdGF0dXNUZXh0LHN0YXR1czpzLnN0YXR1cyx1cmw6cy5yZXNwb25zZVVSTCx0ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShzLnJlc3BvbnNlVGV4dCl9LGpzb246ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKEpTT04ucGFyc2Uocy5yZXNwb25zZVRleHQpKX0sYmxvYjpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3MucmVzcG9uc2VdKSl9LGNsb25lOmEsaGVhZGVyczp7a2V5czpmdW5jdGlvbigpe3JldHVybiBvfSxlbnRyaWVzOmZ1bmN0aW9uKCl7cmV0dXJuIHV9LGdldDpmdW5jdGlvbihlKXtyZXR1cm4gaVtlLnRvTG93ZXJDYXNlKCldfSxoYXM6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudG9Mb3dlckNhc2UoKWluIGl9fX19O2Zvcih2YXIgbCBpbiBzLm9wZW4obi5tZXRob2R8fFwiZ2V0XCIsZSwhMCkscy5vbmxvYWQ9ZnVuY3Rpb24oKXtzLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnJlcGxhY2UoL14oLio/KTpbXlxcU1xcbl0qKFtcXHNcXFNdKj8pJC9nbSxmdW5jdGlvbihlLG4sdCl7by5wdXNoKG49bi50b0xvd2VyQ2FzZSgpKSx1LnB1c2goW24sdF0pLGlbbl09aVtuXT9pW25dK1wiLFwiK3Q6dH0pLHQoYSgpKX0scy5vbmVycm9yPXIscy53aXRoQ3JlZGVudGlhbHM9XCJpbmNsdWRlXCI9PW4uY3JlZGVudGlhbHMsbi5oZWFkZXJzKXMuc2V0UmVxdWVzdEhlYWRlcihsLG4uaGVhZGVyc1tsXSk7cy5zZW5kKG4uYm9keXx8bnVsbCl9KX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bmZldGNoLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy5kZWZhdWx0PWluaXRpYWxpemVCdWlsZFdhdGNoZXI7dmFyIF9ldmVudHNvdXJjZT1yZXF1aXJlKFwiLi9lcnJvci1vdmVybGF5L2V2ZW50c291cmNlXCIpO2Z1bmN0aW9uIGluaXRpYWxpemVCdWlsZFdhdGNoZXIoKXt2YXIgc2hhZG93SG9zdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtzaGFkb3dIb3N0LmlkPSdfX25leHQtYnVpbGQtd2F0Y2hlcic7Ly8gTWFrZSBzdXJlIGNvbnRhaW5lciBpcyBmaXhlZCBhbmQgb24gYSBoaWdoIHpJbmRleCBzbyBpdCBzaG93c1xuc2hhZG93SG9zdC5zdHlsZS5wb3NpdGlvbj0nZml4ZWQnO3NoYWRvd0hvc3Quc3R5bGUuYm90dG9tPScxMHB4JztzaGFkb3dIb3N0LnN0eWxlLnJpZ2h0PScyMHB4JztzaGFkb3dIb3N0LnN0eWxlLndpZHRoPTA7c2hhZG93SG9zdC5zdHlsZS5oZWlnaHQ9MDtzaGFkb3dIb3N0LnN0eWxlLnpJbmRleD05OTk5OTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNoYWRvd0hvc3QpO3ZhciBzaGFkb3dSb290O3ZhciBwcmVmaXg9Jyc7aWYoc2hhZG93SG9zdC5hdHRhY2hTaGFkb3cpe3NoYWRvd1Jvb3Q9c2hhZG93SG9zdC5hdHRhY2hTaGFkb3coe21vZGU6J29wZW4nfSk7fWVsc2V7Ly8gSWYgYXR0YWNoU2hhZG93IGlzIHVuZGVmaW5lZCB0aGVuIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnRcbi8vIHRoZSBTaGFkb3cgRE9NLCB3ZSBuZWVkIHRvIHByZWZpeCBhbGwgdGhlIG5hbWVzIHNvIHRoZXJlXG4vLyB3aWxsIGJlIG5vIGNvbmZsaWN0c1xuc2hhZG93Um9vdD1zaGFkb3dIb3N0O3ByZWZpeD0nX19uZXh0LWJ1aWxkLXdhdGNoZXItJzt9Ly8gQ29udGFpbmVyXG52YXIgY29udGFpbmVyPWNyZWF0ZUNvbnRhaW5lcihwcmVmaXgpO3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTsvLyBDU1NcbnZhciBjc3M9Y3JlYXRlQ3NzKHByZWZpeCk7c2hhZG93Um9vdC5hcHBlbmRDaGlsZChjc3MpOy8vIFN0YXRlXG52YXIgaXNWaXNpYmxlPWZhbHNlO3ZhciBpc0J1aWxkaW5nPWZhbHNlO3ZhciB0aW1lb3V0SWQ9bnVsbDsvLyBIYW5kbGUgZXZlbnRzXG52YXIgZXZ0U291cmNlPSgwLF9ldmVudHNvdXJjZS5nZXRFdmVudFNvdXJjZVdyYXBwZXIpKHtwYXRoOicvX25leHQvd2VicGFjay1obXInfSk7ZXZ0U291cmNlLmFkZE1lc3NhZ2VMaXN0ZW5lcihldmVudD0+ey8vIFRoaXMgaXMgdGhlIGhlYXJ0YmVhdCBldmVudFxuaWYoZXZlbnQuZGF0YT09PSdcXHVEODNEXFx1REM5Mycpe3JldHVybjt9dHJ5e2hhbmRsZU1lc3NhZ2UoZXZlbnQpO31jYXRjaChfdW51c2VkKXt9fSk7ZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCl7dmFyIG9iaj1KU09OLnBhcnNlKGV2ZW50LmRhdGEpOy8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcbnN3aXRjaChvYmouYWN0aW9uKXtjYXNlJ2J1aWxkaW5nJzp0aW1lb3V0SWQmJmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO2lzVmlzaWJsZT10cnVlO2lzQnVpbGRpbmc9dHJ1ZTt1cGRhdGVDb250YWluZXIoKTticmVhaztjYXNlJ2J1aWx0JzpjYXNlJ3N5bmMnOmlzQnVpbGRpbmc9ZmFsc2U7Ly8gV2FpdCBmb3IgdGhlIGZhZGUgb3V0IHRyYW5zdGlvbiB0byBjb21wbGV0ZVxudGltZW91dElkPXNldFRpbWVvdXQoKCk9Pntpc1Zpc2libGU9ZmFsc2U7dXBkYXRlQ29udGFpbmVyKCk7fSwxMDApO3VwZGF0ZUNvbnRhaW5lcigpO2JyZWFrO319ZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKCl7aWYoaXNCdWlsZGluZyl7Y29udGFpbmVyLmNsYXNzTGlzdC5hZGQocHJlZml4K1wiYnVpbGRpbmdcIik7fWVsc2V7Y29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUocHJlZml4K1wiYnVpbGRpbmdcIik7fWlmKGlzVmlzaWJsZSl7Y29udGFpbmVyLmNsYXNzTGlzdC5hZGQocHJlZml4K1widmlzaWJsZVwiKTt9ZWxzZXtjb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShwcmVmaXgrXCJ2aXNpYmxlXCIpO319fWZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihwcmVmaXgpe3ZhciBjb250YWluZXI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7Y29udGFpbmVyLmlkPXByZWZpeCtcImNvbnRhaW5lclwiO2NvbnRhaW5lci5pbm5lckhUTUw9XCJcXG4gICAgPGRpdiBpZD1cXFwiXCIrcHJlZml4K1wiaWNvbi13cmFwcGVyXFxcIj5cXG4gICAgICA8c3ZnIHZpZXdCb3g9XFxcIjAgMCAyMjYgMjAwXFxcIj5cXG4gICAgICAgIDxkZWZzPlxcbiAgICAgICAgICA8bGluZWFyR3JhZGllbnRcXG4gICAgICAgICAgICB4MT1cXFwiMTE0LjcyMDc3NSVcXFwiXFxuICAgICAgICAgICAgeTE9XFxcIjE4MS4yODMyNDUlXFxcIlxcbiAgICAgICAgICAgIHgyPVxcXCIzOS41Mzk5MzA2JVxcXCJcXG4gICAgICAgICAgICB5Mj1cXFwiMTAwJVxcXCJcXG4gICAgICAgICAgICBpZD1cXFwiXCIrcHJlZml4K1wibGluZWFyLWdyYWRpZW50XFxcIlxcbiAgICAgICAgICA+XFxuICAgICAgICAgICAgPHN0b3Agc3RvcC1jb2xvcj1cXFwiI0ZGRkZGRlxcXCIgb2Zmc2V0PVxcXCIwJVxcXCIgLz5cXG4gICAgICAgICAgICA8c3RvcCBzdG9wLWNvbG9yPVxcXCIjMDAwMDAwXFxcIiBvZmZzZXQ9XFxcIjEwMCVcXFwiIC8+XFxuICAgICAgICAgIDwvbGluZWFyR3JhZGllbnQ+XFxuICAgICAgICA8L2RlZnM+XFxuICAgICAgICA8ZyBpZD1cXFwiXCIrcHJlZml4K1wiaWNvbi1ncm91cFxcXCIgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCJ1cmwoI1wiK3ByZWZpeCtcImxpbmVhci1ncmFkaWVudClcXFwiIHN0cm9rZS13aWR0aD1cXFwiMThcXFwiPlxcbiAgICAgICAgICA8cGF0aCBkPVxcXCJNMTEzLDUuMDgyMTkxMTcgTDQuMjgzOTM4MDEsMTk3LjUgTDIyMS43MTYwNjIsMTk3LjUgTDExMyw1LjA4MjE5MTE3IFpcXFwiIC8+XFxuICAgICAgICA8L2c+XFxuICAgICAgPC9zdmc+XFxuICAgIDwvZGl2PlxcbiAgXCI7cmV0dXJuIGNvbnRhaW5lcjt9ZnVuY3Rpb24gY3JlYXRlQ3NzKHByZWZpeCl7dmFyIGNzcz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO2Nzcy50ZXh0Q29udGVudD1cIlxcbiAgICAjXCIrcHJlZml4K1wiY29udGFpbmVyIHtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgYm90dG9tOiAxMHB4O1xcbiAgICAgIHJpZ2h0OiAzMHB4O1xcblxcbiAgICAgIGJhY2tncm91bmQ6ICNmZmY7XFxuICAgICAgY29sb3I6ICMwMDA7XFxuICAgICAgZm9udDogaW5pdGlhbDtcXG4gICAgICBjdXJzb3I6IGluaXRpYWw7XFxuICAgICAgbGV0dGVyLXNwYWNpbmc6IGluaXRpYWw7XFxuICAgICAgdGV4dC1zaGFkb3c6IGluaXRpYWw7XFxuICAgICAgdGV4dC10cmFuc2Zvcm06IGluaXRpYWw7XFxuICAgICAgdmlzaWJpbGl0eTogaW5pdGlhbDtcXG5cXG4gICAgICBwYWRkaW5nOiA4cHggMTBweDtcXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgIGJveC1zaGFkb3c6IDAgMTFweCA0MHB4IDAgcmdiYSgwLCAwLCAwLCAwLjI1KSwgMCAycHggMTBweCAwIHJnYmEoMCwgMCwgMCwgMC4xMik7XFxuXFxuICAgICAgZGlzcGxheTogbm9uZTtcXG4gICAgICBvcGFjaXR5OiAwO1xcbiAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlLCBib3R0b20gMC4xcyBlYXNlO1xcbiAgICAgIGFuaW1hdGlvbjogXCIrcHJlZml4K1wiZmFkZS1pbiAwLjFzIGVhc2UtaW4tb3V0O1xcbiAgICB9XFxuXFxuICAgICNcIitwcmVmaXgrXCJjb250YWluZXIuXCIrcHJlZml4K1widmlzaWJsZSB7XFxuICAgICAgZGlzcGxheTogZmxleDtcXG4gICAgfVxcblxcbiAgICAjXCIrcHJlZml4K1wiY29udGFpbmVyLlwiK3ByZWZpeCtcImJ1aWxkaW5nIHtcXG4gICAgICBib3R0b206IDIwcHg7XFxuICAgICAgb3BhY2l0eTogMTtcXG4gICAgfVxcblxcbiAgICAjXCIrcHJlZml4K1wiaWNvbi13cmFwcGVyIHtcXG4gICAgICB3aWR0aDogMTZweDtcXG4gICAgICBoZWlnaHQ6IDE2cHg7XFxuICAgIH1cXG5cXG4gICAgI1wiK3ByZWZpeCtcImljb24td3JhcHBlciA+IHN2ZyB7XFxuICAgICAgd2lkdGg6IDEwMCU7XFxuICAgICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB9XFxuXFxuICAgICNcIitwcmVmaXgrXCJpY29uLWdyb3VwIHtcXG4gICAgICBhbmltYXRpb246IFwiK3ByZWZpeCtcInN0cm9rZWRhc2ggMXMgZWFzZS1pbi1vdXQgYm90aCBpbmZpbml0ZTtcXG4gICAgfVxcblxcbiAgICBAa2V5ZnJhbWVzIFwiK3ByZWZpeCtcImZhZGUtaW4ge1xcbiAgICAgIGZyb20ge1xcbiAgICAgICAgYm90dG9tOiAxMHB4O1xcbiAgICAgICAgb3BhY2l0eTogMDtcXG4gICAgICB9XFxuICAgICAgdG8ge1xcbiAgICAgICAgYm90dG9tOiAyMHB4O1xcbiAgICAgICAgb3BhY2l0eTogMTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgQGtleWZyYW1lcyBcIitwcmVmaXgrXCJzdHJva2VkYXNoIHtcXG4gICAgICAwJSB7XFxuICAgICAgICBzdHJva2UtZGFzaGFycmF5OiAwIDIyNjtcXG4gICAgICB9XFxuICAgICAgODAlLFxcbiAgICAgIDEwMCUge1xcbiAgICAgICAgc3Ryb2tlLWRhc2hhcnJheTogNjU5IDIyNjtcXG4gICAgICB9XFxuICAgIH1cXG4gIFwiO3JldHVybiBjc3M7fSIsIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMuZ2V0RXZlbnRTb3VyY2VXcmFwcGVyPWdldEV2ZW50U291cmNlV3JhcHBlcjt2YXIgZXZlbnRDYWxsYmFja3M9W107ZnVuY3Rpb24gRXZlbnRTb3VyY2VXcmFwcGVyKG9wdGlvbnMpe3ZhciBzb3VyY2U7dmFyIGxhc3RBY3Rpdml0eT1uZXcgRGF0ZSgpO3ZhciBsaXN0ZW5lcnM9W107aWYoIW9wdGlvbnMudGltZW91dCl7b3B0aW9ucy50aW1lb3V0PTIwKjEwMDA7fWluaXQoKTt2YXIgdGltZXI9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtpZihuZXcgRGF0ZSgpLWxhc3RBY3Rpdml0eT5vcHRpb25zLnRpbWVvdXQpe2hhbmRsZURpc2Nvbm5lY3QoKTt9fSxvcHRpb25zLnRpbWVvdXQvMik7ZnVuY3Rpb24gaW5pdCgpe3NvdXJjZT1uZXcgd2luZG93LkV2ZW50U291cmNlKG9wdGlvbnMucGF0aCk7c291cmNlLm9ub3Blbj1oYW5kbGVPbmxpbmU7c291cmNlLm9uZXJyb3I9aGFuZGxlRGlzY29ubmVjdDtzb3VyY2Uub25tZXNzYWdlPWhhbmRsZU1lc3NhZ2U7fWZ1bmN0aW9uIGhhbmRsZU9ubGluZSgpe2lmKG9wdGlvbnMubG9nKWNvbnNvbGUubG9nKCdbSE1SXSBjb25uZWN0ZWQnKTtsYXN0QWN0aXZpdHk9bmV3IERhdGUoKTt9ZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShldmVudCl7bGFzdEFjdGl2aXR5PW5ldyBEYXRlKCk7Zm9yKHZhciBpPTA7aTxsaXN0ZW5lcnMubGVuZ3RoO2krKyl7bGlzdGVuZXJzW2ldKGV2ZW50KTt9aWYoZXZlbnQuZGF0YS5pbmRleE9mKCdhY3Rpb24nKSE9PS0xKXtldmVudENhbGxiYWNrcy5mb3JFYWNoKGNiPT5jYihldmVudCkpO319ZnVuY3Rpb24gaGFuZGxlRGlzY29ubmVjdCgpe2NsZWFySW50ZXJ2YWwodGltZXIpO3NvdXJjZS5jbG9zZSgpO3NldFRpbWVvdXQoaW5pdCxvcHRpb25zLnRpbWVvdXQpO31yZXR1cm57Y2xvc2U6KCk9PntjbGVhckludGVydmFsKHRpbWVyKTtzb3VyY2UuY2xvc2UoKTt9LGFkZE1lc3NhZ2VMaXN0ZW5lcjpmdW5jdGlvbiBhZGRNZXNzYWdlTGlzdGVuZXIoZm4pe2xpc3RlbmVycy5wdXNoKGZuKTt9fTt9ZnVuY3Rpb24gZ2V0RXZlbnRTb3VyY2VXcmFwcGVyKG9wdGlvbnMpe2lmKCFvcHRpb25zLm9uZGVtYW5kKXtyZXR1cm57YWRkTWVzc2FnZUxpc3RlbmVyOmNiPT57ZXZlbnRDYWxsYmFja3MucHVzaChjYik7fX07fXJldHVybiBFdmVudFNvdXJjZVdyYXBwZXIob3B0aW9ucyk7fSIsIlwidXNlIHN0cmljdFwiOy8qKlxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovIC8vIFRoaXMgZmlsZSBpcyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svY3JlYXRlLXJlYWN0LWFwcC9ibG9iLzdiMWEzMmJlNmVjOWY5OWE2YzlhM2M2NjgxM2YzYWMwOWM0NzM2YjkvcGFja2FnZXMvcmVhY3QtZGV2LXV0aWxzL2Zvcm1hdFdlYnBhY2tNZXNzYWdlcy5qc1xuLy8gSXQncyBiZWVuIGVkaXRlZCB0byByZW1vdmUgY2hhbGsgYW5kIENSQS1zcGVjaWZpYyBsb2dpY1xudmFyIGZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbD0nU3ludGF4IGVycm9yOic7ZnVuY3Rpb24gaXNMaWtlbHlBU3ludGF4RXJyb3IobWVzc2FnZSl7cmV0dXJuIG1lc3NhZ2UuaW5kZXhPZihmcmllbmRseVN5bnRheEVycm9yTGFiZWwpIT09LTE7fS8vIENsZWFucyB1cCB3ZWJwYWNrIGVycm9yIG1lc3NhZ2VzLlxuZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShtZXNzYWdlKXt2YXIgbGluZXM9bWVzc2FnZS5zcGxpdCgnXFxuJyk7Ly8gU3RyaXAgV2VicGFjay1hZGRlZCBoZWFkZXJzIG9mZiBlcnJvcnMvd2FybmluZ3Ncbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svYmxvYi9tYXN0ZXIvbGliL01vZHVsZUVycm9yLmpzXG5saW5lcz1saW5lcy5maWx0ZXIobGluZT0+IS9Nb2R1bGUgW0EteiBdK1xcKGZyb20vLnRlc3QobGluZSkpOy8vIFRyYW5zZm9ybSBwYXJzaW5nIGVycm9yIGludG8gc3ludGF4IGVycm9yXG4vLyBUT0RPOiBtb3ZlIHRoaXMgdG8gb3VyIEVTTGludCBmb3JtYXR0ZXI/XG5saW5lcz1saW5lcy5tYXAobGluZT0+e3ZhciBwYXJzaW5nRXJyb3I9L0xpbmUgKFxcZCspOig/OihcXGQrKTopP1xccypQYXJzaW5nIGVycm9yOiAoLispJC8uZXhlYyhsaW5lKTtpZighcGFyc2luZ0Vycm9yKXtyZXR1cm4gbGluZTt9dmFyWyxlcnJvckxpbmUsZXJyb3JDb2x1bW4sZXJyb3JNZXNzYWdlXT1wYXJzaW5nRXJyb3I7cmV0dXJuIGZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbCtcIiBcIitlcnJvck1lc3NhZ2UrXCIgKFwiK2Vycm9yTGluZStcIjpcIitlcnJvckNvbHVtbitcIilcIjt9KTttZXNzYWdlPWxpbmVzLmpvaW4oJ1xcbicpOy8vIFNtb29zaCBzeW50YXggZXJyb3JzIChjb21tb25seSBmb3VuZCBpbiBDU1MpXG5tZXNzYWdlPW1lc3NhZ2UucmVwbGFjZSgvU3ludGF4RXJyb3JcXHMrXFwoKFxcZCspOihcXGQrKVxcKVxccyooLis/KVxcbi9nLGZyaWVuZGx5U3ludGF4RXJyb3JMYWJlbCtcIiAkMyAoJDE6JDIpXFxuXCIpOy8vIENsZWFuIHVwIGV4cG9ydCBlcnJvcnNcbm1lc3NhZ2U9bWVzc2FnZS5yZXBsYWNlKC9eLipleHBvcnQgJyguKz8pJyB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sXCJBdHRlbXB0ZWQgaW1wb3J0IGVycm9yOiAnJDEnIGlzIG5vdCBleHBvcnRlZCBmcm9tICckMicuXCIpO21lc3NhZ2U9bWVzc2FnZS5yZXBsYWNlKC9eLipleHBvcnQgJ2RlZmF1bHQnIFxcKGltcG9ydGVkIGFzICcoLis/KSdcXCkgd2FzIG5vdCBmb3VuZCBpbiAnKC4rPyknLiokL2dtLFwiQXR0ZW1wdGVkIGltcG9ydCBlcnJvcjogJyQyJyBkb2VzIG5vdCBjb250YWluIGEgZGVmYXVsdCBleHBvcnQgKGltcG9ydGVkIGFzICckMScpLlwiKTttZXNzYWdlPW1lc3NhZ2UucmVwbGFjZSgvXi4qZXhwb3J0ICcoLis/KScgXFwoaW1wb3J0ZWQgYXMgJyguKz8pJ1xcKSB3YXMgbm90IGZvdW5kIGluICcoLis/KScuKiQvZ20sXCJBdHRlbXB0ZWQgaW1wb3J0IGVycm9yOiAnJDEnIGlzIG5vdCBleHBvcnRlZCBmcm9tICckMycgKGltcG9ydGVkIGFzICckMicpLlwiKTtsaW5lcz1tZXNzYWdlLnNwbGl0KCdcXG4nKTsvLyBSZW1vdmUgbGVhZGluZyBuZXdsaW5lXG5pZihsaW5lcy5sZW5ndGg+MiYmbGluZXNbMV0udHJpbSgpPT09Jycpe2xpbmVzLnNwbGljZSgxLDEpO30vLyBDbGVhbiB1cCBmaWxlIG5hbWVcbmxpbmVzWzBdPWxpbmVzWzBdLnJlcGxhY2UoL14oLiopIFxcZCs6XFxkKy1cXGQrJC8sJyQxJyk7Ly8gQ2xlYW5zIHVwIHZlcmJvc2UgXCJtb2R1bGUgbm90IGZvdW5kXCIgbWVzc2FnZXMgZm9yIGZpbGVzIGFuZCBwYWNrYWdlcy5cbmlmKGxpbmVzWzFdJiZsaW5lc1sxXS5pbmRleE9mKCdNb2R1bGUgbm90IGZvdW5kOiAnKT09PTApe2xpbmVzPVtsaW5lc1swXSxsaW5lc1sxXS5yZXBsYWNlKCdFcnJvcjogJywnJykucmVwbGFjZSgnTW9kdWxlIG5vdCBmb3VuZDogQ2Fubm90IGZpbmQgZmlsZTonLCdDYW5ub3QgZmluZCBmaWxlOicpXTt9Ly8gQWRkIGhlbHBmdWwgbWVzc2FnZSBmb3IgdXNlcnMgdHJ5aW5nIHRvIHVzZSBTYXNzIGZvciB0aGUgZmlyc3QgdGltZVxuaWYobGluZXNbMV0mJmxpbmVzWzFdLm1hdGNoKC9DYW5ub3QgZmluZCBtb2R1bGUuK25vZGUtc2Fzcy8pKXsvLyAuL2ZpbGUubW9kdWxlLnNjc3MgKDw8bG9hZGVyIGluZm8+PikgPT4gLi9maWxlLm1vZHVsZS5zY3NzXG5saW5lc1swXT1saW5lc1swXS5yZXBsYWNlKC8oLispIFxcKC4rPyg/PVxcP1xcPykuKz9cXCkvLCckMScpO2xpbmVzWzFdPVwiVG8gdXNlIE5leHQuanMnIGJ1aWx0LWluIFNhc3Mgc3VwcG9ydCwgeW91IGZpcnN0IG5lZWQgdG8gaW5zdGFsbCBgc2Fzc2AuXFxuXCI7bGluZXNbMV0rPSdSdW4gYG5wbSBpIHNhc3NgIG9yIGB5YXJuIGFkZCBzYXNzYCBpbnNpZGUgeW91ciB3b3Jrc3BhY2UuXFxuJztsaW5lc1sxXSs9J1xcbkxlYXJuIG1vcmU6IGh0dHBzOi8vZXJyLnNoL25leHQuanMvaW5zdGFsbC1zYXNzJzt9bWVzc2FnZT1saW5lcy5qb2luKCdcXG4nKTsvLyBJbnRlcm5hbCBzdGFja3MgYXJlIGdlbmVyYWxseSB1c2VsZXNzIHNvIHdlIHN0cmlwIHRoZW0uLi4gd2l0aCB0aGVcbi8vIGV4Y2VwdGlvbiBvZiBzdGFja3MgY29udGFpbmluZyBgd2VicGFjazpgIGJlY2F1c2UgdGhleSdyZSBub3JtYWxseVxuLy8gZnJvbSB1c2VyIGNvZGUgZ2VuZXJhdGVkIGJ5IFdlYnBhY2suIEZvciBtb3JlIGluZm9ybWF0aW9uIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHAvcHVsbC8xMDUwXG5tZXNzYWdlPW1lc3NhZ2UucmVwbGFjZSgvXlxccyphdFxccygoPyF3ZWJwYWNrOikuKSo6XFxkKzpcXGQrW1xccyldKihcXG58JCkvZ20sJycpOy8vIGF0IC4uLiAuLi46eDp5XG5tZXNzYWdlPW1lc3NhZ2UucmVwbGFjZSgvXlxccyphdFxcczxhbm9ueW1vdXM+KFxcbnwkKS9nbSwnJyk7Ly8gYXQgPGFub255bW91cz5cbmxpbmVzPW1lc3NhZ2Uuc3BsaXQoJ1xcbicpOy8vIFJlbW92ZSBkdXBsaWNhdGVkIG5ld2xpbmVzXG5saW5lcz1saW5lcy5maWx0ZXIoKGxpbmUsaW5kZXgsYXJyKT0+aW5kZXg9PT0wfHxsaW5lLnRyaW0oKSE9PScnfHxsaW5lLnRyaW0oKSE9PWFycltpbmRleC0xXS50cmltKCkpOy8vIFJlYXNzZW1ibGUgdGhlIG1lc3NhZ2Vcbm1lc3NhZ2U9bGluZXMuam9pbignXFxuJyk7cmV0dXJuIG1lc3NhZ2UudHJpbSgpO31mdW5jdGlvbiBmb3JtYXRXZWJwYWNrTWVzc2FnZXMoanNvbil7dmFyIGZvcm1hdHRlZEVycm9ycz1qc29uLmVycm9ycy5tYXAoZnVuY3Rpb24obWVzc2FnZSl7cmV0dXJuIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSx0cnVlKTt9KTt2YXIgZm9ybWF0dGVkV2FybmluZ3M9anNvbi53YXJuaW5ncy5tYXAoZnVuY3Rpb24obWVzc2FnZSl7cmV0dXJuIGZvcm1hdE1lc3NhZ2UobWVzc2FnZSxmYWxzZSk7fSk7dmFyIHJlc3VsdD17ZXJyb3JzOmZvcm1hdHRlZEVycm9ycyx3YXJuaW5nczpmb3JtYXR0ZWRXYXJuaW5nc307aWYocmVzdWx0LmVycm9ycy5zb21lKGlzTGlrZWx5QVN5bnRheEVycm9yKSl7Ly8gSWYgdGhlcmUgYXJlIGFueSBzeW50YXggZXJyb3JzLCBzaG93IGp1c3QgdGhlbS5cbnJlc3VsdC5lcnJvcnM9cmVzdWx0LmVycm9ycy5maWx0ZXIoaXNMaWtlbHlBU3ludGF4RXJyb3IpO31yZXR1cm4gcmVzdWx0O31tb2R1bGUuZXhwb3J0cz1mb3JtYXRXZWJwYWNrTWVzc2FnZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ9cmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO3ZhciBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZD1yZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkXCIpO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMuZGVmYXVsdD1jb25uZWN0O3ZhciBEZXZPdmVybGF5PV9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCJAbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50XCIpKTt2YXIgX3N0cmlwQW5zaT1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvc3RyaXAtYW5zaVwiKSk7dmFyIF9ldmVudHNvdXJjZT1yZXF1aXJlKFwiLi9ldmVudHNvdXJjZVwiKTt2YXIgX2Zvcm1hdFdlYnBhY2tNZXNzYWdlcz1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Zvcm1hdC13ZWJwYWNrLW1lc3NhZ2VzXCIpKTsvKipcbiAqIE1JVCBMaWNlbnNlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqLyAvLyBUaGlzIGZpbGUgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBDcmVhdGUgUmVhY3QgQXBwIEhNUiBkZXYgY2xpZW50IHRoYXRcbi8vIGNhbiBiZSBmb3VuZCBoZXJlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2NyZWF0ZS1yZWFjdC1hcHAvYmxvYi92My40LjEvcGFja2FnZXMvcmVhY3QtZGV2LXV0aWxzL3dlYnBhY2tIb3REZXZDbGllbnQuanNcbi8vIFRoaXMgYWx0ZXJuYXRpdmUgV2VicGFja0RldlNlcnZlciBjb21iaW5lcyB0aGUgZnVuY3Rpb25hbGl0eSBvZjpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2stZGV2LXNlcnZlci9ibG9iL3dlYnBhY2stMS9jbGllbnQvaW5kZXguanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svYmxvYi93ZWJwYWNrLTEvaG90L2Rldi1zZXJ2ZXIuanNcbi8vIEl0IG9ubHkgc3VwcG9ydHMgdGhlaXIgc2ltcGxlc3QgY29uZmlndXJhdGlvbiAoaG90IHVwZGF0ZXMgb24gc2FtZSBzZXJ2ZXIpLlxuLy8gSXQgbWFrZXMgc29tZSBvcGluaW9uYXRlZCBjaG9pY2VzIG9uIHRvcCwgbGlrZSBhZGRpbmcgYSBzeW50YXggZXJyb3Igb3ZlcmxheVxuLy8gdGhhdCBsb29rcyBzaW1pbGFyIHRvIG91ciBjb25zb2xlIG91dHB1dC4gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgYnk6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2xlbmphbWluL3dlYnBhY2staG90LW1pZGRsZXdhcmVcbnZhciBoYWRSdW50aW1lRXJyb3I9ZmFsc2U7dmFyIGN1c3RvbUhtckV2ZW50SGFuZGxlcjtmdW5jdGlvbiBjb25uZWN0KG9wdGlvbnMpe0Rldk92ZXJsYXkucmVnaXN0ZXIoKTsoMCxfZXZlbnRzb3VyY2UuZ2V0RXZlbnRTb3VyY2VXcmFwcGVyKShvcHRpb25zKS5hZGRNZXNzYWdlTGlzdGVuZXIoZXZlbnQ9PnsvLyBUaGlzIGlzIHRoZSBoZWFydGJlYXQgZXZlbnRcbmlmKGV2ZW50LmRhdGE9PT0nXFx1RDgzRFxcdURDOTMnKXtyZXR1cm47fXRyeXtwcm9jZXNzTWVzc2FnZShldmVudCk7fWNhdGNoKGV4KXtjb25zb2xlLndhcm4oJ0ludmFsaWQgSE1SIG1lc3NhZ2U6ICcrZXZlbnQuZGF0YSsnXFxuJytleCk7fX0pO3JldHVybntzdWJzY3JpYmVUb0htckV2ZW50KGhhbmRsZXIpe2N1c3RvbUhtckV2ZW50SGFuZGxlcj1oYW5kbGVyO30sb25VbnJlY292ZXJhYmxlRXJyb3IoKXtoYWRSdW50aW1lRXJyb3I9dHJ1ZTt9fTt9Ly8gUmVtZW1iZXIgc29tZSBzdGF0ZSByZWxhdGVkIHRvIGhvdCBtb2R1bGUgcmVwbGFjZW1lbnQuXG52YXIgaXNGaXJzdENvbXBpbGF0aW9uPXRydWU7dmFyIG1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2g9bnVsbDt2YXIgaGFzQ29tcGlsZUVycm9ycz1mYWxzZTtmdW5jdGlvbiBjbGVhck91dGRhdGVkRXJyb3JzKCl7Ly8gQ2xlYW4gdXAgb3V0ZGF0ZWQgY29tcGlsZSBlcnJvcnMsIGlmIGFueS5cbmlmKHR5cGVvZiBjb25zb2xlIT09J3VuZGVmaW5lZCcmJnR5cGVvZiBjb25zb2xlLmNsZWFyPT09J2Z1bmN0aW9uJyl7aWYoaGFzQ29tcGlsZUVycm9ycyl7Y29uc29sZS5jbGVhcigpO319fS8vIFN1Y2Nlc3NmdWwgY29tcGlsYXRpb24uXG5mdW5jdGlvbiBoYW5kbGVTdWNjZXNzKCl7Y2xlYXJPdXRkYXRlZEVycm9ycygpO3ZhciBpc0hvdFVwZGF0ZT0haXNGaXJzdENvbXBpbGF0aW9uO2lzRmlyc3RDb21waWxhdGlvbj1mYWxzZTtoYXNDb21waWxlRXJyb3JzPWZhbHNlOy8vIEF0dGVtcHQgdG8gYXBwbHkgaG90IHVwZGF0ZXMgb3IgcmVsb2FkLlxuaWYoaXNIb3RVcGRhdGUpe3RyeUFwcGx5VXBkYXRlcyhmdW5jdGlvbiBvblN1Y2Nlc3NmdWxIb3RVcGRhdGUoaGFzVXBkYXRlcyl7Ly8gT25seSBkaXNtaXNzIGl0IHdoZW4gd2UncmUgc3VyZSBpdCdzIGEgaG90IHVwZGF0ZS5cbi8vIE90aGVyd2lzZSBpdCB3b3VsZCBmbGlja2VyIHJpZ2h0IGJlZm9yZSB0aGUgcmVsb2FkLlxub25GYXN0UmVmcmVzaChoYXNVcGRhdGVzKTt9KTt9fS8vIENvbXBpbGF0aW9uIHdpdGggd2FybmluZ3MgKGUuZy4gRVNMaW50KS5cbmZ1bmN0aW9uIGhhbmRsZVdhcm5pbmdzKHdhcm5pbmdzKXtjbGVhck91dGRhdGVkRXJyb3JzKCk7dmFyIGlzSG90VXBkYXRlPSFpc0ZpcnN0Q29tcGlsYXRpb247aXNGaXJzdENvbXBpbGF0aW9uPWZhbHNlO2hhc0NvbXBpbGVFcnJvcnM9ZmFsc2U7ZnVuY3Rpb24gcHJpbnRXYXJuaW5ncygpey8vIFByaW50IHdhcm5pbmdzIHRvIHRoZSBjb25zb2xlLlxudmFyIGZvcm1hdHRlZD0oMCxfZm9ybWF0V2VicGFja01lc3NhZ2VzLmRlZmF1bHQpKHt3YXJuaW5nczp3YXJuaW5ncyxlcnJvcnM6W119KTtpZih0eXBlb2YgY29uc29sZSE9PSd1bmRlZmluZWQnJiZ0eXBlb2YgY29uc29sZS53YXJuPT09J2Z1bmN0aW9uJyl7Zm9yKHZhciBpPTA7aTxmb3JtYXR0ZWQud2FybmluZ3MubGVuZ3RoO2krKyl7aWYoaT09PTUpe2NvbnNvbGUud2FybignVGhlcmUgd2VyZSBtb3JlIHdhcm5pbmdzIGluIG90aGVyIGZpbGVzLlxcbicrJ1lvdSBjYW4gZmluZCBhIGNvbXBsZXRlIGxvZyBpbiB0aGUgdGVybWluYWwuJyk7YnJlYWs7fWNvbnNvbGUud2FybigoMCxfc3RyaXBBbnNpLmRlZmF1bHQpKGZvcm1hdHRlZC53YXJuaW5nc1tpXSkpO319fXByaW50V2FybmluZ3MoKTsvLyBBdHRlbXB0IHRvIGFwcGx5IGhvdCB1cGRhdGVzIG9yIHJlbG9hZC5cbmlmKGlzSG90VXBkYXRlKXt0cnlBcHBseVVwZGF0ZXMoZnVuY3Rpb24gb25TdWNjZXNzZnVsSG90VXBkYXRlKGhhc1VwZGF0ZXMpey8vIE9ubHkgZGlzbWlzcyBpdCB3aGVuIHdlJ3JlIHN1cmUgaXQncyBhIGhvdCB1cGRhdGUuXG4vLyBPdGhlcndpc2UgaXQgd291bGQgZmxpY2tlciByaWdodCBiZWZvcmUgdGhlIHJlbG9hZC5cbm9uRmFzdFJlZnJlc2goaGFzVXBkYXRlcyk7fSk7fX0vLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cbmZ1bmN0aW9uIGhhbmRsZUVycm9ycyhlcnJvcnMpe2NsZWFyT3V0ZGF0ZWRFcnJvcnMoKTtpc0ZpcnN0Q29tcGlsYXRpb249ZmFsc2U7aGFzQ29tcGlsZUVycm9ycz10cnVlOy8vIFwiTWFzc2FnZVwiIHdlYnBhY2sgbWVzc2FnZXMuXG52YXIgZm9ybWF0dGVkPSgwLF9mb3JtYXRXZWJwYWNrTWVzc2FnZXMuZGVmYXVsdCkoe2Vycm9yczplcnJvcnMsd2FybmluZ3M6W119KTsvLyBPbmx5IHNob3cgdGhlIGZpcnN0IGVycm9yLlxuRGV2T3ZlcmxheS5vbkJ1aWxkRXJyb3IoZm9ybWF0dGVkLmVycm9yc1swXSk7Ly8gQWxzbyBsb2cgdGhlbSB0byB0aGUgY29uc29sZS5cbmlmKHR5cGVvZiBjb25zb2xlIT09J3VuZGVmaW5lZCcmJnR5cGVvZiBjb25zb2xlLmVycm9yPT09J2Z1bmN0aW9uJyl7Zm9yKHZhciBpPTA7aTxmb3JtYXR0ZWQuZXJyb3JzLmxlbmd0aDtpKyspe2NvbnNvbGUuZXJyb3IoKDAsX3N0cmlwQW5zaS5kZWZhdWx0KShmb3JtYXR0ZWQuZXJyb3JzW2ldKSk7fX0vLyBEbyBub3QgYXR0ZW1wdCB0byByZWxvYWQgbm93LlxuLy8gV2Ugd2lsbCByZWxvYWQgb24gbmV4dCBzdWNjZXNzIGluc3RlYWQuXG5pZihwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKXtpZihzZWxmLl9fTkVYVF9ITVJfQ0Ipe3NlbGYuX19ORVhUX0hNUl9DQihmb3JtYXR0ZWQuZXJyb3JzWzBdKTtzZWxmLl9fTkVYVF9ITVJfQ0I9bnVsbDt9fX1mdW5jdGlvbiBvbkZhc3RSZWZyZXNoKGhhc1VwZGF0ZXMpe0Rldk92ZXJsYXkub25CdWlsZE9rKCk7aWYoaGFzVXBkYXRlcyl7RGV2T3ZlcmxheS5vblJlZnJlc2goKTt9Y29uc29sZS5sb2coJ1tGYXN0IFJlZnJlc2hdIGRvbmUnKTt9Ly8gVGhlcmUgaXMgYSBuZXdlciB2ZXJzaW9uIG9mIHRoZSBjb2RlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIGhhbmRsZUF2YWlsYWJsZUhhc2goaGFzaCl7Ly8gVXBkYXRlIGxhc3Qga25vd24gY29tcGlsYXRpb24gaGFzaC5cbm1vc3RSZWNlbnRDb21waWxhdGlvbkhhc2g9aGFzaDt9Ly8gSGFuZGxlIG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cbmZ1bmN0aW9uIHByb2Nlc3NNZXNzYWdlKGUpe3ZhciBvYmo9SlNPTi5wYXJzZShlLmRhdGEpO3N3aXRjaChvYmouYWN0aW9uKXtjYXNlJ2J1aWxkaW5nJzp7Y29uc29sZS5sb2coJ1tGYXN0IFJlZnJlc2hdIHJlYnVpbGRpbmcnKTticmVhazt9Y2FzZSdidWlsdCc6Y2FzZSdzeW5jJzp7aWYob2JqLmhhc2gpe2hhbmRsZUF2YWlsYWJsZUhhc2gob2JqLmhhc2gpO312YXJ7ZXJyb3JzLHdhcm5pbmdzfT1vYmo7dmFyIGhhc0Vycm9ycz1Cb29sZWFuKGVycm9ycyYmZXJyb3JzLmxlbmd0aCk7aWYoaGFzRXJyb3JzKXtyZXR1cm4gaGFuZGxlRXJyb3JzKGVycm9ycyk7fXZhciBoYXNXYXJuaW5ncz1Cb29sZWFuKHdhcm5pbmdzJiZ3YXJuaW5ncy5sZW5ndGgpO2lmKGhhc1dhcm5pbmdzKXtyZXR1cm4gaGFuZGxlV2FybmluZ3Mod2FybmluZ3MpO31yZXR1cm4gaGFuZGxlU3VjY2VzcygpO31kZWZhdWx0OntpZihjdXN0b21IbXJFdmVudEhhbmRsZXIpe2N1c3RvbUhtckV2ZW50SGFuZGxlcihvYmopO2JyZWFrO31icmVhazt9fX0vLyBJcyB0aGVyZSBhIG5ld2VyIHZlcnNpb24gb2YgdGhpcyBjb2RlIGF2YWlsYWJsZT9cbmZ1bmN0aW9uIGlzVXBkYXRlQXZhaWxhYmxlKCl7LyogZ2xvYmFscyBfX3dlYnBhY2tfaGFzaF9fICovIC8vIF9fd2VicGFja19oYXNoX18gaXMgdGhlIGhhc2ggb2YgdGhlIGN1cnJlbnQgY29tcGlsYXRpb24uXG4vLyBJdCdzIGEgZ2xvYmFsIHZhcmlhYmxlIGluamVjdGVkIGJ5IFdlYnBhY2suXG5yZXR1cm4gbW9zdFJlY2VudENvbXBpbGF0aW9uSGFzaCE9PV9fd2VicGFja19oYXNoX187fS8vIFdlYnBhY2sgZGlzYWxsb3dzIHVwZGF0ZXMgaW4gb3RoZXIgc3RhdGVzLlxuZnVuY3Rpb24gY2FuQXBwbHlVcGRhdGVzKCl7cmV0dXJuIG1vZHVsZS5ob3Quc3RhdHVzKCk9PT0naWRsZSc7fWZ1bmN0aW9uIGFmdGVyQXBwbHlVcGRhdGVzKGZuKXtpZihjYW5BcHBseVVwZGF0ZXMoKSl7Zm4oKTt9ZWxzZXtmdW5jdGlvbiBoYW5kbGVyKHN0YXR1cyl7aWYoc3RhdHVzPT09J2lkbGUnKXttb2R1bGUuaG90LnJlbW92ZVN0YXR1c0hhbmRsZXIoaGFuZGxlcik7Zm4oKTt9fW1vZHVsZS5ob3QuYWRkU3RhdHVzSGFuZGxlcihoYW5kbGVyKTt9fS8vIEF0dGVtcHQgdG8gdXBkYXRlIGNvZGUgb24gdGhlIGZseSwgZmFsbCBiYWNrIHRvIGEgaGFyZCByZWxvYWQuXG5mdW5jdGlvbiB0cnlBcHBseVVwZGF0ZXMob25Ib3RVcGRhdGVTdWNjZXNzKXtpZighbW9kdWxlLmhvdCl7Ly8gSG90TW9kdWxlUmVwbGFjZW1lbnRQbHVnaW4gaXMgbm90IGluIFdlYnBhY2sgY29uZmlndXJhdGlvbi5cbmNvbnNvbGUuZXJyb3IoJ0hvdE1vZHVsZVJlcGxhY2VtZW50UGx1Z2luIGlzIG5vdCBpbiBXZWJwYWNrIGNvbmZpZ3VyYXRpb24uJyk7Ly8gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xucmV0dXJuO31pZighaXNVcGRhdGVBdmFpbGFibGUoKXx8IWNhbkFwcGx5VXBkYXRlcygpKXtyZXR1cm47fWZ1bmN0aW9uIGhhbmRsZUFwcGx5VXBkYXRlcyhlcnIsdXBkYXRlZE1vZHVsZXMpe2lmKGVycnx8aGFkUnVudGltZUVycm9yfHwhdXBkYXRlZE1vZHVsZXMpe2lmKGVycil7Y29uc29sZS53YXJuKCdbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkXFxuXFxuJytcIkZhc3QgUmVmcmVzaCB3aWxsIHBlcmZvcm0gYSBmdWxsIHJlbG9hZCB3aGVuIHlvdSBlZGl0IGEgZmlsZSB0aGF0J3MgaW1wb3J0ZWQgYnkgbW9kdWxlcyBvdXRzaWRlIG9mIHRoZSBSZWFjdCB0cmVlLlxcblwiKydZb3UgbWlnaHQgaGF2ZSBhIGZpbGUgd2hpY2ggcmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBidXQgYWxzbyBleHBvcnRzIGEgdmFsdWUgdGhhdCBpcyBpbXBvcnRlZCBieSBhIG5vbi1SZWFjdCBjb21wb25lbnQuXFxuJysnQ29uc2lkZXIgbWlncmF0aW5nIHRoZSBub24tUmVhY3QgY29tcG9uZW50IGV4cG9ydCB0byBhIHNlcGFyYXRlIGZpbGUgYW5kIGltcG9ydGluZyBpdCBpbnRvIGJvdGggZmlsZXMuXFxuXFxuJysnSXQgaXMgYWxzbyBwb3NzaWJsZSB5b3UgYXJlIHVzaW5nIGNsYXNzIGNvbXBvbmVudHMgYXQgdGhlIHRvcC1sZXZlbCBvZiB5b3VyIGFwcGxpY2F0aW9uLCB3aGljaCBkaXNhYmxlcyBGYXN0IFJlZnJlc2guXFxuJysnRmFzdCBSZWZyZXNoIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBmdW5jdGlvbiBjb21wb25lbnQgaW4geW91ciBSZWFjdCB0cmVlLicpO31lbHNlIGlmKGhhZFJ1bnRpbWVFcnJvcil7Y29uc29sZS53YXJuKCdbRmFzdCBSZWZyZXNoXSBwZXJmb3JtaW5nIGZ1bGwgcmVsb2FkIGJlY2F1c2UgeW91ciBhcHBsaWNhdGlvbiBoYWQgYW4gdW5yZWNvdmVyYWJsZSBlcnJvcicpO313aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7cmV0dXJuO312YXIgaGFzVXBkYXRlcz1Cb29sZWFuKHVwZGF0ZWRNb2R1bGVzLmxlbmd0aCk7aWYodHlwZW9mIG9uSG90VXBkYXRlU3VjY2Vzcz09PSdmdW5jdGlvbicpey8vIE1heWJlIHdlIHdhbnQgdG8gZG8gc29tZXRoaW5nLlxub25Ib3RVcGRhdGVTdWNjZXNzKGhhc1VwZGF0ZXMpO31pZihpc1VwZGF0ZUF2YWlsYWJsZSgpKXsvLyBXaGlsZSB3ZSB3ZXJlIHVwZGF0aW5nLCB0aGVyZSB3YXMgYSBuZXcgdXBkYXRlISBEbyBpdCBhZ2Fpbi5cbnRyeUFwcGx5VXBkYXRlcyhoYXNVcGRhdGVzP3VuZGVmaW5lZDpvbkhvdFVwZGF0ZVN1Y2Nlc3MpO31lbHNle2lmKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpe2FmdGVyQXBwbHlVcGRhdGVzKCgpPT57aWYoc2VsZi5fX05FWFRfSE1SX0NCKXtzZWxmLl9fTkVYVF9ITVJfQ0IoKTtzZWxmLl9fTkVYVF9ITVJfQ0I9bnVsbDt9fSk7fX19Ly8gaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9hcGkvaG90LW1vZHVsZS1yZXBsYWNlbWVudC8jY2hlY2tcbm1vZHVsZS5ob3QuY2hlY2soLyogYXV0b0FwcGx5ICovdHJ1ZSkudGhlbih1cGRhdGVkTW9kdWxlcz0+e2hhbmRsZUFwcGx5VXBkYXRlcyhudWxsLHVwZGF0ZWRNb2R1bGVzKTt9LGVycj0+e2hhbmRsZUFwcGx5VXBkYXRlcyhlcnIsbnVsbCk7fSk7fSIsIlwidXNlIHN0cmljdFwiO3ZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0PXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmRlZmF1bHQ9dm9pZCAwO3ZhciBfdW5mZXRjaD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJuZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3VuZmV0Y2hcIikpOy8qIGVzbGludC1kaXNhYmxlICovIC8vIEltcHJvdmVkIHZlcnNpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL1lhZmZsZS9FdmVudFNvdXJjZS9cbi8vIEF2YWlsYWJsZSB1bmRlciBNSVQgTGljZW5zZSAoTUlUKVxuLy8gT25seSB0cmllcyB0byBzdXBwb3J0IElFMTEgYW5kIG5vdGhpbmcgYmVsb3dcbnZhciBkb2N1bWVudD13aW5kb3cuZG9jdW1lbnQ7dmFyIFJlc3BvbnNlPXdpbmRvdy5SZXNwb25zZTt2YXIgVGV4dERlY29kZXI9d2luZG93LlRleHREZWNvZGVyO3ZhciBUZXh0RW5jb2Rlcj13aW5kb3cuVGV4dEVuY29kZXI7dmFyIEFib3J0Q29udHJvbGxlcj13aW5kb3cuQWJvcnRDb250cm9sbGVyO2lmKEFib3J0Q29udHJvbGxlcj09dW5kZWZpbmVkKXtBYm9ydENvbnRyb2xsZXI9ZnVuY3Rpb24gQWJvcnRDb250cm9sbGVyKCl7dGhpcy5zaWduYWw9bnVsbDt0aGlzLmFib3J0PWZ1bmN0aW9uKCl7fTt9O31mdW5jdGlvbiBUZXh0RGVjb2RlclBvbHlmaWxsKCl7dGhpcy5iaXRzTmVlZGVkPTA7dGhpcy5jb2RlUG9pbnQ9MDt9VGV4dERlY29kZXJQb2x5ZmlsbC5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKG9jdGV0cyl7ZnVuY3Rpb24gdmFsaWQoY29kZVBvaW50LHNoaWZ0LG9jdGV0c0NvdW50KXtpZihvY3RldHNDb3VudD09PTEpe3JldHVybiBjb2RlUG9pbnQ+PTB4MDA4MD4+c2hpZnQmJmNvZGVQb2ludDw8c2hpZnQ8PTB4MDdmZjt9aWYob2N0ZXRzQ291bnQ9PT0yKXtyZXR1cm4gY29kZVBvaW50Pj0weDA4MDA+PnNoaWZ0JiZjb2RlUG9pbnQ8PHNoaWZ0PD0weGQ3ZmZ8fGNvZGVQb2ludD49MHhlMDAwPj5zaGlmdCYmY29kZVBvaW50PDxzaGlmdDw9MHhmZmZmO31pZihvY3RldHNDb3VudD09PTMpe3JldHVybiBjb2RlUG9pbnQ+PTB4MDEwMDAwPj5zaGlmdCYmY29kZVBvaW50PDxzaGlmdDw9MHgxMGZmZmY7fXRocm93IG5ldyBFcnJvcigpO31mdW5jdGlvbiBvY3RldHNDb3VudChiaXRzTmVlZGVkLGNvZGVQb2ludCl7aWYoYml0c05lZWRlZD09PTYqMSl7cmV0dXJuIGNvZGVQb2ludD4+Nj4xNT8zOmNvZGVQb2ludD4zMT8yOjE7fWlmKGJpdHNOZWVkZWQ9PT02KjIpe3JldHVybiBjb2RlUG9pbnQ+MTU/MzoyO31pZihiaXRzTmVlZGVkPT09NiozKXtyZXR1cm4gMzt9dGhyb3cgbmV3IEVycm9yKCk7fXZhciBSRVBMQUNFUj0weGZmZmQ7dmFyIHN0cmluZz0nJzt2YXIgYml0c05lZWRlZD10aGlzLmJpdHNOZWVkZWQ7dmFyIGNvZGVQb2ludD10aGlzLmNvZGVQb2ludDtmb3IodmFyIGk9MDtpPG9jdGV0cy5sZW5ndGg7aSs9MSl7dmFyIG9jdGV0PW9jdGV0c1tpXTtpZihiaXRzTmVlZGVkIT09MCl7aWYob2N0ZXQ8MTI4fHxvY3RldD4xOTF8fCF2YWxpZChjb2RlUG9pbnQ8PDZ8b2N0ZXQmNjMsYml0c05lZWRlZC02LG9jdGV0c0NvdW50KGJpdHNOZWVkZWQsY29kZVBvaW50KSkpe2JpdHNOZWVkZWQ9MDtjb2RlUG9pbnQ9UkVQTEFDRVI7c3RyaW5nKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7fX1pZihiaXRzTmVlZGVkPT09MCl7aWYob2N0ZXQ+PTAmJm9jdGV0PD0xMjcpe2JpdHNOZWVkZWQ9MDtjb2RlUG9pbnQ9b2N0ZXQ7fWVsc2UgaWYob2N0ZXQ+PTE5MiYmb2N0ZXQ8PTIyMyl7Yml0c05lZWRlZD02KjE7Y29kZVBvaW50PW9jdGV0JjMxO31lbHNlIGlmKG9jdGV0Pj0yMjQmJm9jdGV0PD0yMzkpe2JpdHNOZWVkZWQ9NioyO2NvZGVQb2ludD1vY3RldCYxNTt9ZWxzZSBpZihvY3RldD49MjQwJiZvY3RldDw9MjQ3KXtiaXRzTmVlZGVkPTYqMztjb2RlUG9pbnQ9b2N0ZXQmNzt9ZWxzZXtiaXRzTmVlZGVkPTA7Y29kZVBvaW50PVJFUExBQ0VSO31pZihiaXRzTmVlZGVkIT09MCYmIXZhbGlkKGNvZGVQb2ludCxiaXRzTmVlZGVkLG9jdGV0c0NvdW50KGJpdHNOZWVkZWQsY29kZVBvaW50KSkpe2JpdHNOZWVkZWQ9MDtjb2RlUG9pbnQ9UkVQTEFDRVI7fX1lbHNle2JpdHNOZWVkZWQtPTY7Y29kZVBvaW50PWNvZGVQb2ludDw8NnxvY3RldCY2Mzt9aWYoYml0c05lZWRlZD09PTApe2lmKGNvZGVQb2ludDw9MHhmZmZmKXtzdHJpbmcrPVN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTt9ZWxzZXtzdHJpbmcrPVN0cmluZy5mcm9tQ2hhckNvZGUoMHhkODAwKyhjb2RlUG9pbnQtMHhmZmZmLTE+PjEwKSk7c3RyaW5nKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZGMwMCsoY29kZVBvaW50LTB4ZmZmZi0xJjB4M2ZmKSk7fX19dGhpcy5iaXRzTmVlZGVkPWJpdHNOZWVkZWQ7dGhpcy5jb2RlUG9pbnQ9Y29kZVBvaW50O3JldHVybiBzdHJpbmc7fTsvLyBGaXJlZm94IDwgMzggdGhyb3dzIGFuIGVycm9yIHdpdGggc3RyZWFtIG9wdGlvblxudmFyIHN1cHBvcnRzU3RyZWFtT3B0aW9uPWZ1bmN0aW9uIHN1cHBvcnRzU3RyZWFtT3B0aW9uKCl7dHJ5e3JldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCd0ZXN0Jykse3N0cmVhbTp0cnVlfSk9PT0ndGVzdCc7fWNhdGNoKGVycm9yKXtjb25zb2xlLmxvZyhlcnJvcik7fXJldHVybiBmYWxzZTt9Oy8vIElFLCBFZGdlXG5pZihUZXh0RGVjb2Rlcj09dW5kZWZpbmVkfHxUZXh0RW5jb2Rlcj09dW5kZWZpbmVkfHwhc3VwcG9ydHNTdHJlYW1PcHRpb24oKSl7VGV4dERlY29kZXI9VGV4dERlY29kZXJQb2x5ZmlsbDt9dmFyIGs9ZnVuY3Rpb24gaygpe307ZnVuY3Rpb24gWEhSV3JhcHBlcih4aHIpe3RoaXMud2l0aENyZWRlbnRpYWxzPWZhbHNlO3RoaXMucmVzcG9uc2VUeXBlPScnO3RoaXMucmVhZHlTdGF0ZT0wO3RoaXMuc3RhdHVzPTA7dGhpcy5zdGF0dXNUZXh0PScnO3RoaXMucmVzcG9uc2VUZXh0PScnO3RoaXMub25wcm9ncmVzcz1rO3RoaXMub25yZWFkeXN0YXRlY2hhbmdlPWs7dGhpcy5fY29udGVudFR5cGU9Jyc7dGhpcy5feGhyPXhocjt0aGlzLl9zZW5kVGltZW91dD0wO3RoaXMuX2Fib3J0PWs7fVhIUldyYXBwZXIucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24obWV0aG9kLHVybCl7dGhpcy5fYWJvcnQodHJ1ZSk7dmFyIHRoYXQ9dGhpczt2YXIgeGhyPXRoaXMuX3hocjt2YXIgc3RhdGU9MTt2YXIgdGltZW91dD0wO3RoaXMuX2Fib3J0PWZ1bmN0aW9uKHNpbGVudCl7aWYodGhhdC5fc2VuZFRpbWVvdXQhPT0wKXtjbGVhclRpbWVvdXQodGhhdC5fc2VuZFRpbWVvdXQpO3RoYXQuX3NlbmRUaW1lb3V0PTA7fWlmKHN0YXRlPT09MXx8c3RhdGU9PT0yfHxzdGF0ZT09PTMpe3N0YXRlPTQ7eGhyLm9ubG9hZD1rO3hoci5vbmVycm9yPWs7eGhyLm9uYWJvcnQ9azt4aHIub25wcm9ncmVzcz1rO3hoci5vbnJlYWR5c3RhdGVjaGFuZ2U9azsvLyBJRSA4IC0gOTogWERvbWFpblJlcXVlc3QjYWJvcnQoKSBkb2VzIG5vdCBmaXJlIGFueSBldmVudFxuLy8gT3BlcmEgPCAxMDogWE1MSHR0cFJlcXVlc3QjYWJvcnQoKSBkb2VzIG5vdCBmaXJlIGFueSBldmVudFxueGhyLmFib3J0KCk7aWYodGltZW91dCE9PTApe2NsZWFyVGltZW91dCh0aW1lb3V0KTt0aW1lb3V0PTA7fWlmKCFzaWxlbnQpe3RoYXQucmVhZHlTdGF0ZT00O3RoYXQub25yZWFkeXN0YXRlY2hhbmdlKCk7fX1zdGF0ZT0wO307dmFyIG9uU3RhcnQ9ZnVuY3Rpb24gb25TdGFydCgpe2lmKHN0YXRlPT09MSl7Ly8gc3RhdGUgPSAyO1xudmFyIHN0YXR1cz0wO3ZhciBzdGF0dXNUZXh0PScnO3ZhciBjb250ZW50VHlwZT11bmRlZmluZWQ7aWYoISgnY29udGVudFR5cGUnaW4geGhyKSl7dHJ5e3N0YXR1cz14aHIuc3RhdHVzO3N0YXR1c1RleHQ9eGhyLnN0YXR1c1RleHQ7Y29udGVudFR5cGU9eGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTt9Y2F0Y2goZXJyb3Ipey8vIElFIDwgMTAgdGhyb3dzIGV4Y2VwdGlvbiBmb3IgYHhoci5zdGF0dXNgIHdoZW4geGhyLnJlYWR5U3RhdGUgPT09IDIgfHwgeGhyLnJlYWR5U3RhdGUgPT09IDNcbi8vIE9wZXJhIDwgMTEgdGhyb3dzIGV4Y2VwdGlvbiBmb3IgYHhoci5zdGF0dXNgIHdoZW4geGhyLnJlYWR5U3RhdGUgPT09IDJcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTEyMVxuc3RhdHVzPTA7c3RhdHVzVGV4dD0nJztjb250ZW50VHlwZT11bmRlZmluZWQ7Ly8gRmlyZWZveCA8IDE0LCBDaHJvbWUgPywgU2FmYXJpID9cbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTY1OFxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTc3ODU0XG59fWVsc2V7c3RhdHVzPTIwMDtzdGF0dXNUZXh0PSdPSyc7Y29udGVudFR5cGU9eGhyLmNvbnRlbnRUeXBlO31pZihzdGF0dXMhPT0wKXtzdGF0ZT0yO3RoYXQucmVhZHlTdGF0ZT0yO3RoYXQuc3RhdHVzPXN0YXR1czt0aGF0LnN0YXR1c1RleHQ9c3RhdHVzVGV4dDt0aGF0Ll9jb250ZW50VHlwZT1jb250ZW50VHlwZTt0aGF0Lm9ucmVhZHlzdGF0ZWNoYW5nZSgpO319fTt2YXIgb25Qcm9ncmVzcz1mdW5jdGlvbiBvblByb2dyZXNzKCl7b25TdGFydCgpO2lmKHN0YXRlPT09Mnx8c3RhdGU9PT0zKXtzdGF0ZT0zO3ZhciByZXNwb25zZVRleHQ9Jyc7dHJ5e3Jlc3BvbnNlVGV4dD14aHIucmVzcG9uc2VUZXh0O31jYXRjaChlcnJvcil7Ly8gSUUgOCAtIDkgd2l0aCBYTUxIdHRwUmVxdWVzdFxufXRoYXQucmVhZHlTdGF0ZT0zO3RoYXQucmVzcG9uc2VUZXh0PXJlc3BvbnNlVGV4dDt0aGF0Lm9ucHJvZ3Jlc3MoKTt9fTt2YXIgb25GaW5pc2g9ZnVuY3Rpb24gb25GaW5pc2goKXsvLyBGaXJlZm94IDUyIGZpcmVzIFwicmVhZHlzdGF0ZWNoYW5nZVwiICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkgd2l0aG91dCBmaW5hbCBcInJlYWR5c3RhdGVjaGFuZ2VcIiAoeGhyLnJlYWR5U3RhdGUgPT09IDMpXG4vLyBJRSA4IGZpcmVzIFwib25sb2FkXCIgd2l0aG91dCBcIm9ucHJvZ3Jlc3NcIlxub25Qcm9ncmVzcygpO2lmKHN0YXRlPT09MXx8c3RhdGU9PT0yfHxzdGF0ZT09PTMpe3N0YXRlPTQ7aWYodGltZW91dCE9PTApe2NsZWFyVGltZW91dCh0aW1lb3V0KTt0aW1lb3V0PTA7fXRoYXQucmVhZHlTdGF0ZT00O3RoYXQub25yZWFkeXN0YXRlY2hhbmdlKCk7fX07dmFyIG9uUmVhZHlTdGF0ZUNoYW5nZT1mdW5jdGlvbiBvblJlYWR5U3RhdGVDaGFuZ2UoKXtpZih4aHIhPXVuZGVmaW5lZCl7Ly8gT3BlcmEgMTJcbmlmKHhoci5yZWFkeVN0YXRlPT09NCl7b25GaW5pc2goKTt9ZWxzZSBpZih4aHIucmVhZHlTdGF0ZT09PTMpe29uUHJvZ3Jlc3MoKTt9ZWxzZSBpZih4aHIucmVhZHlTdGF0ZT09PTIpe29uU3RhcnQoKTt9fX07dmFyIG9uVGltZW91dD1mdW5jdGlvbiBvblRpbWVvdXQoKXt0aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtvblRpbWVvdXQoKTt9LDUwMCk7aWYoeGhyLnJlYWR5U3RhdGU9PT0zKXtvblByb2dyZXNzKCk7fX07Ly8gWERvbWFpblJlcXVlc3QjYWJvcnQgcmVtb3ZlcyBvbnByb2dyZXNzLCBvbmVycm9yLCBvbmxvYWRcbnhoci5vbmxvYWQ9b25GaW5pc2g7eGhyLm9uZXJyb3I9b25GaW5pc2g7Ly8gaW1wcm9wZXIgZml4IHRvIG1hdGNoIEZpcmVmb3ggYmVoYXZpb3VyLCBidXQgaXQgaXMgYmV0dGVyIHRoYW4ganVzdCBpZ25vcmUgYWJvcnRcbi8vIHNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03Njg1OTZcbi8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTg4MDIwMFxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE1MzU3MFxuLy8gSUUgOCBmaXJlcyBcIm9ubG9hZFwiIHdpdGhvdXQgXCJvbnByb2dyZXNzXG54aHIub25hYm9ydD1vbkZpbmlzaDsvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03MzY3MjNcbmlmKCEoJ3NlbmRBc0JpbmFyeSdpbiBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUpJiYhKCdtb3pBbm9uJ2luIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZSkpe3hoci5vbnByb2dyZXNzPW9uUHJvZ3Jlc3M7fS8vIElFIDggLSA5IChYTUxIVFRQUmVxdWVzdClcbi8vIE9wZXJhIDwgMTJcbi8vIEZpcmVmb3ggPCAzLjVcbi8vIEZpcmVmb3ggMy41IC0gMy42IC0gPyA8IDkuMFxuLy8gb25wcm9ncmVzcyBpcyBub3QgZmlyZWQgc29tZXRpbWVzIG9yIGRlbGF5ZWRcbi8vIHNlZSBhbHNvICM2NFxueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZT1vblJlYWR5U3RhdGVDaGFuZ2U7aWYoJ2NvbnRlbnRUeXBlJ2luIHhocil7dXJsKz0odXJsLmluZGV4T2YoJz8nKT09PS0xPyc/JzonJicpKydwYWRkaW5nPXRydWUnO314aHIub3BlbihtZXRob2QsdXJsLHRydWUpO2lmKCdyZWFkeVN0YXRlJ2luIHhocil7Ly8gd29ya2Fyb3VuZCBmb3IgT3BlcmEgMTIgaXNzdWUgd2l0aCBcInByb2dyZXNzXCIgZXZlbnRzXG4vLyAjOTFcbnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe29uVGltZW91dCgpO30sMCk7fX07WEhSV3JhcHBlci5wcm90b3R5cGUuYWJvcnQ9ZnVuY3Rpb24oKXt0aGlzLl9hYm9ydChmYWxzZSk7fTtYSFJXcmFwcGVyLnByb3RvdHlwZS5nZXRSZXNwb25zZUhlYWRlcj1mdW5jdGlvbihuYW1lKXtyZXR1cm4gdGhpcy5fY29udGVudFR5cGU7fTtYSFJXcmFwcGVyLnByb3RvdHlwZS5zZXRSZXF1ZXN0SGVhZGVyPWZ1bmN0aW9uKG5hbWUsdmFsdWUpe3ZhciB4aHI9dGhpcy5feGhyO2lmKCdzZXRSZXF1ZXN0SGVhZGVyJ2luIHhocil7eGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSx2YWx1ZSk7fX07WEhSV3JhcHBlci5wcm90b3R5cGUuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3hoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMhPXVuZGVmaW5lZD90aGlzLl94aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk6Jyc7fTtYSFJXcmFwcGVyLnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKCl7Ly8gbG9hZGluZyBpbmRpY2F0b3IgaW4gU2FmYXJpIDwgPyAoNiksIENocm9tZSA8IDE0LCBGaXJlZm94XG5pZighKCdvbnRpbWVvdXQnaW4gWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlKSYmZG9jdW1lbnQhPXVuZGVmaW5lZCYmZG9jdW1lbnQucmVhZHlTdGF0ZSE9dW5kZWZpbmVkJiZkb2N1bWVudC5yZWFkeVN0YXRlIT09J2NvbXBsZXRlJyl7dmFyIHRoYXQ9dGhpczt0aGF0Ll9zZW5kVGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhhdC5fc2VuZFRpbWVvdXQ9MDt0aGF0LnNlbmQoKTt9LDQpO3JldHVybjt9dmFyIHhocj10aGlzLl94aHI7Ly8gd2l0aENyZWRlbnRpYWxzIHNob3VsZCBiZSBzZXQgYWZ0ZXIgXCJvcGVuXCIgZm9yIFNhZmFyaSBhbmQgQ2hyb21lICg8IDE5ID8pXG54aHIud2l0aENyZWRlbnRpYWxzPXRoaXMud2l0aENyZWRlbnRpYWxzO3hoci5yZXNwb25zZVR5cGU9dGhpcy5yZXNwb25zZVR5cGU7dHJ5ey8vIHhoci5zZW5kKCk7IHRocm93cyBcIk5vdCBlbm91Z2ggYXJndW1lbnRzXCIgaW4gRmlyZWZveCAzLjBcbnhoci5zZW5kKHVuZGVmaW5lZCk7fWNhdGNoKGVycm9yMSl7Ly8gU2FmYXJpIDUuMS43LCBPcGVyYSAxMlxudGhyb3cgZXJyb3IxO319O2Z1bmN0aW9uIHRvTG93ZXJDYXNlKG5hbWUpe3JldHVybiBuYW1lLnJlcGxhY2UoL1tBLVpdL2csZnVuY3Rpb24oYyl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYy5jaGFyQ29kZUF0KDApKzB4MjApO30pO31mdW5jdGlvbiBIZWFkZXJzUG9seWZpbGwoYWxsKXsvLyBHZXQgaGVhZGVyczogaW1wbGVtZW50ZWQgYWNjb3JkaW5nIHRvIG1vemlsbGEncyBleGFtcGxlIGNvZGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9nZXRBbGxSZXNwb25zZUhlYWRlcnMjRXhhbXBsZVxudmFyIG1hcD1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhcnJheT1hbGwuc3BsaXQoJ1xcclxcbicpO2Zvcih2YXIgaT0wO2k8YXJyYXkubGVuZ3RoO2krPTEpe3ZhciBsaW5lPWFycmF5W2ldO3ZhciBwYXJ0cz1saW5lLnNwbGl0KCc6ICcpO3ZhciBuYW1lPXBhcnRzLnNoaWZ0KCk7dmFyIHZhbHVlPXBhcnRzLmpvaW4oJzogJyk7bWFwW3RvTG93ZXJDYXNlKG5hbWUpXT12YWx1ZTt9dGhpcy5fbWFwPW1hcDt9SGVhZGVyc1BvbHlmaWxsLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24obmFtZSl7cmV0dXJuIHRoaXMuX21hcFt0b0xvd2VyQ2FzZShuYW1lKV07fTtmdW5jdGlvbiBYSFJUcmFuc3BvcnQoKXt9WEhSVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKHhocixvblN0YXJ0Q2FsbGJhY2ssb25Qcm9ncmVzc0NhbGxiYWNrLG9uRmluaXNoQ2FsbGJhY2ssdXJsLHdpdGhDcmVkZW50aWFscyxoZWFkZXJzKXt4aHIub3BlbignR0VUJyx1cmwpO3ZhciBvZmZzZXQ9MDt4aHIub25wcm9ncmVzcz1mdW5jdGlvbigpe3ZhciByZXNwb25zZVRleHQ9eGhyLnJlc3BvbnNlVGV4dDt2YXIgY2h1bms9cmVzcG9uc2VUZXh0LnNsaWNlKG9mZnNldCk7b2Zmc2V0Kz1jaHVuay5sZW5ndGg7b25Qcm9ncmVzc0NhbGxiYWNrKGNodW5rKTt9O3hoci5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZih4aHIucmVhZHlTdGF0ZT09PTIpe3ZhciBzdGF0dXM9eGhyLnN0YXR1czt2YXIgc3RhdHVzVGV4dD14aHIuc3RhdHVzVGV4dDt2YXIgY29udGVudFR5cGU9eGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTt2YXIgaGVhZGVycz14aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7b25TdGFydENhbGxiYWNrKHN0YXR1cyxzdGF0dXNUZXh0LGNvbnRlbnRUeXBlLG5ldyBIZWFkZXJzUG9seWZpbGwoaGVhZGVycyksZnVuY3Rpb24oKXt4aHIuYWJvcnQoKTt9KTt9ZWxzZSBpZih4aHIucmVhZHlTdGF0ZT09PTQpe29uRmluaXNoQ2FsbGJhY2soKTt9fTt4aHIud2l0aENyZWRlbnRpYWxzPXdpdGhDcmVkZW50aWFsczt4aHIucmVzcG9uc2VUeXBlPSd0ZXh0Jztmb3IodmFyIG5hbWUgaW4gaGVhZGVycyl7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsbmFtZSkpe3hoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsaGVhZGVyc1tuYW1lXSk7fX14aHIuc2VuZCgpO307ZnVuY3Rpb24gSGVhZGVyc1dyYXBwZXIoaGVhZGVycyl7dGhpcy5faGVhZGVycz1oZWFkZXJzO31IZWFkZXJzV3JhcHBlci5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKG5hbWUpe3JldHVybiB0aGlzLl9oZWFkZXJzLmdldChuYW1lKTt9O2Z1bmN0aW9uIEZldGNoVHJhbnNwb3J0KCl7fUZldGNoVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKHhocixvblN0YXJ0Q2FsbGJhY2ssb25Qcm9ncmVzc0NhbGxiYWNrLG9uRmluaXNoQ2FsbGJhY2ssdXJsLHdpdGhDcmVkZW50aWFscyxoZWFkZXJzKXt2YXIgY29udHJvbGxlcj1uZXcgQWJvcnRDb250cm9sbGVyKCk7dmFyIHNpZ25hbD1jb250cm9sbGVyLnNpZ25hbDsvLyBzZWUgIzEyMFxudmFyIHRleHREZWNvZGVyPW5ldyBUZXh0RGVjb2RlcigpOygwLF91bmZldGNoLmRlZmF1bHQpKHVybCx7aGVhZGVyczpoZWFkZXJzLGNyZWRlbnRpYWxzOndpdGhDcmVkZW50aWFscz8naW5jbHVkZSc6J3NhbWUtb3JpZ2luJyxzaWduYWw6c2lnbmFsLGNhY2hlOiduby1zdG9yZSd9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXt2YXIgcmVhZGVyPXJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7b25TdGFydENhbGxiYWNrKHJlc3BvbnNlLnN0YXR1cyxyZXNwb25zZS5zdGF0dXNUZXh0LHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSxuZXcgSGVhZGVyc1dyYXBwZXIocmVzcG9uc2UuaGVhZGVycyksZnVuY3Rpb24oKXtjb250cm9sbGVyLmFib3J0KCk7cmVhZGVyLmNhbmNlbCgpO30pO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCl7dmFyIHJlYWROZXh0Q2h1bms9ZnVuY3Rpb24gcmVhZE5leHRDaHVuaygpe3JlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbihyZXN1bHQpe2lmKHJlc3VsdC5kb25lKXsvLyBOb3RlOiBieXRlcyBpbiB0ZXh0RGVjb2RlciBhcmUgaWdub3JlZFxucmVzb2x2ZSh1bmRlZmluZWQpO31lbHNle3ZhciBjaHVuaz10ZXh0RGVjb2Rlci5kZWNvZGUocmVzdWx0LnZhbHVlLHtzdHJlYW06dHJ1ZX0pO29uUHJvZ3Jlc3NDYWxsYmFjayhjaHVuayk7cmVhZE5leHRDaHVuaygpO319KVsnY2F0Y2gnXShmdW5jdGlvbihlcnJvcil7cmVqZWN0KGVycm9yKTt9KTt9O3JlYWROZXh0Q2h1bmsoKTt9KTt9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7b25GaW5pc2hDYWxsYmFjaygpO3JldHVybiByZXN1bHQ7fSxmdW5jdGlvbihlcnJvcil7b25GaW5pc2hDYWxsYmFjaygpO3JldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7fSk7fTtmdW5jdGlvbiBFdmVudFRhcmdldCgpe3RoaXMuX2xpc3RlbmVycz1PYmplY3QuY3JlYXRlKG51bGwpO31mdW5jdGlvbiB0aHJvd0Vycm9yKGUpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0aHJvdyBlO30sMCk7fUV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50PWZ1bmN0aW9uKGV2ZW50KXtldmVudC50YXJnZXQ9dGhpczt2YXIgdHlwZUxpc3RlbmVycz10aGlzLl9saXN0ZW5lcnNbZXZlbnQudHlwZV07aWYodHlwZUxpc3RlbmVycyE9dW5kZWZpbmVkKXt2YXIgbGVuZ3RoPXR5cGVMaXN0ZW5lcnMubGVuZ3RoO2Zvcih2YXIgaT0wO2k8bGVuZ3RoO2krPTEpe3ZhciBsaXN0ZW5lcj10eXBlTGlzdGVuZXJzW2ldO3RyeXtpZih0eXBlb2YgbGlzdGVuZXIuaGFuZGxlRXZlbnQ9PT0nZnVuY3Rpb24nKXtsaXN0ZW5lci5oYW5kbGVFdmVudChldmVudCk7fWVsc2V7bGlzdGVuZXIuY2FsbCh0aGlzLGV2ZW50KTt9fWNhdGNoKGUpe3Rocm93RXJyb3IoZSk7fX19fTtFdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbih0eXBlLGxpc3RlbmVyKXt0eXBlPVN0cmluZyh0eXBlKTt2YXIgbGlzdGVuZXJzPXRoaXMuX2xpc3RlbmVyczt2YXIgdHlwZUxpc3RlbmVycz1saXN0ZW5lcnNbdHlwZV07aWYodHlwZUxpc3RlbmVycz09dW5kZWZpbmVkKXt0eXBlTGlzdGVuZXJzPVtdO2xpc3RlbmVyc1t0eXBlXT10eXBlTGlzdGVuZXJzO312YXIgZm91bmQ9ZmFsc2U7Zm9yKHZhciBpPTA7aTx0eXBlTGlzdGVuZXJzLmxlbmd0aDtpKz0xKXtpZih0eXBlTGlzdGVuZXJzW2ldPT09bGlzdGVuZXIpe2ZvdW5kPXRydWU7fX1pZighZm91bmQpe3R5cGVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7fX07RXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24odHlwZSxsaXN0ZW5lcil7dHlwZT1TdHJpbmcodHlwZSk7dmFyIGxpc3RlbmVycz10aGlzLl9saXN0ZW5lcnM7dmFyIHR5cGVMaXN0ZW5lcnM9bGlzdGVuZXJzW3R5cGVdO2lmKHR5cGVMaXN0ZW5lcnMhPXVuZGVmaW5lZCl7dmFyIGZpbHRlcmVkPVtdO2Zvcih2YXIgaT0wO2k8dHlwZUxpc3RlbmVycy5sZW5ndGg7aSs9MSl7aWYodHlwZUxpc3RlbmVyc1tpXSE9PWxpc3RlbmVyKXtmaWx0ZXJlZC5wdXNoKHR5cGVMaXN0ZW5lcnNbaV0pO319aWYoZmlsdGVyZWQubGVuZ3RoPT09MCl7ZGVsZXRlIGxpc3RlbmVyc1t0eXBlXTt9ZWxzZXtsaXN0ZW5lcnNbdHlwZV09ZmlsdGVyZWQ7fX19O2Z1bmN0aW9uIEV2ZW50KHR5cGUpe3RoaXMudHlwZT10eXBlO3RoaXMudGFyZ2V0PXVuZGVmaW5lZDt9ZnVuY3Rpb24gTWVzc2FnZUV2ZW50KHR5cGUsb3B0aW9ucyl7RXZlbnQuY2FsbCh0aGlzLHR5cGUpO3RoaXMuZGF0YT1vcHRpb25zLmRhdGE7dGhpcy5sYXN0RXZlbnRJZD1vcHRpb25zLmxhc3RFdmVudElkO31NZXNzYWdlRXZlbnQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTtmdW5jdGlvbiBDb25uZWN0aW9uRXZlbnQodHlwZSxvcHRpb25zKXtFdmVudC5jYWxsKHRoaXMsdHlwZSk7dGhpcy5zdGF0dXM9b3B0aW9ucy5zdGF0dXM7dGhpcy5zdGF0dXNUZXh0PW9wdGlvbnMuc3RhdHVzVGV4dDt0aGlzLmhlYWRlcnM9b3B0aW9ucy5oZWFkZXJzO31Db25uZWN0aW9uRXZlbnQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXZlbnQucHJvdG90eXBlKTt2YXIgV0FJVElORz0tMTt2YXIgQ09OTkVDVElORz0wO3ZhciBPUEVOPTE7dmFyIENMT1NFRD0yO3ZhciBBRlRFUl9DUj0tMTt2YXIgRklFTERfU1RBUlQ9MDt2YXIgRklFTEQ9MTt2YXIgVkFMVUVfU1RBUlQ9Mjt2YXIgVkFMVUU9Mzt2YXIgY29udGVudFR5cGVSZWdFeHA9L150ZXh0XFwvZXZlbnRcXC1zdHJlYW07PyhcXHMqY2hhcnNldFxcPXV0ZlxcLTgpPyQvaTt2YXIgTUlOSU1VTV9EVVJBVElPTj0xMDAwO3ZhciBNQVhJTVVNX0RVUkFUSU9OPTE4MDAwMDAwO3ZhciBwYXJzZUR1cmF0aW9uPWZ1bmN0aW9uIHBhcnNlRHVyYXRpb24odmFsdWUsZGVmKXt2YXIgbj1wYXJzZUludCh2YWx1ZSwxMCk7aWYobiE9PW4pe249ZGVmO31yZXR1cm4gY2xhbXBEdXJhdGlvbihuKTt9O3ZhciBjbGFtcER1cmF0aW9uPWZ1bmN0aW9uIGNsYW1wRHVyYXRpb24obil7cmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sTUlOSU1VTV9EVVJBVElPTiksTUFYSU1VTV9EVVJBVElPTik7fTt2YXIgZmlyZT1mdW5jdGlvbiBmaXJlKHRoYXQsZixldmVudCl7dHJ5e2lmKHR5cGVvZiBmPT09J2Z1bmN0aW9uJyl7Zi5jYWxsKHRoYXQsZXZlbnQpO319Y2F0Y2goZSl7dGhyb3dFcnJvcihlKTt9fTtmdW5jdGlvbiBFdmVudFNvdXJjZVBvbHlmaWxsKHVybCxvcHRpb25zKXtFdmVudFRhcmdldC5jYWxsKHRoaXMpO3RoaXMub25vcGVuPXVuZGVmaW5lZDt0aGlzLm9ubWVzc2FnZT11bmRlZmluZWQ7dGhpcy5vbmVycm9yPXVuZGVmaW5lZDt0aGlzLnVybD11bmRlZmluZWQ7dGhpcy5yZWFkeVN0YXRlPXVuZGVmaW5lZDt0aGlzLndpdGhDcmVkZW50aWFscz11bmRlZmluZWQ7dGhpcy5fY2xvc2U9dW5kZWZpbmVkO3N0YXJ0KHRoaXMsdXJsLG9wdGlvbnMpO312YXIgaXNGZXRjaFN1cHBvcnRlZD1fdW5mZXRjaC5kZWZhdWx0IT11bmRlZmluZWQmJlJlc3BvbnNlIT11bmRlZmluZWQmJidib2R5J2luIFJlc3BvbnNlLnByb3RvdHlwZTtmdW5jdGlvbiBzdGFydChlcyx1cmwsb3B0aW9ucyl7dXJsPVN0cmluZyh1cmwpO3ZhciB3aXRoQ3JlZGVudGlhbHM9b3B0aW9ucyE9dW5kZWZpbmVkJiZCb29sZWFuKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzKTt2YXIgaW5pdGlhbFJldHJ5PWNsYW1wRHVyYXRpb24oMTAwMCk7dmFyIGhlYXJ0YmVhdFRpbWVvdXQ9b3B0aW9ucyE9dW5kZWZpbmVkJiZvcHRpb25zLmhlYXJ0YmVhdFRpbWVvdXQhPXVuZGVmaW5lZD9wYXJzZUR1cmF0aW9uKG9wdGlvbnMuaGVhcnRiZWF0VGltZW91dCw0NTAwMCk6Y2xhbXBEdXJhdGlvbig0NTAwMCk7dmFyIGxhc3RFdmVudElkPScnO3ZhciByZXRyeT1pbml0aWFsUmV0cnk7dmFyIHdhc0FjdGl2aXR5PWZhbHNlO3ZhciBoZWFkZXJzPW9wdGlvbnMhPXVuZGVmaW5lZCYmb3B0aW9ucy5oZWFkZXJzIT11bmRlZmluZWQ/SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvcHRpb25zLmhlYWRlcnMpKTp1bmRlZmluZWQ7dmFyIEN1cnJlbnRUcmFuc3BvcnQ9b3B0aW9ucyE9dW5kZWZpbmVkJiZvcHRpb25zLlRyYW5zcG9ydCE9dW5kZWZpbmVkP29wdGlvbnMuVHJhbnNwb3J0OlhNTEh0dHBSZXF1ZXN0O3ZhciB4aHI9aXNGZXRjaFN1cHBvcnRlZCYmIShvcHRpb25zIT11bmRlZmluZWQmJm9wdGlvbnMuVHJhbnNwb3J0IT11bmRlZmluZWQpP3VuZGVmaW5lZDpuZXcgWEhSV3JhcHBlcihuZXcgQ3VycmVudFRyYW5zcG9ydCgpKTt2YXIgdHJhbnNwb3J0PXhocj09dW5kZWZpbmVkP25ldyBGZXRjaFRyYW5zcG9ydCgpOm5ldyBYSFJUcmFuc3BvcnQoKTt2YXIgY2FuY2VsRnVuY3Rpb249dW5kZWZpbmVkO3ZhciB0aW1lb3V0PTA7dmFyIGN1cnJlbnRTdGF0ZT1XQUlUSU5HO3ZhciBkYXRhQnVmZmVyPScnO3ZhciBsYXN0RXZlbnRJZEJ1ZmZlcj0nJzt2YXIgZXZlbnRUeXBlQnVmZmVyPScnO3ZhciB0ZXh0QnVmZmVyPScnO3ZhciBzdGF0ZT1GSUVMRF9TVEFSVDt2YXIgZmllbGRTdGFydD0wO3ZhciB2YWx1ZVN0YXJ0PTA7dmFyIG9uU3RhcnQ9ZnVuY3Rpb24gb25TdGFydChzdGF0dXMsc3RhdHVzVGV4dCxjb250ZW50VHlwZSxoZWFkZXJzLGNhbmNlbCl7aWYoY3VycmVudFN0YXRlPT09Q09OTkVDVElORyl7Y2FuY2VsRnVuY3Rpb249Y2FuY2VsO2lmKHN0YXR1cz09PTIwMCYmY29udGVudFR5cGUhPXVuZGVmaW5lZCYmY29udGVudFR5cGVSZWdFeHAudGVzdChjb250ZW50VHlwZSkpe2N1cnJlbnRTdGF0ZT1PUEVOO3dhc0FjdGl2aXR5PXRydWU7cmV0cnk9aW5pdGlhbFJldHJ5O2VzLnJlYWR5U3RhdGU9T1BFTjt2YXIgZXZlbnQ9bmV3IENvbm5lY3Rpb25FdmVudCgnb3Blbicse3N0YXR1czpzdGF0dXMsc3RhdHVzVGV4dDpzdGF0dXNUZXh0LGhlYWRlcnM6aGVhZGVyc30pO2VzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO2ZpcmUoZXMsZXMub25vcGVuLGV2ZW50KTt9ZWxzZXt2YXIgbWVzc2FnZT0nJztpZihzdGF0dXMhPT0yMDApe2lmKHN0YXR1c1RleHQpe3N0YXR1c1RleHQ9c3RhdHVzVGV4dC5yZXBsYWNlKC9cXHMrL2csJyAnKTt9bWVzc2FnZT1cIkV2ZW50U291cmNlJ3MgcmVzcG9uc2UgaGFzIGEgc3RhdHVzIFwiK3N0YXR1cysnICcrc3RhdHVzVGV4dCsnIHRoYXQgaXMgbm90IDIwMC4gQWJvcnRpbmcgdGhlIGNvbm5lY3Rpb24uJzt9ZWxzZXttZXNzYWdlPVwiRXZlbnRTb3VyY2UncyByZXNwb25zZSBoYXMgYSBDb250ZW50LVR5cGUgc3BlY2lmeWluZyBhbiB1bnN1cHBvcnRlZCB0eXBlOiBcIisoY29udGVudFR5cGU9PXVuZGVmaW5lZD8nLSc6Y29udGVudFR5cGUucmVwbGFjZSgvXFxzKy9nLCcgJykpKycuIEFib3J0aW5nIHRoZSBjb25uZWN0aW9uLic7fXRocm93RXJyb3IobmV3IEVycm9yKG1lc3NhZ2UpKTtjbG9zZSgpO3ZhciBldmVudD1uZXcgQ29ubmVjdGlvbkV2ZW50KCdlcnJvcicse3N0YXR1czpzdGF0dXMsc3RhdHVzVGV4dDpzdGF0dXNUZXh0LGhlYWRlcnM6aGVhZGVyc30pO2VzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO2ZpcmUoZXMsZXMub25lcnJvcixldmVudCk7fX19O3ZhciBvblByb2dyZXNzPWZ1bmN0aW9uIG9uUHJvZ3Jlc3ModGV4dENodW5rKXtpZihjdXJyZW50U3RhdGU9PT1PUEVOKXt2YXIgbj0tMTtmb3IodmFyIGk9MDtpPHRleHRDaHVuay5sZW5ndGg7aSs9MSl7dmFyIGM9dGV4dENodW5rLmNoYXJDb2RlQXQoaSk7aWYoYz09PSdcXG4nLmNoYXJDb2RlQXQoMCl8fGM9PT0nXFxyJy5jaGFyQ29kZUF0KDApKXtuPWk7fX12YXIgY2h1bms9KG4hPT0tMT90ZXh0QnVmZmVyOicnKSt0ZXh0Q2h1bmsuc2xpY2UoMCxuKzEpO3RleHRCdWZmZXI9KG49PT0tMT90ZXh0QnVmZmVyOicnKSt0ZXh0Q2h1bmsuc2xpY2UobisxKTtpZihjaHVuayE9PScnKXt3YXNBY3Rpdml0eT10cnVlO31mb3IodmFyIHBvc2l0aW9uPTA7cG9zaXRpb248Y2h1bmsubGVuZ3RoO3Bvc2l0aW9uKz0xKXt2YXIgYz1jaHVuay5jaGFyQ29kZUF0KHBvc2l0aW9uKTtpZihzdGF0ZT09PUFGVEVSX0NSJiZjPT09J1xcbicuY2hhckNvZGVBdCgwKSl7c3RhdGU9RklFTERfU1RBUlQ7fWVsc2V7aWYoc3RhdGU9PT1BRlRFUl9DUil7c3RhdGU9RklFTERfU1RBUlQ7fWlmKGM9PT0nXFxyJy5jaGFyQ29kZUF0KDApfHxjPT09J1xcbicuY2hhckNvZGVBdCgwKSl7aWYoc3RhdGUhPT1GSUVMRF9TVEFSVCl7aWYoc3RhdGU9PT1GSUVMRCl7dmFsdWVTdGFydD1wb3NpdGlvbisxO312YXIgZmllbGQ9Y2h1bmsuc2xpY2UoZmllbGRTdGFydCx2YWx1ZVN0YXJ0LTEpO3ZhciB2YWx1ZT1jaHVuay5zbGljZSh2YWx1ZVN0YXJ0Kyh2YWx1ZVN0YXJ0PHBvc2l0aW9uJiZjaHVuay5jaGFyQ29kZUF0KHZhbHVlU3RhcnQpPT09JyAnLmNoYXJDb2RlQXQoMCk/MTowKSxwb3NpdGlvbik7aWYoZmllbGQ9PT0nZGF0YScpe2RhdGFCdWZmZXIrPSdcXG4nO2RhdGFCdWZmZXIrPXZhbHVlO31lbHNlIGlmKGZpZWxkPT09J2lkJyl7bGFzdEV2ZW50SWRCdWZmZXI9dmFsdWU7fWVsc2UgaWYoZmllbGQ9PT0nZXZlbnQnKXtldmVudFR5cGVCdWZmZXI9dmFsdWU7fWVsc2UgaWYoZmllbGQ9PT0ncmV0cnknKXtpbml0aWFsUmV0cnk9cGFyc2VEdXJhdGlvbih2YWx1ZSxpbml0aWFsUmV0cnkpO3JldHJ5PWluaXRpYWxSZXRyeTt9ZWxzZSBpZihmaWVsZD09PSdoZWFydGJlYXRUaW1lb3V0Jyl7aGVhcnRiZWF0VGltZW91dD1wYXJzZUR1cmF0aW9uKHZhbHVlLGhlYXJ0YmVhdFRpbWVvdXQpO2lmKHRpbWVvdXQhPT0wKXtjbGVhclRpbWVvdXQodGltZW91dCk7dGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b25UaW1lb3V0KCk7fSxoZWFydGJlYXRUaW1lb3V0KTt9fX1pZihzdGF0ZT09PUZJRUxEX1NUQVJUKXtpZihkYXRhQnVmZmVyIT09Jycpe2xhc3RFdmVudElkPWxhc3RFdmVudElkQnVmZmVyO2lmKGV2ZW50VHlwZUJ1ZmZlcj09PScnKXtldmVudFR5cGVCdWZmZXI9J21lc3NhZ2UnO312YXIgZXZlbnQ9bmV3IE1lc3NhZ2VFdmVudChldmVudFR5cGVCdWZmZXIse2RhdGE6ZGF0YUJ1ZmZlci5zbGljZSgxKSxsYXN0RXZlbnRJZDpsYXN0RXZlbnRJZEJ1ZmZlcn0pO2VzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO2lmKGV2ZW50VHlwZUJ1ZmZlcj09PSdtZXNzYWdlJyl7ZmlyZShlcyxlcy5vbm1lc3NhZ2UsZXZlbnQpO31pZihjdXJyZW50U3RhdGU9PT1DTE9TRUQpe3JldHVybjt9fWRhdGFCdWZmZXI9Jyc7ZXZlbnRUeXBlQnVmZmVyPScnO31zdGF0ZT1jPT09J1xccicuY2hhckNvZGVBdCgwKT9BRlRFUl9DUjpGSUVMRF9TVEFSVDt9ZWxzZXtpZihzdGF0ZT09PUZJRUxEX1NUQVJUKXtmaWVsZFN0YXJ0PXBvc2l0aW9uO3N0YXRlPUZJRUxEO31pZihzdGF0ZT09PUZJRUxEKXtpZihjPT09JzonLmNoYXJDb2RlQXQoMCkpe3ZhbHVlU3RhcnQ9cG9zaXRpb24rMTtzdGF0ZT1WQUxVRV9TVEFSVDt9fWVsc2UgaWYoc3RhdGU9PT1WQUxVRV9TVEFSVCl7c3RhdGU9VkFMVUU7fX19fX19O3ZhciBvbkZpbmlzaD1mdW5jdGlvbiBvbkZpbmlzaCgpe2lmKGN1cnJlbnRTdGF0ZT09PU9QRU58fGN1cnJlbnRTdGF0ZT09PUNPTk5FQ1RJTkcpe2N1cnJlbnRTdGF0ZT1XQUlUSU5HO2lmKHRpbWVvdXQhPT0wKXtjbGVhclRpbWVvdXQodGltZW91dCk7dGltZW91dD0wO310aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtvblRpbWVvdXQoKTt9LHJldHJ5KTtyZXRyeT1jbGFtcER1cmF0aW9uKE1hdGgubWluKGluaXRpYWxSZXRyeSoxNixyZXRyeSoyKSk7ZXMucmVhZHlTdGF0ZT1DT05ORUNUSU5HO3ZhciBldmVudD1uZXcgRXZlbnQoJ2Vycm9yJyk7ZXMuZGlzcGF0Y2hFdmVudChldmVudCk7ZmlyZShlcyxlcy5vbmVycm9yLGV2ZW50KTt9fTt2YXIgY2xvc2U9ZnVuY3Rpb24gY2xvc2UoKXtjdXJyZW50U3RhdGU9Q0xPU0VEO2lmKGNhbmNlbEZ1bmN0aW9uIT11bmRlZmluZWQpe2NhbmNlbEZ1bmN0aW9uKCk7Y2FuY2VsRnVuY3Rpb249dW5kZWZpbmVkO31pZih0aW1lb3V0IT09MCl7Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO3RpbWVvdXQ9MDt9ZXMucmVhZHlTdGF0ZT1DTE9TRUQ7fTt2YXIgb25UaW1lb3V0PWZ1bmN0aW9uIG9uVGltZW91dCgpe3RpbWVvdXQ9MDtpZihjdXJyZW50U3RhdGUhPT1XQUlUSU5HKXtpZighd2FzQWN0aXZpdHkmJmNhbmNlbEZ1bmN0aW9uIT11bmRlZmluZWQpe3Rocm93RXJyb3IobmV3IEVycm9yKCdObyBhY3Rpdml0eSB3aXRoaW4gJytoZWFydGJlYXRUaW1lb3V0KycgbWlsbGlzZWNvbmRzLiBSZWNvbm5lY3RpbmcuJykpO2NhbmNlbEZ1bmN0aW9uKCk7Y2FuY2VsRnVuY3Rpb249dW5kZWZpbmVkO31lbHNle3dhc0FjdGl2aXR5PWZhbHNlO3RpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe29uVGltZW91dCgpO30saGVhcnRiZWF0VGltZW91dCk7fXJldHVybjt9d2FzQWN0aXZpdHk9ZmFsc2U7dGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b25UaW1lb3V0KCk7fSxoZWFydGJlYXRUaW1lb3V0KTtjdXJyZW50U3RhdGU9Q09OTkVDVElORztkYXRhQnVmZmVyPScnO2V2ZW50VHlwZUJ1ZmZlcj0nJztsYXN0RXZlbnRJZEJ1ZmZlcj1sYXN0RXZlbnRJZDt0ZXh0QnVmZmVyPScnO2ZpZWxkU3RhcnQ9MDt2YWx1ZVN0YXJ0PTA7c3RhdGU9RklFTERfU1RBUlQ7Ly8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDI4OTE2XG4vLyBSZXF1ZXN0IGhlYWRlciBmaWVsZCBMYXN0LUV2ZW50LUlEIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnMuXG52YXIgcmVxdWVzdFVSTD11cmw7aWYodXJsLnNsaWNlKDAsNSkhPT0nZGF0YTonJiZ1cmwuc2xpY2UoMCw1KSE9PSdibG9iOicpe2lmKGxhc3RFdmVudElkIT09Jycpe3JlcXVlc3RVUkwrPSh1cmwuaW5kZXhPZignPycpPT09LTE/Jz8nOicmJykrJ2xhc3RFdmVudElkPScrZW5jb2RlVVJJQ29tcG9uZW50KGxhc3RFdmVudElkKTt9fXZhciByZXF1ZXN0SGVhZGVycz17fTtyZXF1ZXN0SGVhZGVyc1snQWNjZXB0J109J3RleHQvZXZlbnQtc3RyZWFtJztpZihoZWFkZXJzIT11bmRlZmluZWQpe2Zvcih2YXIgbmFtZSBpbiBoZWFkZXJzKXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycyxuYW1lKSl7cmVxdWVzdEhlYWRlcnNbbmFtZV09aGVhZGVyc1tuYW1lXTt9fX10cnl7dHJhbnNwb3J0Lm9wZW4oeGhyLG9uU3RhcnQsb25Qcm9ncmVzcyxvbkZpbmlzaCxyZXF1ZXN0VVJMLHdpdGhDcmVkZW50aWFscyxyZXF1ZXN0SGVhZGVycyk7fWNhdGNoKGVycm9yKXtjbG9zZSgpO3Rocm93IGVycm9yO319O2VzLnVybD11cmw7ZXMucmVhZHlTdGF0ZT1DT05ORUNUSU5HO2VzLndpdGhDcmVkZW50aWFscz13aXRoQ3JlZGVudGlhbHM7ZXMuX2Nsb3NlPWNsb3NlO29uVGltZW91dCgpO31FdmVudFNvdXJjZVBvbHlmaWxsLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEV2ZW50VGFyZ2V0LnByb3RvdHlwZSk7RXZlbnRTb3VyY2VQb2x5ZmlsbC5wcm90b3R5cGUuQ09OTkVDVElORz1DT05ORUNUSU5HO0V2ZW50U291cmNlUG9seWZpbGwucHJvdG90eXBlLk9QRU49T1BFTjtFdmVudFNvdXJjZVBvbHlmaWxsLnByb3RvdHlwZS5DTE9TRUQ9Q0xPU0VEO0V2ZW50U291cmNlUG9seWZpbGwucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5fY2xvc2UoKTt9O0V2ZW50U291cmNlUG9seWZpbGwuQ09OTkVDVElORz1DT05ORUNUSU5HO0V2ZW50U291cmNlUG9seWZpbGwuT1BFTj1PUEVOO0V2ZW50U291cmNlUG9seWZpbGwuQ0xPU0VEPUNMT1NFRDtFdmVudFNvdXJjZVBvbHlmaWxsLnByb3RvdHlwZS53aXRoQ3JlZGVudGlhbHM9dW5kZWZpbmVkO3ZhciBfZGVmYXVsdD1FdmVudFNvdXJjZVBvbHlmaWxsO2V4cG9ydHMuZGVmYXVsdD1fZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmRpc3BsYXlDb250ZW50PWRpc3BsYXlDb250ZW50O2Z1bmN0aW9uIGRpc3BsYXlDb250ZW50KGNhbGxiYWNrKXsvLyBUaGlzIGlzIHRoZSBmYWxsYmFjayBoZWxwZXIgdGhhdCByZW1vdmVzIE5leHQuanMnIG5vLUZPVUMgc3R5bGVzIHdoZW5cbi8vIENTUyBtb2RlIGlzIGVuYWJsZWQuIFRoaXMgb25seSByZWFsbHkgYWN0aXZhdGVzIGlmIHlvdSBoYXZlbid0IGNyZWF0ZWRcbi8vIF9hbnlfIHN0eWxlcyBpbiB5b3VyIGFwcGxpY2F0aW9uIHlldC5cbjsod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZXx8c2V0VGltZW91dCkoZnVuY3Rpb24oKXtmb3IodmFyIHg9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbmV4dC1oaWRlLWZvdWNdJyksaT14Lmxlbmd0aDtpLS07KXt4W2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoeFtpXSk7fWlmKGNhbGxiYWNrKXtjYWxsYmFjaygpO319KTt9IiwiXCJ1c2Ugc3RyaWN0XCI7dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ9cmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMuZGVmYXVsdD12b2lkIDA7dmFyIF9yb3V0ZXI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwibmV4dC9yb3V0ZXJcIikpO3ZhciBfb25EZW1hbmRFbnRyaWVzVXRpbHM9cmVxdWlyZShcIi4vb24tZGVtYW5kLWVudHJpZXMtdXRpbHNcIik7dmFyIF9kZWZhdWx0PWFzeW5jKF9yZWYpPT57dmFye2Fzc2V0UHJlZml4fT1fcmVmO19yb3V0ZXIuZGVmYXVsdC5yZWFkeSgoKT0+e19yb3V0ZXIuZGVmYXVsdC5ldmVudHMub24oJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLF9vbkRlbWFuZEVudHJpZXNVdGlscy5zZXR1cFBpbmcuYmluZCh2b2lkIDAsYXNzZXRQcmVmaXgsKCk9Pl9yb3V0ZXIuZGVmYXVsdC5wYXRobmFtZSkpO30pOygwLF9vbkRlbWFuZEVudHJpZXNVdGlscy5zZXR1cFBpbmcpKGFzc2V0UHJlZml4LCgpPT5fcm91dGVyLmRlZmF1bHQucGF0aG5hbWUsX29uRGVtYW5kRW50cmllc1V0aWxzLmN1cnJlbnRQYWdlKTsvLyBwcmV2ZW50IEhNUiBjb25uZWN0aW9uIGZyb20gYmVpbmcgY2xvc2VkIHdoZW4gcnVubmluZyB0ZXN0c1xuaWYoIXByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpe2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLGV2ZW50PT57dmFyIHN0YXRlPWRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZTtpZihzdGF0ZT09PSd2aXNpYmxlJyl7KDAsX29uRGVtYW5kRW50cmllc1V0aWxzLnNldHVwUGluZykoYXNzZXRQcmVmaXgsKCk9Pl9yb3V0ZXIuZGVmYXVsdC5wYXRobmFtZSx0cnVlKTt9ZWxzZXsoMCxfb25EZW1hbmRFbnRyaWVzVXRpbHMuY2xvc2VQaW5nKSgpO319KTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywoKT0+eygwLF9vbkRlbWFuZEVudHJpZXNVdGlscy5jbG9zZVBpbmcpKCk7fSk7fX07ZXhwb3J0cy5kZWZhdWx0PV9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO3ZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0PXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmNsb3NlUGluZz1jbG9zZVBpbmc7ZXhwb3J0cy5zZXR1cFBpbmc9c2V0dXBQaW5nO2V4cG9ydHMuY3VycmVudFBhZ2U9dm9pZCAwO3ZhciBfdW5mZXRjaD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJuZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3VuZmV0Y2hcIikpO3ZhciBfZXZlbnRzb3VyY2U9cmVxdWlyZShcIi4vZXJyb3Itb3ZlcmxheS9ldmVudHNvdXJjZVwiKTsvKiBnbG9iYWwgbG9jYXRpb24gKi92YXIgZXZ0U291cmNlO3ZhciBjdXJyZW50UGFnZTtleHBvcnRzLmN1cnJlbnRQYWdlPWN1cnJlbnRQYWdlO2Z1bmN0aW9uIGNsb3NlUGluZygpe2lmKGV2dFNvdXJjZSlldnRTb3VyY2UuY2xvc2UoKTtldnRTb3VyY2U9bnVsbDt9ZnVuY3Rpb24gc2V0dXBQaW5nKGFzc2V0UHJlZml4LHBhdGhuYW1lRm4scmV0cnkpe3ZhciBwYXRobmFtZT1wYXRobmFtZUZuKCk7Ly8gTWFrZSBzdXJlIHRvIG9ubHkgY3JlYXRlIG5ldyBFdmVudFNvdXJjZSByZXF1ZXN0IGlmIHBhZ2UgaGFzIGNoYW5nZWRcbmlmKHBhdGhuYW1lPT09Y3VycmVudFBhZ2UmJiFyZXRyeSlyZXR1cm47ZXhwb3J0cy5jdXJyZW50UGFnZT1jdXJyZW50UGFnZT1wYXRobmFtZTsvLyBjbG9zZSBjdXJyZW50IEV2ZW50U291cmNlIGNvbm5lY3Rpb25cbmNsb3NlUGluZygpO3ZhciB1cmw9YXNzZXRQcmVmaXgrXCIvX25leHQvd2VicGFjay1obXI/cGFnZT1cIitjdXJyZW50UGFnZTtldnRTb3VyY2U9KDAsX2V2ZW50c291cmNlLmdldEV2ZW50U291cmNlV3JhcHBlcikoe3BhdGg6dXJsLHRpbWVvdXQ6NTAwMCxvbmRlbWFuZDoxfSk7ZXZ0U291cmNlLmFkZE1lc3NhZ2VMaXN0ZW5lcihldmVudD0+e2lmKGV2ZW50LmRhdGEuaW5kZXhPZigneycpPT09LTEpcmV0dXJuO3RyeXt2YXIgcGF5bG9hZD1KU09OLnBhcnNlKGV2ZW50LmRhdGEpO2lmKHBheWxvYWQuaW52YWxpZCl7Ly8gUGF5bG9hZCBjYW4gYmUgaW52YWxpZCBldmVuIGlmIHRoZSBwYWdlIGRvZXMgbm90IGV4aXN0LlxuLy8gU28sIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGl0IGV4aXN0cyBiZWZvcmUgcmVsb2FkaW5nLlxuKDAsX3VuZmV0Y2guZGVmYXVsdCkobG9jYXRpb24uaHJlZix7Y3JlZGVudGlhbHM6J3NhbWUtb3JpZ2luJ30pLnRoZW4ocGFnZVJlcz0+e2lmKHBhZ2VSZXMuc3RhdHVzPT09MjAwKXtsb2NhdGlvbi5yZWxvYWQoKTt9fSk7fX1jYXRjaChlcnIpe2NvbnNvbGUuZXJyb3IoJ29uLWRlbWFuZC1lbnRyaWVzIGZhaWxlZCB0byBwYXJzZSByZXNwb25zZScsZXJyKTt9fSk7fSIsIlwidXNlIHN0cmljdFwiO3ZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0PXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmRlZmF1bHQ9aW5pdGlhbGl6ZUJ1aWxkV2F0Y2hlcjt2YXIgX3JvdXRlcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9yb3V0ZXJcIikpO2Z1bmN0aW9uIGluaXRpYWxpemVCdWlsZFdhdGNoZXIoKXt2YXIgc2hhZG93SG9zdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtzaGFkb3dIb3N0LmlkPSdfX25leHQtcHJlcmVuZGVyLWluZGljYXRvcic7Ly8gTWFrZSBzdXJlIGNvbnRhaW5lciBpcyBmaXhlZCBhbmQgb24gYSBoaWdoIHpJbmRleCBzbyBpdCBzaG93c1xuc2hhZG93SG9zdC5zdHlsZS5wb3NpdGlvbj0nZml4ZWQnO3NoYWRvd0hvc3Quc3R5bGUuYm90dG9tPScyMHB4JztzaGFkb3dIb3N0LnN0eWxlLnJpZ2h0PScxMHB4JztzaGFkb3dIb3N0LnN0eWxlLndpZHRoPTA7c2hhZG93SG9zdC5zdHlsZS5oZWlnaHQ9MDtzaGFkb3dIb3N0LnN0eWxlLnpJbmRleD05OTk5ODtzaGFkb3dIb3N0LnN0eWxlLnRyYW5zaXRpb249J2FsbCAxMDBtcyBlYXNlJztkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNoYWRvd0hvc3QpO3ZhciBzaGFkb3dSb290O3ZhciBwcmVmaXg9Jyc7aWYoc2hhZG93SG9zdC5hdHRhY2hTaGFkb3cpe3NoYWRvd1Jvb3Q9c2hhZG93SG9zdC5hdHRhY2hTaGFkb3coe21vZGU6J29wZW4nfSk7fWVsc2V7Ly8gSWYgYXR0YWNoU2hhZG93IGlzIHVuZGVmaW5lZCB0aGVuIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnRcbi8vIHRoZSBTaGFkb3cgRE9NLCB3ZSBuZWVkIHRvIHByZWZpeCBhbGwgdGhlIG5hbWVzIHNvIHRoZXJlXG4vLyB3aWxsIGJlIG5vIGNvbmZsaWN0c1xuc2hhZG93Um9vdD1zaGFkb3dIb3N0O3ByZWZpeD0nX19uZXh0LXByZXJlbmRlci1pbmRpY2F0b3ItJzt9Ly8gQ29udGFpbmVyXG52YXIgY29udGFpbmVyPWNyZWF0ZUNvbnRhaW5lcihwcmVmaXgpO3NoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTsvLyBDU1NcbnZhciBjc3M9Y3JlYXRlQ3NzKHByZWZpeCk7c2hhZG93Um9vdC5hcHBlbmRDaGlsZChjc3MpO3ZhciBleHBhbmRFbD1jb250YWluZXIucXVlcnlTZWxlY3RvcignYScpO3ZhciBjbG9zZUVsPWNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiI1wiK3ByZWZpeCtcImNsb3NlXCIpOy8vIFN0YXRlXG52YXIgZGlzbWlzc0tleT0nX19ORVhUX0RJU01JU1NfUFJFUkVOREVSX0lORElDQVRPUic7dmFyIGRpc21pc3NVbnRpbD1wYXJzZUludCh3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oZGlzbWlzc0tleSksMTApO3ZhciBkaXNtaXNzZWQ9ZGlzbWlzc1VudGlsPm5ldyBEYXRlKCkuZ2V0VGltZSgpO3ZhciBpc1Zpc2libGU9IWRpc21pc3NlZCYmd2luZG93Ll9fTkVYVF9EQVRBX18ubmV4dEV4cG9ydDtmdW5jdGlvbiB1cGRhdGVDb250YWluZXIoKXtpZihpc1Zpc2libGUpe2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHByZWZpeCtcInZpc2libGVcIik7fWVsc2V7Y29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUocHJlZml4K1widmlzaWJsZVwiKTt9fXZhciBleHBhbmRlZENsYXNzPXByZWZpeCtcImV4cGFuZGVkXCI7dmFyIHRvZ2dsZVRpbWVvdXQ7dmFyIHRvZ2dsZUV4cGFuZD1mdW5jdGlvbiB0b2dnbGVFeHBhbmQoZXhwYW5kKXtpZihleHBhbmQ9PT12b2lkIDApe2V4cGFuZD10cnVlO31jbGVhclRpbWVvdXQodG9nZ2xlVGltZW91dCk7dG9nZ2xlVGltZW91dD1zZXRUaW1lb3V0KCgpPT57aWYoZXhwYW5kKXtleHBhbmRFbC5jbGFzc0xpc3QuYWRkKGV4cGFuZGVkQ2xhc3MpO2Nsb3NlRWwuc3R5bGUuZGlzcGxheT0nZmxleCc7fWVsc2V7ZXhwYW5kRWwuY2xhc3NMaXN0LnJlbW92ZShleHBhbmRlZENsYXNzKTtjbG9zZUVsLnN0eWxlLmRpc3BsYXk9J25vbmUnO319LDUwKTt9O2Nsb3NlRWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCgpPT57dmFyIG9uZUhvdXJBd2F5PW5ldyBEYXRlKCkuZ2V0VGltZSgpKzEqNjAqNjAqMTAwMDt3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oZGlzbWlzc0tleSxvbmVIb3VyQXdheSsnJyk7aXNWaXNpYmxlPWZhbHNlO3VwZGF0ZUNvbnRhaW5lcigpO30pO2Nsb3NlRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsKCk9PnRvZ2dsZUV4cGFuZCgpKTtjbG9zZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCgpPT50b2dnbGVFeHBhbmQoZmFsc2UpKTtleHBhbmRFbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywoKT0+dG9nZ2xlRXhwYW5kKCkpO2V4cGFuZEVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCgpPT50b2dnbGVFeHBhbmQoZmFsc2UpKTtfcm91dGVyLmRlZmF1bHQuZXZlbnRzLm9uKCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywoKT0+e2lzVmlzaWJsZT13aW5kb3cubmV4dC5pc1ByZXJlbmRlcmVkO3VwZGF0ZUNvbnRhaW5lcigpO30pO3VwZGF0ZUNvbnRhaW5lcigpO31mdW5jdGlvbiBjcmVhdGVDb250YWluZXIocHJlZml4KXt2YXIgY29udGFpbmVyPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO2NvbnRhaW5lci5pZD1wcmVmaXgrXCJjb250YWluZXJcIjtjb250YWluZXIuaW5uZXJIVE1MPVwiXFxuICAgIDxidXR0b24gaWQ9XFxcIlwiK3ByZWZpeCtcImNsb3NlXFxcIiB0aXRsZT1cXFwiSGlkZSBpbmRpY2F0b3IgZm9yIHNlc3Npb25cXFwiPlxcbiAgICAgIDxzcGFuPlxceEQ3PC9zcGFuPlxcbiAgICA8L2J1dHRvbj5cXG4gICAgPGEgaHJlZj1cXFwiaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MjYXV0b21hdGljLXN0YXRpYy1vcHRpbWl6YXRpb24taW5kaWNhdG9yXFxcIiB0YXJnZXQ9XFxcIl9ibGFua1xcXCIgcmVsPVxcXCJub3JlZmVycmVyXFxcIj5cXG4gICAgICA8ZGl2IGlkPVxcXCJcIitwcmVmaXgrXCJpY29uLXdyYXBwZXJcXFwiPlxcbiAgICAgICAgICA8c3ZnIHdpZHRoPVxcXCIxNVxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDYwIDgwXFxcIiBmaWxsPVxcXCJub25lXFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPlxcbiAgICAgICAgICA8cGF0aCBkPVxcXCJNMzYgM0wzMC43NCA0MUg4TDM2IDNaXFxcIiBmaWxsPVxcXCJibGFja1xcXCIvPlxcbiAgICAgICAgICA8cGF0aCBkPVxcXCJNMjUgNzdMMzAuMjYgMzlINTNMMjUgNzdaXFxcIiBmaWxsPVxcXCJibGFja1xcXCIvPlxcbiAgICAgICAgICA8cGF0aCBkPVxcXCJNMTMuNSAzMy41TDUzIDM5TDQ3LjUgNDYuNUw3IDQxLjI1TDEzLjUgMzMuNVpcXFwiIGZpbGw9XFxcImJsYWNrXFxcIi8+XFxuICAgICAgICAgIDwvc3ZnPlxcbiAgICAgICAgICBQcmVyZW5kZXJlZCBQYWdlXFxuICAgICAgPC9kaXY+XFxuICAgIDwvYT5cXG4gIFwiO3JldHVybiBjb250YWluZXI7fWZ1bmN0aW9uIGNyZWF0ZUNzcyhwcmVmaXgpe3ZhciBjc3M9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtjc3MudGV4dENvbnRlbnQ9XCJcXG4gICAgI1wiK3ByZWZpeCtcImNvbnRhaW5lciB7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgYm90dG9tOiAxMHB4O1xcbiAgICAgIHJpZ2h0OiAxNXB4O1xcbiAgICB9XFxuXFxuICAgICNcIitwcmVmaXgrXCJjbG9zZSB7XFxuICAgICAgdG9wOiAtMTBweDtcXG4gICAgICByaWdodDogLTEwcHg7XFxuICAgICAgYm9yZGVyOiBub25lO1xcbiAgICAgIHdpZHRoOiAxOHB4O1xcbiAgICAgIGhlaWdodDogMThweDtcXG4gICAgICBjb2xvcjogIzMzMzMzMztcXG4gICAgICBmb250LXNpemU6IDE2cHg7XFxuICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgIGRpc3BsYXk6IG5vbmU7XFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICAgIGJhY2tncm91bmQ6ICNmZmZmZmY7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMTAwJTtcXG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIH1cXG5cXG4gICAgI1wiK3ByZWZpeCtcImNvbnRhaW5lciBhIHtcXG4gICAgICBjb2xvcjogaW5oZXJpdDtcXG4gICAgICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxuICAgICAgd2lkdGg6IDE1cHg7XFxuICAgICAgaGVpZ2h0OiAyM3B4O1xcbiAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuXFxuICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICAgIGJhY2tncm91bmQ6ICNmZmY7XFxuICAgICAgY29sb3I6ICMwMDA7XFxuICAgICAgZm9udDogaW5pdGlhbDtcXG4gICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgbGV0dGVyLXNwYWNpbmc6IGluaXRpYWw7XFxuICAgICAgdGV4dC1zaGFkb3c6IGluaXRpYWw7XFxuICAgICAgdGV4dC10cmFuc2Zvcm06IGluaXRpYWw7XFxuICAgICAgdmlzaWJpbGl0eTogaW5pdGlhbDtcXG4gICAgICBmb250LXNpemU6IDE0cHg7XFxuICAgICAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgJ1NlZ29lIFVJJywgUm9ib3RvLCBPeHlnZW4sIFVidW50dSwgQ2FudGFyZWxsLCAnT3BlbiBTYW5zJywgJ0hlbHZldGljYSBOZXVlJywgc2Fucy1zZXJpZjtcXG5cXG4gICAgICBwYWRkaW5nOiA0cHggMnB4O1xcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgYm94LXNoYWRvdzogMCAxMXB4IDQwcHggMCByZ2JhKDAsIDAsIDAsIDAuMjUpLCAwIDJweCAxMHB4IDAgcmdiYSgwLCAwLCAwLCAwLjEyKTtcXG5cXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4xcyBlYXNlLCBib3R0b20gMC4xcyBlYXNlLCB3aWR0aCAwLjNzIGVhc2U7XFxuICAgICAgYW5pbWF0aW9uOiBcIitwcmVmaXgrXCJmYWRlLWluIDAuMXMgZWFzZS1pbi1vdXQ7XFxuICAgIH1cXG5cXG4gICAgI1wiK3ByZWZpeCtcImljb24td3JhcHBlciB7XFxuICAgICAgd2lkdGg6IDE0MHB4O1xcbiAgICAgIGhlaWdodDogMjBweDtcXG4gICAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICAgIGZsZXgtc2hyaW5rOiAwO1xcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICB9XFxuXFxuICAgICNcIitwcmVmaXgrXCJpY29uLXdyYXBwZXIgc3ZnIHtcXG4gICAgICBmbGV4LXNocmluazogMDtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDNweDtcXG4gICAgfVxcblxcbiAgICAjXCIrcHJlZml4K1wiY29udGFpbmVyIGEuXCIrcHJlZml4K1wiZXhwYW5kZWQge1xcbiAgICAgIHdpZHRoOiAxMzVweDtcXG4gICAgfVxcblxcbiAgICAjXCIrcHJlZml4K1wiY29udGFpbmVyLlwiK3ByZWZpeCtcInZpc2libGUge1xcbiAgICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgICAgYm90dG9tOiAxMHB4O1xcbiAgICAgIG9wYWNpdHk6IDE7XFxuICAgIH1cXG5cXG4gICAgQGtleWZyYW1lcyBcIitwcmVmaXgrXCJmYWRlLWluIHtcXG4gICAgICBmcm9tIHtcXG4gICAgICAgIGJvdHRvbTogMHB4O1xcbiAgICAgICAgb3BhY2l0eTogMDtcXG4gICAgICB9XFxuICAgICAgdG8ge1xcbiAgICAgICAgYm90dG9tOiAxMHB4O1xcbiAgICAgICAgb3BhY2l0eTogMTtcXG4gICAgICB9XFxuICAgIH1cXG4gIFwiO3JldHVybiBjc3M7fSIsIlwidXNlIHN0cmljdFwiO3ZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0PXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmRlZmF1bHQ9dm9pZCAwO3ZhciBfaG90RGV2Q2xpZW50PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZXJyb3Itb3ZlcmxheS9ob3QtZGV2LWNsaWVudFwiKSk7dmFyIF9kZWZhdWx0PShfcmVmKT0+e3Zhcnthc3NldFByZWZpeH09X3JlZjt2YXIgb3B0aW9ucz17cGF0aDphc3NldFByZWZpeCtcIi9fbmV4dC93ZWJwYWNrLWhtclwifTt2YXIgZGV2Q2xpZW50PSgwLF9ob3REZXZDbGllbnQuZGVmYXVsdCkob3B0aW9ucyk7ZGV2Q2xpZW50LnN1YnNjcmliZVRvSG1yRXZlbnQob2JqPT57aWYob2JqLmFjdGlvbj09PSdyZWxvYWRQYWdlJyl7cmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTt9aWYob2JqLmFjdGlvbj09PSdyZW1vdmVkUGFnZScpe3ZhcltwYWdlXT1vYmouZGF0YTtpZihwYWdlPT09d2luZG93Lm5leHQucm91dGVyLnBhdGhuYW1lKXtyZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO31yZXR1cm47fWlmKG9iai5hY3Rpb249PT0nYWRkZWRQYWdlJyl7dmFyW19wYWdlXT1vYmouZGF0YTtpZihfcGFnZT09PXdpbmRvdy5uZXh0LnJvdXRlci5wYXRobmFtZSYmdHlwZW9mIHdpbmRvdy5uZXh0LnJvdXRlci5jb21wb25lbnRzW19wYWdlXT09PSd1bmRlZmluZWQnKXtyZXR1cm4gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO31yZXR1cm47fXRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBhY3Rpb24gJytvYmouYWN0aW9uKTt9KTtyZXR1cm4gZGV2Q2xpZW50O307ZXhwb3J0cy5kZWZhdWx0PV9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMuZGVmYXVsdD1pbml0SGVhZE1hbmFnZXI7dmFyIERPTUF0dHJpYnV0ZU5hbWVzPXthY2NlcHRDaGFyc2V0OidhY2NlcHQtY2hhcnNldCcsY2xhc3NOYW1lOidjbGFzcycsaHRtbEZvcjonZm9yJyxodHRwRXF1aXY6J2h0dHAtZXF1aXYnfTtmdW5jdGlvbiByZWFjdEVsZW1lbnRUb0RPTShfcmVmKXt2YXJ7dHlwZSxwcm9wc309X3JlZjt2YXIgZWw9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtmb3IodmFyIHAgaW4gcHJvcHMpe2lmKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwKSljb250aW51ZTtpZihwPT09J2NoaWxkcmVuJ3x8cD09PSdkYW5nZXJvdXNseVNldElubmVySFRNTCcpY29udGludWU7Ly8gd2UgZG9uJ3QgcmVuZGVyIHVuZGVmaW5lZCBwcm9wcyB0byB0aGUgRE9NXG5pZihwcm9wc1twXT09PXVuZGVmaW5lZCljb250aW51ZTt2YXIgYXR0cj1ET01BdHRyaWJ1dGVOYW1lc1twXXx8cC50b0xvd2VyQ2FzZSgpO2VsLnNldEF0dHJpYnV0ZShhdHRyLHByb3BzW3BdKTt9dmFye2NoaWxkcmVuLGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MfT1wcm9wcztpZihkYW5nZXJvdXNseVNldElubmVySFRNTCl7ZWwuaW5uZXJIVE1MPWRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbHx8Jyc7fWVsc2UgaWYoY2hpbGRyZW4pe2VsLnRleHRDb250ZW50PXR5cGVvZiBjaGlsZHJlbj09PSdzdHJpbmcnP2NoaWxkcmVuOmNoaWxkcmVuLmpvaW4oJycpO31yZXR1cm4gZWw7fWZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRzKHR5cGUsY29tcG9uZW50cyl7dmFyIGhlYWRFbD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO3ZhciBoZWFkQ291bnRFbD1oZWFkRWwucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPW5leHQtaGVhZC1jb3VudF0nKTtpZihwcm9jZXNzLmVudi5OT0RFX0VOViE9PSdwcm9kdWN0aW9uJyl7aWYoIWhlYWRDb3VudEVsKXtjb25zb2xlLmVycm9yKCdXYXJuaW5nOiBuZXh0LWhlYWQtY291bnQgaXMgbWlzc2luZy4gaHR0cHM6Ly9lcnIuc2gvbmV4dC5qcy9uZXh0LWhlYWQtY291bnQtbWlzc2luZycpO3JldHVybjt9fXZhciBoZWFkQ291bnQ9TnVtYmVyKGhlYWRDb3VudEVsLmNvbnRlbnQpO3ZhciBvbGRUYWdzPVtdO2Zvcih2YXIgaT0wLGo9aGVhZENvdW50RWwucHJldmlvdXNFbGVtZW50U2libGluZztpPGhlYWRDb3VudDtpKyssaj1qLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpe2lmKGoudGFnTmFtZS50b0xvd2VyQ2FzZSgpPT09dHlwZSl7b2xkVGFncy5wdXNoKGopO319dmFyIG5ld1RhZ3M9Y29tcG9uZW50cy5tYXAocmVhY3RFbGVtZW50VG9ET00pLmZpbHRlcihuZXdUYWc9Pntmb3IodmFyIGs9MCxsZW49b2xkVGFncy5sZW5ndGg7azxsZW47aysrKXt2YXIgb2xkVGFnPW9sZFRhZ3Nba107aWYob2xkVGFnLmlzRXF1YWxOb2RlKG5ld1RhZykpe29sZFRhZ3Muc3BsaWNlKGssMSk7cmV0dXJuIGZhbHNlO319cmV0dXJuIHRydWU7fSk7b2xkVGFncy5mb3JFYWNoKHQ9PnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSk7bmV3VGFncy5mb3JFYWNoKHQ9PmhlYWRFbC5pbnNlcnRCZWZvcmUodCxoZWFkQ291bnRFbCkpO2hlYWRDb3VudEVsLmNvbnRlbnQ9KGhlYWRDb3VudC1vbGRUYWdzLmxlbmd0aCtuZXdUYWdzLmxlbmd0aCkudG9TdHJpbmcoKTt9ZnVuY3Rpb24gaW5pdEhlYWRNYW5hZ2VyKCl7dmFyIHVwZGF0ZVByb21pc2U9bnVsbDtyZXR1cm4gaGVhZD0+e3ZhciBwcm9taXNlPXVwZGF0ZVByb21pc2U9UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+e2lmKHByb21pc2UhPT11cGRhdGVQcm9taXNlKXJldHVybjt1cGRhdGVQcm9taXNlPW51bGw7dmFyIHRhZ3M9e307aGVhZC5mb3JFYWNoKGg9Pnt2YXIgY29tcG9uZW50cz10YWdzW2gudHlwZV18fFtdO2NvbXBvbmVudHMucHVzaChoKTt0YWdzW2gudHlwZV09Y29tcG9uZW50czt9KTt2YXIgdGl0bGVDb21wb25lbnQ9dGFncy50aXRsZT90YWdzLnRpdGxlWzBdOm51bGw7dmFyIHRpdGxlPScnO2lmKHRpdGxlQ29tcG9uZW50KXt2YXJ7Y2hpbGRyZW59PXRpdGxlQ29tcG9uZW50LnByb3BzO3RpdGxlPXR5cGVvZiBjaGlsZHJlbj09PSdzdHJpbmcnP2NoaWxkcmVuOmNoaWxkcmVuLmpvaW4oJycpO31pZih0aXRsZSE9PWRvY3VtZW50LnRpdGxlKWRvY3VtZW50LnRpdGxlPXRpdGxlO1snbWV0YScsJ2Jhc2UnLCdsaW5rJywnc3R5bGUnLCdzY3JpcHQnXS5mb3JFYWNoKHR5cGU9Pnt1cGRhdGVFbGVtZW50cyh0eXBlLHRhZ3NbdHlwZV18fFtdKTt9KTt9KTt9O30iLCJcInVzZSBzdHJpY3RcIjt2YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQzPXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7dmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ9cmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMucmVuZGVyPXJlbmRlcjtleHBvcnRzLnJlbmRlckVycm9yPXJlbmRlckVycm9yO2V4cG9ydHMuZGVmYXVsdD1leHBvcnRzLmVtaXR0ZXI9ZXhwb3J0cy5yb3V0ZXI9ZXhwb3J0cy52ZXJzaW9uPXZvaWQgMDt2YXIgX2V4dGVuZHMyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kc1wiKSk7dmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkMj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIikpO3ZhciBfcm91dGVyPXJlcXVpcmUoXCJuZXh0L3JvdXRlclwiKTt2YXIgX3F1ZXJ5c3RyaW5nPXJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTt2YXIgX3JlYWN0PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTt2YXIgX3JlYWN0RG9tPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0LWRvbVwiKSk7dmFyIF9oZWFkTWFuYWdlckNvbnRleHQ9cmVxdWlyZShcIi4uL25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dFwiKTt2YXIgX21pdHQ9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vbmV4dC1zZXJ2ZXIvbGliL21pdHRcIikpO3ZhciBfcm91dGVyQ29udGV4dD1yZXF1aXJlKFwiLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0XCIpO3ZhciBfaXNEeW5hbWljPXJlcXVpcmUoXCIuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWNcIik7dmFyIGVudkNvbmZpZz1faW50ZXJvcFJlcXVpcmVXaWxkY2FyZDMocmVxdWlyZShcIi4uL25leHQtc2VydmVyL2xpYi9ydW50aW1lLWNvbmZpZ1wiKSk7dmFyIF91dGlscz1yZXF1aXJlKFwiLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzXCIpO3ZhciBfaGVhZE1hbmFnZXI9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9oZWFkLW1hbmFnZXJcIikpO3ZhciBfcGFnZUxvYWRlcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BhZ2UtbG9hZGVyXCIpKTt2YXIgX3BlcmZvcm1hbmNlUmVsYXllcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3BlcmZvcm1hbmNlLXJlbGF5ZXJcIikpOy8qIGdsb2JhbCBsb2NhdGlvbiAqLyAvLy8gPHJlZmVyZW5jZSB0eXBlcz1cInJlYWN0LWRvbS9leHBlcmltZW50YWxcIiAvPlxuaWYoISgnZmluYWxseSdpbiBQcm9taXNlLnByb3RvdHlwZSkpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlXG5Qcm9taXNlLnByb3RvdHlwZS5maW5hbGx5PXJlcXVpcmUoJ25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvZmluYWxseS1wb2x5ZmlsbC5taW4nKTt9dmFyIGRhdGE9SlNPTi5wYXJzZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19ORVhUX0RBVEFfXycpLnRleHRDb250ZW50KTt3aW5kb3cuX19ORVhUX0RBVEFfXz1kYXRhO3ZhciB2ZXJzaW9uPVwiOS40LjFcIjtleHBvcnRzLnZlcnNpb249dmVyc2lvbjt2YXJ7cHJvcHMsZXJyLHBhZ2UscXVlcnksYnVpbGRJZCxhc3NldFByZWZpeCxydW50aW1lQ29uZmlnLGR5bmFtaWNJZHMsaXNGYWxsYmFja309ZGF0YTt2YXIgcHJlZml4PWFzc2V0UHJlZml4fHwnJzsvLyBXaXRoIGR5bmFtaWMgYXNzZXRQcmVmaXggaXQncyBubyBsb25nZXIgcG9zc2libGUgdG8gc2V0IGFzc2V0UHJlZml4IGF0IHRoZSBidWlsZCB0aW1lXG4vLyBTbywgdGhpcyBpcyBob3cgd2UgZG8gaXQgaW4gdGhlIGNsaWVudCBzaWRlIGF0IHJ1bnRpbWVcbl9fd2VicGFja19wdWJsaWNfcGF0aF9fPXByZWZpeCtcIi9fbmV4dC9cIjsvL2VzbGludC1kaXNhYmxlLWxpbmVcbi8vIEluaXRpYWxpemUgbmV4dC9jb25maWcgd2l0aCB0aGUgZW52aXJvbm1lbnQgY29uZmlndXJhdGlvblxuZW52Q29uZmlnLnNldENvbmZpZyh7c2VydmVyUnVudGltZUNvbmZpZzp7fSxwdWJsaWNSdW50aW1lQ29uZmlnOnJ1bnRpbWVDb25maWd8fHt9fSk7dmFyIGFzUGF0aD0oMCxfdXRpbHMuZ2V0VVJMKSgpO3ZhciBwYWdlTG9hZGVyPW5ldyBfcGFnZUxvYWRlci5kZWZhdWx0KGJ1aWxkSWQscHJlZml4KTt2YXIgcmVnaXN0ZXI9KF9yZWYpPT57dmFyW3IsZl09X3JlZjtyZXR1cm4gcGFnZUxvYWRlci5yZWdpc3RlclBhZ2UocixmKTt9O2lmKHdpbmRvdy5fX05FWFRfUCl7d2luZG93Ll9fTkVYVF9QLm1hcChyZWdpc3Rlcik7fXdpbmRvdy5fX05FWFRfUD1bXTt3aW5kb3cuX19ORVhUX1AucHVzaD1yZWdpc3Rlcjt2YXIgdXBkYXRlSGVhZD0oMCxfaGVhZE1hbmFnZXIuZGVmYXVsdCkoKTt2YXIgYXBwRWxlbWVudD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19uZXh0Jyk7dmFyIGxhc3RBcHBQcm9wczt2YXIgd2VicGFja0hNUjt2YXIgcm91dGVyO2V4cG9ydHMucm91dGVyPXJvdXRlcjt2YXIgRXJyb3JDb21wb25lbnQ7dmFyIENvbXBvbmVudDt2YXIgQXBwLG9uUGVyZkVudHJ5O2NsYXNzIENvbnRhaW5lciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudHtjb21wb25lbnREaWRDYXRjaChlcnIsaW5mbyl7dGhpcy5wcm9wcy5mbihlcnIsaW5mbyk7fWNvbXBvbmVudERpZE1vdW50KCl7dGhpcy5zY3JvbGxUb0hhc2goKTtpZihwcm9jZXNzLmVudi5fX05FWFRfUExVR0lOUyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG5Qcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT4oMCxfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZDIuZGVmYXVsdCkocmVxdWlyZSgnbmV4dC1wbHVnaW4tbG9hZGVyP21pZGRsZXdhcmU9dW5zdGFibGUtcG9zdC1oeWRyYXRpb24hJykpKS50aGVuKG1vZD0+e3JldHVybiBtb2QuZGVmYXVsdCgpO30pLmNhdGNoKGVycj0+e2NvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGxpbmcgcG9zdC1oeWRyYXRpb24gZm9yIHBsdWdpbnMnLGVycik7fSk7fS8vIFdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgcm91dGVyIHN0YXRlIGlmOlxuLy8gLSB0aGUgcGFnZSB3YXMgKGF1dG8pIGV4cG9ydGVkIGFuZCBoYXMgYSBxdWVyeSBzdHJpbmcgb3Igc2VhcmNoIChoYXNoKVxuLy8gLSBpdCB3YXMgYXV0byBleHBvcnRlZCBhbmQgaXMgYSBkeW5hbWljIHJvdXRlICh0byBwcm92aWRlIHBhcmFtcylcbi8vIC0gaWYgaXQgaXMgYSBjbGllbnQtc2lkZSBza2VsZXRvbiAoZmFsbGJhY2sgcmVuZGVyKVxuaWYocm91dGVyLmlzU3NyJiYoaXNGYWxsYmFja3x8ZGF0YS5uZXh0RXhwb3J0JiYoKDAsX2lzRHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGVyLnBhdGhuYW1lKXx8bG9jYXRpb24uc2VhcmNoKXx8cHJvcHMmJnByb3BzLl9fTl9TU0cmJmxvY2F0aW9uLnNlYXJjaCkpey8vIHVwZGF0ZSBxdWVyeSBvbiBtb3VudCBmb3IgZXhwb3J0ZWQgcGFnZXNcbnJvdXRlci5yZXBsYWNlKHJvdXRlci5wYXRobmFtZSsnPycrKDAsX3F1ZXJ5c3RyaW5nLnN0cmluZ2lmeSkoKDAsX2V4dGVuZHMyLmRlZmF1bHQpKCgwLF9leHRlbmRzMi5kZWZhdWx0KSh7fSxyb3V0ZXIucXVlcnkpLCgwLF9xdWVyeXN0cmluZy5wYXJzZSkobG9jYXRpb24uc2VhcmNoLnN1YnN0cigxKSkpKSxhc1BhdGgsey8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanNcbi8vIGNsaWVudC1zaWRlIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuXG4vLyBJdCBtYXkgY2hhbmdlIGF0IGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuX2g6MSwvLyBGYWxsYmFjayBwYWdlcyBtdXN0IHRyaWdnZXIgdGhlIGRhdGEgZmV0Y2gsIHNvIHRoZSB0cmFuc2l0aW9uIGlzXG4vLyBub3Qgc2hhbGxvdy5cbi8vIE90aGVyIHBhZ2VzIChzdHJpY3RseSB1cGRhdGluZyBxdWVyeSkgaGFwcGVucyBzaGFsbG93bHksIGFzIGRhdGFcbi8vIHJlcXVpcmVtZW50cyB3b3VsZCBhbHJlYWR5IGJlIHByZXNlbnQuXG5zaGFsbG93OiFpc0ZhbGxiYWNrfSk7fWlmKHByb2Nlc3MuZW52Ll9fTkVYVF9URVNUX01PREUpe3dpbmRvdy5fX05FWFRfSFlEUkFURUQ9dHJ1ZTtpZih3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKXt3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKCk7fX19Y29tcG9uZW50RGlkVXBkYXRlKCl7dGhpcy5zY3JvbGxUb0hhc2goKTt9c2Nyb2xsVG9IYXNoKCl7dmFye2hhc2h9PWxvY2F0aW9uO2hhc2g9aGFzaCYmaGFzaC5zdWJzdHJpbmcoMSk7aWYoIWhhc2gpcmV0dXJuO3ZhciBlbD1kb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKTtpZighZWwpcmV0dXJuOy8vIElmIHdlIGNhbGwgc2Nyb2xsSW50b1ZpZXcoKSBpbiBoZXJlIHdpdGhvdXQgYSBzZXRUaW1lb3V0XG4vLyBpdCB3b24ndCBzY3JvbGwgcHJvcGVybHkuXG5zZXRUaW1lb3V0KCgpPT5lbC5zY3JvbGxJbnRvVmlldygpLDApO31yZW5kZXIoKXtpZihwcm9jZXNzLmVudi5OT0RFX0VOVj09PSdwcm9kdWN0aW9uJyl7cmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47fWlmKHByb2Nlc3MuZW52Lk5PREVfRU5WIT09J3Byb2R1Y3Rpb24nKXt2YXJ7UmVhY3REZXZPdmVybGF5fT1yZXF1aXJlKCdAbmV4dC9yZWFjdC1kZXYtb3ZlcmxheS9saWIvY2xpZW50Jyk7cmV0dXJuLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhY3REZXZPdmVybGF5LG51bGwsdGhpcy5wcm9wcy5jaGlsZHJlbik7fX19dmFyIGVtaXR0ZXI9KDAsX21pdHQuZGVmYXVsdCkoKTtleHBvcnRzLmVtaXR0ZXI9ZW1pdHRlcjt2YXIgX2RlZmF1bHQ9YXN5bmMgZnVuY3Rpb24gX2RlZmF1bHQoX3RlbXApe3Zhcnt3ZWJwYWNrSE1SOnBhc3NlZFdlYnBhY2tITVJ9PV90ZW1wPT09dm9pZCAwP3t9Ol90ZW1wOy8vIFRoaXMgbWFrZXMgc3VyZSB0aGlzIHNwZWNpZmljIGxpbmVzIGFyZSByZW1vdmVkIGluIHByb2R1Y3Rpb25cbmlmKHByb2Nlc3MuZW52Lk5PREVfRU5WPT09J2RldmVsb3BtZW50Jyl7d2VicGFja0hNUj1wYXNzZWRXZWJwYWNrSE1SO312YXJ7cGFnZTphcHAsbW9kfT1hd2FpdCBwYWdlTG9hZGVyLmxvYWRQYWdlU2NyaXB0KCcvX2FwcCcpO0FwcD1hcHA7aWYobW9kJiZtb2QucmVwb3J0V2ViVml0YWxzKXtvblBlcmZFbnRyeT0oX3JlZjIpPT57dmFye2lkLG5hbWUsc3RhcnRUaW1lLHZhbHVlLGR1cmF0aW9uLGVudHJ5VHlwZSxlbnRyaWVzfT1fcmVmMjsvLyBDb21iaW5lcyB0aW1lc3RhbXAgd2l0aCByYW5kb20gbnVtYmVyIGZvciB1bmlxdWUgSURcbnZhciB1bmlxdWVJRD1EYXRlLm5vdygpK1wiLVwiKyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKDllMTItMSkpKzFlMTIpO3ZhciBwZXJmU3RhcnRFbnRyeTtpZihlbnRyaWVzJiZlbnRyaWVzLmxlbmd0aCl7cGVyZlN0YXJ0RW50cnk9ZW50cmllc1swXS5zdGFydFRpbWU7fW1vZC5yZXBvcnRXZWJWaXRhbHMoe2lkOmlkfHx1bmlxdWVJRCxuYW1lLHN0YXJ0VGltZTpzdGFydFRpbWV8fHBlcmZTdGFydEVudHJ5LHZhbHVlOnZhbHVlPT1udWxsP2R1cmF0aW9uOnZhbHVlLGxhYmVsOmVudHJ5VHlwZT09PSdtYXJrJ3x8ZW50cnlUeXBlPT09J21lYXN1cmUnPydjdXN0b20nOid3ZWItdml0YWwnfSk7fTt9dmFyIGluaXRpYWxFcnI9ZXJyO3RyeXs7KHtwYWdlOkNvbXBvbmVudH09YXdhaXQgcGFnZUxvYWRlci5sb2FkUGFnZShwYWdlKSk7aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlYhPT0ncHJvZHVjdGlvbicpe3Zhcntpc1ZhbGlkRWxlbWVudFR5cGV9PXJlcXVpcmUoJ3JlYWN0LWlzJyk7aWYoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKXt0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFxcXCJcIitwYWdlK1wiXFxcIlwiKTt9fX1jYXRjaChlcnJvcil7Ly8gVGhpcyBjYXRjaGVzIGVycm9ycyBsaWtlIHRocm93aW5nIGluIHRoZSB0b3AgbGV2ZWwgb2YgYSBtb2R1bGVcbmluaXRpYWxFcnI9ZXJyb3I7fWlmKHByb2Nlc3MuZW52Lk5PREVfRU5WPT09J2RldmVsb3BtZW50Jyl7dmFye2dldE5vZGVFcnJvcn09cmVxdWlyZSgnQG5leHQvcmVhY3QtZGV2LW92ZXJsYXkvbGliL2NsaWVudCcpOy8vIFNlcnZlci1zaWRlIHJ1bnRpbWUgZXJyb3JzIG5lZWQgdG8gYmUgcmUtdGhyb3duIG9uIHRoZSBjbGllbnQtc2lkZSBzb1xuLy8gdGhhdCB0aGUgb3ZlcmxheSBpcyByZW5kZXJlZC5cbmlmKGluaXRpYWxFcnIpe2lmKGluaXRpYWxFcnI9PT1lcnIpe3NldFRpbWVvdXQoKCk9Pnt2YXIgZXJyb3I7dHJ5ey8vIEdlbmVyYXRlIGEgbmV3IGVycm9yIG9iamVjdC4gV2UgYHRocm93YCBpdCBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbi8vIHdpbGwgc2V0IHRoZSBgc3RhY2tgIHdoZW4gdGhyb3duLCBhbmQgd2Ugd2FudCB0byBlbnN1cmUgb3VycyBpc1xuLy8gbm90IG92ZXJyaWRkZW4gd2hlbiB3ZSByZS10aHJvdyBpdCBiZWxvdy5cbnRocm93IG5ldyBFcnJvcihpbml0aWFsRXJyLm1lc3NhZ2UpO31jYXRjaChlKXtlcnJvcj1lO31lcnJvci5uYW1lPWluaXRpYWxFcnIubmFtZTtlcnJvci5zdGFjaz1pbml0aWFsRXJyLnN0YWNrO3ZhciBub2RlPWdldE5vZGVFcnJvcihlcnJvcik7dGhyb3cgbm9kZTt9KTt9Ly8gV2UgcmVwbGFjZWQgdGhlIHNlcnZlci1zaWRlIGVycm9yIHdpdGggYSBjbGllbnQtc2lkZSBlcnJvciwgYW5kIHNob3VsZFxuLy8gbm8gbG9uZ2VyIHJld3JpdGUgdGhlIHN0YWNrIHRyYWNlIHRvIGEgTm9kZSBlcnJvci5cbmVsc2V7c2V0VGltZW91dCgoKT0+e3Rocm93IGluaXRpYWxFcnI7fSk7fX19aWYod2luZG93Ll9fTkVYVF9QUkVMT0FEUkVBRFkpe2F3YWl0IHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKGR5bmFtaWNJZHMpO31leHBvcnRzLnJvdXRlcj1yb3V0ZXI9KDAsX3JvdXRlci5jcmVhdGVSb3V0ZXIpKHBhZ2UscXVlcnksYXNQYXRoLHtpbml0aWFsUHJvcHM6cHJvcHMscGFnZUxvYWRlcixBcHAsQ29tcG9uZW50LHdyYXBBcHAsZXJyOmluaXRpYWxFcnIsaXNGYWxsYmFjayxzdWJzY3JpcHRpb246KF9yZWYzLEFwcCk9Pnt2YXJ7Q29tcG9uZW50LHByb3BzLGVycn09X3JlZjM7cmVuZGVyKHtBcHAsQ29tcG9uZW50LHByb3BzLGVycn0pO319KTsvLyBjYWxsIGluaXQtY2xpZW50IG1pZGRsZXdhcmVcbmlmKHByb2Nlc3MuZW52Ll9fTkVYVF9QTFVHSU5TKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcblByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PigwLF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkMi5kZWZhdWx0KShyZXF1aXJlKCduZXh0LXBsdWdpbi1sb2FkZXI/bWlkZGxld2FyZT1vbi1pbml0LWNsaWVudCEnKSkpLnRoZW4obW9kPT57cmV0dXJuIG1vZC5kZWZhdWx0KHtyb3V0ZXJ9KTt9KS5jYXRjaChlcnI9Pntjb25zb2xlLmVycm9yKCdFcnJvciBjYWxsaW5nIGNsaWVudC1pbml0IGZvciBwbHVnaW5zJyxlcnIpO30pO312YXIgcmVuZGVyQ3R4PXtBcHAsQ29tcG9uZW50LHByb3BzLGVycjppbml0aWFsRXJyfTtpZihwcm9jZXNzLmVudi5OT0RFX0VOVj09PSdwcm9kdWN0aW9uJyl7cmVuZGVyKHJlbmRlckN0eCk7cmV0dXJuIGVtaXR0ZXI7fWlmKHByb2Nlc3MuZW52Lk5PREVfRU5WIT09J3Byb2R1Y3Rpb24nKXtyZXR1cm57ZW1pdHRlcixyZW5kZXIscmVuZGVyQ3R4fTt9fTtleHBvcnRzLmRlZmF1bHQ9X2RlZmF1bHQ7YXN5bmMgZnVuY3Rpb24gcmVuZGVyKHByb3BzKXtpZihwcm9wcy5lcnIpe2F3YWl0IHJlbmRlckVycm9yKHByb3BzKTtyZXR1cm47fXRyeXthd2FpdCBkb1JlbmRlcihwcm9wcyk7fWNhdGNoKGVycil7aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlY9PT0nZGV2ZWxvcG1lbnQnKXsvLyBFbnN1cmUgdGhpcyBlcnJvciBpcyBkaXNwbGF5ZWQgaW4gdGhlIG92ZXJsYXkgaW4gZGV2ZWxvcG1lbnRcbnNldFRpbWVvdXQoKCk9Pnt0aHJvdyBlcnI7fSk7fWF3YWl0IHJlbmRlckVycm9yKCgwLF9leHRlbmRzMi5kZWZhdWx0KSgoMCxfZXh0ZW5kczIuZGVmYXVsdCkoe30scHJvcHMpLHt9LHtlcnJ9KSk7fX0vLyBUaGlzIG1ldGhvZCBoYW5kbGVzIGFsbCBydW50aW1lIGFuZCBkZWJ1ZyBlcnJvcnMuXG4vLyA0MDQgYW5kIDUwMCBlcnJvcnMgYXJlIHNwZWNpYWwga2luZCBvZiBlcnJvcnNcbi8vIGFuZCB0aGV5IGFyZSBzdGlsbCBoYW5kbGUgdmlhIHRoZSBtYWluIHJlbmRlciBtZXRob2QuXG5mdW5jdGlvbiByZW5kZXJFcnJvcihwcm9wcyl7dmFye0FwcCxlcnJ9PXByb3BzOy8vIEluIGRldmVsb3BtZW50IHJ1bnRpbWUgZXJyb3JzIGFyZSBjYXVnaHQgYnkgb3VyIG92ZXJsYXlcbi8vIEluIHByb2R1Y3Rpb24gd2UgY2F0Y2ggcnVudGltZSBlcnJvcnMgdXNpbmcgY29tcG9uZW50RGlkQ2F0Y2ggd2hpY2ggd2lsbCB0cmlnZ2VyIHJlbmRlckVycm9yXG5pZihwcm9jZXNzLmVudi5OT0RFX0VOViE9PSdwcm9kdWN0aW9uJyl7Ly8gQSBOZXh0LmpzIHJlbmRlcmluZyBydW50aW1lIGVycm9yIGlzIGFsd2F5cyB1bnJlY292ZXJhYmxlXG4vLyBGSVhNRTogbGV0J3MgbWFrZSB0aGlzIHJlY292ZXJhYmxlIChlcnJvciBpbiBHSVAgY2xpZW50LXRyYW5zaXRpb24pXG53ZWJwYWNrSE1SLm9uVW5yZWNvdmVyYWJsZUVycm9yKCk7Ly8gV2UgbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgPEFwcD4gc28gdGhhdCB0aGUgYDxSZWFjdERldk92ZXJsYXk+YCBjYW5cbi8vIHJlbmRlciBpdHNlbGYuXG5yZXR1cm4gZG9SZW5kZXIoe0FwcDooKT0+bnVsbCxwcm9wczp7fSxDb21wb25lbnQ6KCk9Pm51bGwsZXJyOm51bGx9KTt9aWYocHJvY2Vzcy5lbnYuX19ORVhUX1BMVUdJTlMpey8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+KDAsX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQyLmRlZmF1bHQpKHJlcXVpcmUoJ25leHQtcGx1Z2luLWxvYWRlcj9taWRkbGV3YXJlPW9uLWVycm9yLWNsaWVudCEnKSkpLnRoZW4obW9kPT57cmV0dXJuIG1vZC5kZWZhdWx0KHtlcnJ9KTt9KS5jYXRjaChlcnI9Pntjb25zb2xlLmVycm9yKCdlcnJvciBjYWxsaW5nIG9uLWVycm9yLWNsaWVudCBmb3IgcGx1Z2lucycsZXJyKTt9KTt9Ly8gTWFrZSBzdXJlIHdlIGxvZyB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUsIG90aGVyd2lzZSB1c2VycyBjYW4ndCB0cmFjayBkb3duIGlzc3Vlcy5cbmNvbnNvbGUuZXJyb3IoZXJyKTtyZXR1cm4gcGFnZUxvYWRlci5sb2FkUGFnZSgnL19lcnJvcicpLnRoZW4oKF9yZWY0KT0+e3ZhcntwYWdlOkVycm9yQ29tcG9uZW50fT1fcmVmNDsvLyBJbiBwcm9kdWN0aW9uIHdlIGRvIGEgbm9ybWFsIHJlbmRlciB3aXRoIHRoZSBgRXJyb3JDb21wb25lbnRgIGFzIGNvbXBvbmVudC5cbi8vIElmIHdlJ3ZlIGdvdHRlbiBoZXJlIHVwb24gaW5pdGlhbCByZW5kZXIsIHdlIGNhbiB1c2UgdGhlIHByb3BzIGZyb20gdGhlIHNlcnZlci5cbi8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBjYWxsIGBnZXRJbml0aWFsUHJvcHNgIG9uIGBBcHBgIGJlZm9yZSBtb3VudGluZy5cbnZhciBBcHBUcmVlPXdyYXBBcHAoQXBwKTt2YXIgYXBwQ3R4PXtDb21wb25lbnQ6RXJyb3JDb21wb25lbnQsQXBwVHJlZSxyb3V0ZXIsY3R4OntlcnIscGF0aG5hbWU6cGFnZSxxdWVyeSxhc1BhdGgsQXBwVHJlZX19O3JldHVybiBQcm9taXNlLnJlc29sdmUocHJvcHMucHJvcHM/cHJvcHMucHJvcHM6KDAsX3V0aWxzLmxvYWRHZXRJbml0aWFsUHJvcHMpKEFwcCxhcHBDdHgpKS50aGVuKGluaXRQcm9wcz0+ZG9SZW5kZXIoKDAsX2V4dGVuZHMyLmRlZmF1bHQpKCgwLF9leHRlbmRzMi5kZWZhdWx0KSh7fSxwcm9wcykse30se2VycixDb21wb25lbnQ6RXJyb3JDb21wb25lbnQscHJvcHM6aW5pdFByb3BzfSkpKTt9KTt9Ly8gSWYgaHlkcmF0ZSBkb2VzIG5vdCBleGlzdCwgZWcgaW4gcHJlYWN0LlxudmFyIGlzSW5pdGlhbFJlbmRlcj10eXBlb2YgX3JlYWN0RG9tLmRlZmF1bHQuaHlkcmF0ZT09PSdmdW5jdGlvbic7dmFyIHJlYWN0Um9vdD1udWxsO2Z1bmN0aW9uIHJlbmRlclJlYWN0RWxlbWVudChyZWFjdEVsLGRvbUVsKXtpZihwcm9jZXNzLmVudi5fX05FWFRfUkVBQ1RfTU9ERSE9PSdsZWdhY3knKXtpZighcmVhY3RSb290KXt2YXIgb3B0cz17aHlkcmF0ZTp0cnVlfTtyZWFjdFJvb3Q9cHJvY2Vzcy5lbnYuX19ORVhUX1JFQUNUX01PREU9PT0nY29uY3VycmVudCc/X3JlYWN0RG9tLmRlZmF1bHQudW5zdGFibGVfY3JlYXRlUm9vdChkb21FbCxvcHRzKTpfcmVhY3REb20uZGVmYXVsdC51bnN0YWJsZV9jcmVhdGVCbG9ja2luZ1Jvb3QoZG9tRWwsb3B0cyk7fXJlYWN0Um9vdC5yZW5kZXIocmVhY3RFbCk7fWVsc2V7Ly8gbWFyayBzdGFydCBvZiBoeWRyYXRlL3JlbmRlclxuaWYoX3V0aWxzLlNUKXtwZXJmb3JtYW5jZS5tYXJrKCdiZWZvcmVSZW5kZXInKTt9Ly8gVGhlIGNoZWNrIGZvciBgLmh5ZHJhdGVgIGlzIHRoZXJlIHRvIHN1cHBvcnQgUmVhY3QgYWx0ZXJuYXRpdmVzIGxpa2UgcHJlYWN0XG5pZihpc0luaXRpYWxSZW5kZXIpe19yZWFjdERvbS5kZWZhdWx0Lmh5ZHJhdGUocmVhY3RFbCxkb21FbCxtYXJrSHlkcmF0ZUNvbXBsZXRlKTtpc0luaXRpYWxSZW5kZXI9ZmFsc2U7aWYob25QZXJmRW50cnkmJl91dGlscy5TVCl7KDAsX3BlcmZvcm1hbmNlUmVsYXllci5kZWZhdWx0KShvblBlcmZFbnRyeSk7fX1lbHNle19yZWFjdERvbS5kZWZhdWx0LnJlbmRlcihyZWFjdEVsLGRvbUVsLG1hcmtSZW5kZXJDb21wbGV0ZSk7fX19ZnVuY3Rpb24gbWFya0h5ZHJhdGVDb21wbGV0ZSgpe2lmKCFfdXRpbHMuU1QpcmV0dXJuO3BlcmZvcm1hbmNlLm1hcmsoJ2FmdGVySHlkcmF0ZScpOy8vIG1hcmsgZW5kIG9mIGh5ZHJhdGlvblxucGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1iZWZvcmUtaHlkcmF0aW9uJywnbmF2aWdhdGlvblN0YXJ0JywnYmVmb3JlUmVuZGVyJyk7cGVyZm9ybWFuY2UubWVhc3VyZSgnTmV4dC5qcy1oeWRyYXRpb24nLCdiZWZvcmVSZW5kZXInLCdhZnRlckh5ZHJhdGUnKTtpZihvblBlcmZFbnRyeSl7cGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1oeWRyYXRpb24nKS5mb3JFYWNoKG9uUGVyZkVudHJ5KTt9Y2xlYXJNYXJrcygpO31mdW5jdGlvbiBtYXJrUmVuZGVyQ29tcGxldGUoKXtpZighX3V0aWxzLlNUKXJldHVybjtwZXJmb3JtYW5jZS5tYXJrKCdhZnRlclJlbmRlcicpOy8vIG1hcmsgZW5kIG9mIHJlbmRlclxudmFyIG5hdlN0YXJ0RW50cmllcz1wZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlOYW1lKCdyb3V0ZUNoYW5nZScsJ21hcmsnKTtpZighbmF2U3RhcnRFbnRyaWVzLmxlbmd0aCl7cmV0dXJuO31wZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInLG5hdlN0YXJ0RW50cmllc1swXS5uYW1lLCdiZWZvcmVSZW5kZXInKTtwZXJmb3JtYW5jZS5tZWFzdXJlKCdOZXh0LmpzLXJlbmRlcicsJ2JlZm9yZVJlbmRlcicsJ2FmdGVyUmVuZGVyJyk7aWYob25QZXJmRW50cnkpe3BlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoJ05leHQuanMtcmVuZGVyJykuZm9yRWFjaChvblBlcmZFbnRyeSk7cGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZSgnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJykuZm9yRWFjaChvblBlcmZFbnRyeSk7fWNsZWFyTWFya3MoKTtbJ05leHQuanMtcm91dGUtY2hhbmdlLXRvLXJlbmRlcicsJ05leHQuanMtcmVuZGVyJ10uZm9yRWFjaChtZWFzdXJlPT5wZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmUpKTt9ZnVuY3Rpb24gY2xlYXJNYXJrcygpeztbJ2JlZm9yZVJlbmRlcicsJ2FmdGVySHlkcmF0ZScsJ2FmdGVyUmVuZGVyJywncm91dGVDaGFuZ2UnXS5mb3JFYWNoKG1hcms9PnBlcmZvcm1hbmNlLmNsZWFyTWFya3MobWFyaykpO31mdW5jdGlvbiBBcHBDb250YWluZXIoX3JlZjUpe3ZhcntjaGlsZHJlbn09X3JlZjU7cmV0dXJuLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29udGFpbmVyLHtmbjplcnJvcj0+cmVuZGVyRXJyb3Ioe0FwcCxlcnI6ZXJyb3J9KS5jYXRjaChlcnI9PmNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbmRlcmluZyBwYWdlOiAnLGVycikpfSwvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcm91dGVyQ29udGV4dC5Sb3V0ZXJDb250ZXh0LlByb3ZpZGVyLHt2YWx1ZTooMCxfcm91dGVyLm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSkocm91dGVyKX0sLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX2hlYWRNYW5hZ2VyQ29udGV4dC5IZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXIse3ZhbHVlOnVwZGF0ZUhlYWR9LGNoaWxkcmVuKSkpO312YXIgd3JhcEFwcD1BcHA9PnByb3BzPT57dmFyIGFwcFByb3BzPSgwLF9leHRlbmRzMi5kZWZhdWx0KSgoMCxfZXh0ZW5kczIuZGVmYXVsdCkoe30scHJvcHMpLHt9LHtDb21wb25lbnQsZXJyLHJvdXRlcn0pO3JldHVybi8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcENvbnRhaW5lcixudWxsLC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcCxhcHBQcm9wcykpO307YXN5bmMgZnVuY3Rpb24gZG9SZW5kZXIoX3JlZjYpe3ZhcntBcHAsQ29tcG9uZW50LHByb3BzLGVycn09X3JlZjY7Ly8gVXN1YWwgZ2V0SW5pdGlhbFByb3BzIGZldGNoaW5nIGlzIGhhbmRsZWQgaW4gbmV4dC9yb3V0ZXJcbi8vIHRoaXMgaXMgZm9yIHdoZW4gRXJyb3JDb21wb25lbnQgZ2V0cyByZXBsYWNlZCBieSBDb21wb25lbnQgYnkgSE1SXG5pZighcHJvcHMmJkNvbXBvbmVudCYmQ29tcG9uZW50IT09RXJyb3JDb21wb25lbnQmJmxhc3RBcHBQcm9wcy5Db21wb25lbnQ9PT1FcnJvckNvbXBvbmVudCl7dmFye3BhdGhuYW1lLHF1ZXJ5Ol9xdWVyeSxhc1BhdGg6X2FzUGF0aH09cm91dGVyO3ZhciBBcHBUcmVlPXdyYXBBcHAoQXBwKTt2YXIgYXBwQ3R4PXtyb3V0ZXIsQXBwVHJlZSxDb21wb25lbnQ6RXJyb3JDb21wb25lbnQsY3R4OntlcnIscGF0aG5hbWUscXVlcnk6X3F1ZXJ5LGFzUGF0aDpfYXNQYXRoLEFwcFRyZWV9fTtwcm9wcz1hd2FpdCgwLF91dGlscy5sb2FkR2V0SW5pdGlhbFByb3BzKShBcHAsYXBwQ3R4KTt9Q29tcG9uZW50PUNvbXBvbmVudHx8bGFzdEFwcFByb3BzLkNvbXBvbmVudDtwcm9wcz1wcm9wc3x8bGFzdEFwcFByb3BzLnByb3BzO3ZhciBhcHBQcm9wcz0oMCxfZXh0ZW5kczIuZGVmYXVsdCkoKDAsX2V4dGVuZHMyLmRlZmF1bHQpKHt9LHByb3BzKSx7fSx7Q29tcG9uZW50LGVycixyb3V0ZXJ9KTsvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxubGFzdEFwcFByb3BzPWFwcFByb3BzO2VtaXR0ZXIuZW1pdCgnYmVmb3JlLXJlYWN0ZG9tLXJlbmRlcicse0NvbXBvbmVudCxFcnJvckNvbXBvbmVudCxhcHBQcm9wc30pO3ZhciBlbGVtPS8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcENvbnRhaW5lcixudWxsLC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEFwcCxhcHBQcm9wcykpOy8vIFdlIGNhdGNoIHJ1bnRpbWUgZXJyb3JzIHVzaW5nIGNvbXBvbmVudERpZENhdGNoIHdoaWNoIHdpbGwgdHJpZ2dlciByZW5kZXJFcnJvclxucmVuZGVyUmVhY3RFbGVtZW50KHByb2Nlc3MuZW52Ll9fTkVYVF9TVFJJQ1RfTU9ERT8vKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfcmVhY3QuZGVmYXVsdC5TdHJpY3RNb2RlLG51bGwsZWxlbSk6ZWxlbSxhcHBFbGVtZW50KTtlbWl0dGVyLmVtaXQoJ2FmdGVyLXJlYWN0ZG9tLXJlbmRlcicse0NvbXBvbmVudCxFcnJvckNvbXBvbmVudCxhcHBQcm9wc30pO30iLCJcInVzZSBzdHJpY3RcIjt2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdD1yZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7dmFyIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkPXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlV2lsZGNhcmRcIik7dmFyIG5leHQ9X2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vXCIpKTt2YXIgX2V2ZW50U291cmNlUG9seWZpbGw9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9kZXYvZXZlbnQtc291cmNlLXBvbHlmaWxsXCIpKTt2YXIgX29uRGVtYW5kRW50cmllc0NsaWVudD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Rldi9vbi1kZW1hbmQtZW50cmllcy1jbGllbnRcIikpO3ZhciBfd2VicGFja0hvdE1pZGRsZXdhcmVDbGllbnQ9X2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9kZXYvd2VicGFjay1ob3QtbWlkZGxld2FyZS1jbGllbnRcIikpO3ZhciBfZGV2QnVpbGRXYXRjaGVyPV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZGV2L2Rldi1idWlsZC13YXRjaGVyXCIpKTt2YXIgX3ByZXJlbmRlckluZGljYXRvcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2Rldi9wcmVyZW5kZXItaW5kaWNhdG9yXCIpKTt2YXIgX2ZvdWM9cmVxdWlyZShcIi4vZGV2L2ZvdWNcIik7LyogZ2xvYmFscyBpbXBvcnQoJy4vZGV2L25vb3AnKTsgKi8gLy8gVGVtcG9yYXJ5IHdvcmthcm91bmQgZm9yIHRoZSBpc3N1ZSBkZXNjcmliZWQgaGVyZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96ZWl0L25leHQuanMvaXNzdWVzLzM3NzUjaXNzdWVjb21tZW50LTQwNzQzODEyM1xuLy8gVGhlIHJ1bnRpbWVDaHVuayBkb2Vzbid0IGhhdmUgZHluYW1pYyBpbXBvcnQgaGFuZGxpbmcgY29kZSB3aGVuIHRoZXJlIGhhc24ndCBiZWVuIGEgZHluYW1pYyBpbXBvcnRcbi8vIFRoZSBydW50aW1lQ2h1bmsgY2FuJ3QgaG90IHJlbG9hZCBpdHNlbGYgY3VycmVudGx5IHRvIGNvcnJlY3QgaXQgd2hlbiBhZGRpbmcgcGFnZXMgdXNpbmcgb24tZGVtYW5kLWVudHJpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbmltcG9ydCgnLi9kZXYvbm9vcCcpOzsvLyBTdXBwb3J0IEV2ZW50U291cmNlIG9uIEludGVybmV0IEV4cGxvcmVyIDExXG5pZighd2luZG93LkV2ZW50U291cmNlKXt3aW5kb3cuRXZlbnRTb3VyY2U9X2V2ZW50U291cmNlUG9seWZpbGwuZGVmYXVsdDt9dmFye19fTkVYVF9EQVRBX186e2Fzc2V0UHJlZml4fX09d2luZG93O3ZhciBwcmVmaXg9YXNzZXRQcmVmaXh8fCcnO3ZhciB3ZWJwYWNrSE1SPSgwLF93ZWJwYWNrSG90TWlkZGxld2FyZUNsaWVudC5kZWZhdWx0KSh7YXNzZXRQcmVmaXg6cHJlZml4fSk7d2luZG93Lm5leHQ9bmV4dDsoMCxuZXh0LmRlZmF1bHQpKHt3ZWJwYWNrSE1SfSkudGhlbigoX3JlZik9Pnt2YXJ7ZW1pdHRlcixyZW5kZXJDdHgscmVuZGVyfT1fcmVmOygwLF9vbkRlbWFuZEVudHJpZXNDbGllbnQuZGVmYXVsdCkoe2Fzc2V0UHJlZml4OnByZWZpeH0pO2lmKHByb2Nlc3MuZW52Ll9fTkVYVF9CVUlMRF9JTkRJQ0FUT1IpKDAsX2RldkJ1aWxkV2F0Y2hlci5kZWZhdWx0KSgpO2lmKHByb2Nlc3MuZW52Ll9fTkVYVF9QUkVSRU5ERVJfSU5ESUNBVE9SJiYvLyBkaXNhYmxlIGJ5IGRlZmF1bHQgaW4gZWxlY3Ryb25cbiEodHlwZW9mIHByb2Nlc3MhPT0ndW5kZWZpbmVkJyYmJ2VsZWN0cm9uJ2luIHByb2Nlc3MudmVyc2lvbnMpKXsoMCxfcHJlcmVuZGVySW5kaWNhdG9yLmRlZmF1bHQpKCk7fS8vIGRlbGF5IHJlbmRlcmluZyB1bnRpbCBhZnRlciBzdHlsZXMgaGF2ZSBiZWVuIGFwcGxpZWQgaW4gZGV2ZWxvcG1lbnRcbigwLF9mb3VjLmRpc3BsYXlDb250ZW50KSgoKT0+e3JlbmRlcihyZW5kZXJDdHgpO30pO3ZhciBsYXN0U2Nyb2xsO2VtaXR0ZXIub24oJ2JlZm9yZS1yZWFjdGRvbS1yZW5kZXInLChfcmVmMik9Pnt2YXJ7Q29tcG9uZW50LEVycm9yQ29tcG9uZW50fT1fcmVmMjsvLyBSZW1lbWJlciBzY3JvbGwgd2hlbiBFcnJvckNvbXBvbmVudCBpcyBiZWluZyByZW5kZXJlZCB0byBsYXRlciByZXN0b3JlIGl0XG5pZighbGFzdFNjcm9sbCYmQ29tcG9uZW50PT09RXJyb3JDb21wb25lbnQpe3ZhcntwYWdlWE9mZnNldCxwYWdlWU9mZnNldH09d2luZG93O2xhc3RTY3JvbGw9e3g6cGFnZVhPZmZzZXQseTpwYWdlWU9mZnNldH07fX0pO2VtaXR0ZXIub24oJ2FmdGVyLXJlYWN0ZG9tLXJlbmRlcicsKF9yZWYzKT0+e3ZhcntDb21wb25lbnQsRXJyb3JDb21wb25lbnR9PV9yZWYzO2lmKGxhc3RTY3JvbGwmJkNvbXBvbmVudCE9PUVycm9yQ29tcG9uZW50KXsvLyBSZXN0b3JlIHNjcm9sbCBhZnRlciBFcnJvckNvbXBvbmVudCB3YXMgcmVwbGFjZWQgd2l0aCBhIHBhZ2UgY29tcG9uZW50IGJ5IEhNUlxudmFye3gseX09bGFzdFNjcm9sbDt3aW5kb3cuc2Nyb2xsKHgseSk7bGFzdFNjcm9sbD1udWxsO319KTt9KS5jYXRjaChlcnI9Pntjb25zb2xlLmVycm9yKCdFcnJvciB3YXMgbm90IGNhdWdodCcsZXJyKTt9KTsiLCJcInVzZSBzdHJpY3RcIjt2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdD1yZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy5kZWZhdWx0PXZvaWQgMDt2YXIgX3VybD1yZXF1aXJlKFwidXJsXCIpO3ZhciBfbWl0dD1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi9uZXh0LXNlcnZlci9saWIvbWl0dFwiKSk7dmFyIF9pc0R5bmFtaWM9cmVxdWlyZShcIi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljXCIpO3ZhciBfcm91dGVNYXRjaGVyPXJlcXVpcmUoXCIuLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtbWF0Y2hlclwiKTt2YXIgX3JvdXRlUmVnZXg9cmVxdWlyZShcIi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9yb3V0ZS1yZWdleFwiKTt2YXIgX3JvdXRlcj1yZXF1aXJlKFwiLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlclwiKTtmdW5jdGlvbiBoYXNSZWwocmVsLGxpbmspe3RyeXtsaW5rPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtyZXR1cm4gbGluay5yZWxMaXN0LnN1cHBvcnRzKHJlbCk7fWNhdGNoKF91bnVzZWQpe319dmFyIHJlbFByZWZldGNoPWhhc1JlbCgncHJlbG9hZCcpJiYhaGFzUmVsKCdwcmVmZXRjaCcpPy8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI2ZlYXQ9bGluay1yZWwtcHJlbG9hZFxuLy8gbWFjT1MgYW5kIGlPUyAoU2FmYXJpIGRvZXMgbm90IHN1cHBvcnQgcHJlZmV0Y2gpXG4ncHJlbG9hZCc6Ly8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jZmVhdD1saW5rLXJlbC1wcmVmZXRjaFxuLy8gSUUgMTEsIEVkZ2UgMTIrLCBuZWFybHkgYWxsIGV2ZXJncmVlblxuJ3ByZWZldGNoJzt2YXIgaGFzTm9Nb2R1bGU9KCdub01vZHVsZSdpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSk7LyoqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZSAqL2Z1bmN0aW9uIG5vcm1hbGl6ZVJvdXRlKHJvdXRlKXtpZihyb3V0ZVswXSE9PScvJyl7dGhyb3cgbmV3IEVycm9yKFwiUm91dGUgbmFtZSBzaG91bGQgc3RhcnQgd2l0aCBhIFxcXCIvXFxcIiwgZ290IFxcXCJcIityb3V0ZStcIlxcXCJcIik7fXJvdXRlPXJvdXRlLnJlcGxhY2UoL1xcL2luZGV4JC8sJy8nKTtpZihyb3V0ZT09PScvJylyZXR1cm4gcm91dGU7cmV0dXJuIHJvdXRlLnJlcGxhY2UoL1xcLyQvLCcnKTt9ZnVuY3Rpb24gYXBwZW5kTGluayhocmVmLHJlbCxhcyl7cmV0dXJuIG5ldyBQcm9taXNlKChyZXMscmVqLGxpbmspPT57bGluaz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJyk7bGluay5jcm9zc09yaWdpbj1wcm9jZXNzLmNyb3NzT3JpZ2luO2xpbmsuaHJlZj1ocmVmO2xpbmsucmVsPXJlbDtpZihhcylsaW5rLmFzPWFzO2xpbmsub25sb2FkPXJlcztsaW5rLm9uZXJyb3I9cmVqO2RvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluayk7fSk7fWNsYXNzIFBhZ2VMb2FkZXJ7Y29uc3RydWN0b3IoYnVpbGRJZCxhc3NldFByZWZpeCl7dGhpcy5idWlsZElkPWJ1aWxkSWQ7dGhpcy5hc3NldFByZWZpeD1hc3NldFByZWZpeDt0aGlzLnBhZ2VDYWNoZT17fTt0aGlzLnBhZ2VSZWdpc3RlckV2ZW50cz0oMCxfbWl0dC5kZWZhdWx0KSgpO3RoaXMubG9hZGluZ1JvdXRlcz17fTtpZihwcm9jZXNzLmVudi5fX05FWFRfR1JBTlVMQVJfQ0hVTktTKXt0aGlzLnByb21pc2VkQnVpbGRNYW5pZmVzdD1uZXcgUHJvbWlzZShyZXNvbHZlPT57aWYod2luZG93Ll9fQlVJTERfTUFOSUZFU1Qpe3Jlc29sdmUod2luZG93Ll9fQlVJTERfTUFOSUZFU1QpO31lbHNle3dpbmRvdy5fX0JVSUxEX01BTklGRVNUX0NCPSgpPT57cmVzb2x2ZSh3aW5kb3cuX19CVUlMRF9NQU5JRkVTVCk7fTt9fSk7fS8qKiBAdHlwZSB7UHJvbWlzZTxTZXQ8c3RyaW5nPj59ICovdGhpcy5wcm9taXNlZFNzZ01hbmlmZXN0PW5ldyBQcm9taXNlKHJlc29sdmU9PntpZih3aW5kb3cuX19TU0dfTUFOSUZFU1Qpe3Jlc29sdmUod2luZG93Ll9fU1NHX01BTklGRVNUKTt9ZWxzZXt3aW5kb3cuX19TU0dfTUFOSUZFU1RfQ0I9KCk9PntyZXNvbHZlKHdpbmRvdy5fX1NTR19NQU5JRkVTVCk7fTt9fSk7fS8vIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZGVwZW5kZW5jaWVzIGZvciBhIHBhcnRpY3VsYXIgcm91dGVcbmdldERlcGVuZGVuY2llcyhyb3V0ZSl7cmV0dXJuIHRoaXMucHJvbWlzZWRCdWlsZE1hbmlmZXN0LnRoZW4obWFuPT5tYW5bcm91dGVdJiZtYW5bcm91dGVdLm1hcCh1cmw9PnRoaXMuYXNzZXRQcmVmaXgrXCIvX25leHQvXCIrZW5jb2RlVVJJKHVybCkpfHxbXSk7fS8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiB0aGUgcm91dGUgaHJlZiAoZmlsZS1zeXN0ZW0gcGF0aClcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFzUGF0aCB0aGUgVVJMIGFzIHNob3duIGluIGJyb3dzZXIgKHZpcnR1YWwgcGF0aCk7IHVzZWQgZm9yIGR5bmFtaWMgcm91dGVzXG4gICAqL2dldERhdGFIcmVmKGhyZWYsYXNQYXRoKXt2YXIgZ2V0SHJlZkZvclNsdWc9LyoqIEB0eXBlIHN0cmluZyAqL3BhdGg9PntwYXRoPSgwLF9yb3V0ZXIuZGVsQmFzZVBhdGgpKHBhdGgpO3JldHVybiB0aGlzLmFzc2V0UHJlZml4K1wiL19uZXh0L2RhdGEvXCIrdGhpcy5idWlsZElkKyhwYXRoPT09Jy8nPycvaW5kZXgnOnBhdGgpK1wiLmpzb25cIjt9O3ZhcntwYXRobmFtZTpocmVmUGF0aG5hbWUscXVlcnl9PSgwLF91cmwucGFyc2UpKGhyZWYsdHJ1ZSk7dmFye3BhdGhuYW1lOmFzUGF0aG5hbWV9PSgwLF91cmwucGFyc2UpKGFzUGF0aCk7dmFyIHJvdXRlPW5vcm1hbGl6ZVJvdXRlKGhyZWZQYXRobmFtZSk7dmFyIGlzRHluYW1pYz0oMCxfaXNEeW5hbWljLmlzRHluYW1pY1JvdXRlKShyb3V0ZSksaW50ZXJwb2xhdGVkUm91dGU7aWYoaXNEeW5hbWljKXt2YXIgZHluYW1pY1JlZ2V4PSgwLF9yb3V0ZVJlZ2V4LmdldFJvdXRlUmVnZXgpKHJvdXRlKTt2YXIgZHluYW1pY0dyb3Vwcz1keW5hbWljUmVnZXguZ3JvdXBzO3ZhciBkeW5hbWljTWF0Y2hlcz0vLyBUcnkgdG8gbWF0Y2ggdGhlIGR5bmFtaWMgcm91dGUgYWdhaW5zdCB0aGUgYXNQYXRoXG4oMCxfcm91dGVNYXRjaGVyLmdldFJvdXRlTWF0Y2hlcikoZHluYW1pY1JlZ2V4KShhc1BhdGhuYW1lKXx8Ly8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgdGhlIHZhbHVlcyBmcm9tIHRoZSBocmVmXG4vLyBUT0RPOiBzaG91bGQgdGhpcyB0YWtlIHByaW9yaXR5OyBhbHNvIG5lZWQgdG8gY2hhbmdlIGluIHRoZSByb3V0ZXIuXG5xdWVyeTtpbnRlcnBvbGF0ZWRSb3V0ZT1yb3V0ZTtpZighT2JqZWN0LmtleXMoZHluYW1pY0dyb3VwcykuZXZlcnkocGFyYW09Pnt2YXIgdmFsdWU9ZHluYW1pY01hdGNoZXNbcGFyYW1dO3ZhciByZXBlYXQ9ZHluYW1pY0dyb3Vwc1twYXJhbV0ucmVwZWF0Oy8vIHN1cHBvcnQgc2luZ2xlLWxldmVsIGNhdGNoLWFsbFxuLy8gVE9ETzogbW9yZSByb2J1c3QgaGFuZGxpbmcgZm9yIHVzZXItZXJyb3IgKHBhc3NpbmcgYC9gKVxuaWYocmVwZWF0JiYhQXJyYXkuaXNBcnJheSh2YWx1ZSkpdmFsdWU9W3ZhbHVlXTtyZXR1cm4gcGFyYW0gaW4gZHluYW1pY01hdGNoZXMmJigvLyBJbnRlcnBvbGF0ZSBncm91cCBpbnRvIGRhdGEgVVJMIGlmIHByZXNlbnRcbmludGVycG9sYXRlZFJvdXRlPWludGVycG9sYXRlZFJvdXRlLnJlcGxhY2UoXCJbXCIrKHJlcGVhdD8nLi4uJzonJykrcGFyYW0rXCJdXCIscmVwZWF0P3ZhbHVlLm1hcChlbmNvZGVVUklDb21wb25lbnQpLmpvaW4oJy8nKTplbmNvZGVVUklDb21wb25lbnQodmFsdWUpKSk7fSkpe2ludGVycG9sYXRlZFJvdXRlPScnOy8vIGRpZCBub3Qgc2F0aXNmeSBhbGwgcmVxdWlyZW1lbnRzXG4vLyBuLmIuIFdlIGlnbm9yZSB0aGlzIGVycm9yIGJlY2F1c2Ugd2UgaGFuZGxlIHdhcm5pbmcgZm9yIHRoaXMgY2FzZSBpblxuLy8gZGV2ZWxvcG1lbnQgaW4gdGhlIGA8TGluaz5gIGNvbXBvbmVudCBkaXJlY3RseS5cbn19cmV0dXJuIGlzRHluYW1pYz9pbnRlcnBvbGF0ZWRSb3V0ZSYmZ2V0SHJlZkZvclNsdWcoaW50ZXJwb2xhdGVkUm91dGUpOmdldEhyZWZGb3JTbHVnKHJvdXRlKTt9LyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIHRoZSByb3V0ZSBocmVmIChmaWxlLXN5c3RlbSBwYXRoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXNQYXRoIHRoZSBVUkwgYXMgc2hvd24gaW4gYnJvd3NlciAodmlydHVhbCBwYXRoKTsgdXNlZCBmb3IgZHluYW1pYyByb3V0ZXNcbiAgICovcHJlZmV0Y2hEYXRhKGhyZWYsYXNQYXRoKXt2YXJ7cGF0aG5hbWU6aHJlZlBhdGhuYW1lfT0oMCxfdXJsLnBhcnNlKShocmVmLHRydWUpO3ZhciByb3V0ZT1ub3JtYWxpemVSb3V0ZShocmVmUGF0aG5hbWUpO3JldHVybiB0aGlzLnByb21pc2VkU3NnTWFuaWZlc3QudGhlbigocyxfZGF0YUhyZWYpPT4vLyBDaGVjayBpZiB0aGUgcm91dGUgcmVxdWlyZXMgYSBkYXRhIGZpbGVcbnMuaGFzKHJvdXRlKSYmKC8vIFRyeSB0byBnZW5lcmF0ZSBkYXRhIGhyZWYsIG5vb3Agd2hlbiBmYWxzeVxuX2RhdGFIcmVmPXRoaXMuZ2V0RGF0YUhyZWYoaHJlZixhc1BhdGgpKSYmLy8gbm9vcCB3aGVuIGRhdGEgaGFzIGFscmVhZHkgYmVlbiBwcmVmZXRjaGVkIChkZWR1cGUpXG4hZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImxpbmtbcmVsPVxcXCJcIityZWxQcmVmZXRjaCtcIlxcXCJdW2hyZWZePVxcXCJcIitfZGF0YUhyZWYrXCJcXFwiXVwiKSYmLy8gSW5qZWN0IHRoZSBgPGxpbmsgcmVsPXByZWZldGNoPmAgdGFnIGZvciBhYm92ZSBjb21wdXRlZCBgaHJlZmAuXG5hcHBlbmRMaW5rKF9kYXRhSHJlZixyZWxQcmVmZXRjaCwnZmV0Y2gnKSk7fWxvYWRQYWdlKHJvdXRlKXtyZXR1cm4gdGhpcy5sb2FkUGFnZVNjcmlwdChyb3V0ZSk7fWxvYWRQYWdlU2NyaXB0KHJvdXRlKXtyb3V0ZT1ub3JtYWxpemVSb3V0ZShyb3V0ZSk7cmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLHJlamVjdCk9Pnt2YXIgZmlyZT0oX3JlZik9Pnt2YXJ7ZXJyb3IscGFnZSxtb2R9PV9yZWY7dGhpcy5wYWdlUmVnaXN0ZXJFdmVudHMub2ZmKHJvdXRlLGZpcmUpO2RlbGV0ZSB0aGlzLmxvYWRpbmdSb3V0ZXNbcm91dGVdO2lmKGVycm9yKXtyZWplY3QoZXJyb3IpO31lbHNle3Jlc29sdmUoe3BhZ2UsbW9kfSk7fX07Ly8gSWYgdGhlcmUncyBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoZSBwYWdlLCBsZXQncyB1c2UgaXQuXG52YXIgY2FjaGVkUGFnZT10aGlzLnBhZ2VDYWNoZVtyb3V0ZV07aWYoY2FjaGVkUGFnZSl7dmFye2Vycm9yLHBhZ2UsbW9kfT1jYWNoZWRQYWdlO2Vycm9yP3JlamVjdChlcnJvcik6cmVzb2x2ZSh7cGFnZSxtb2R9KTtyZXR1cm47fS8vIFJlZ2lzdGVyIGEgbGlzdGVuZXIgdG8gZ2V0IHRoZSBwYWdlXG50aGlzLnBhZ2VSZWdpc3RlckV2ZW50cy5vbihyb3V0ZSxmaXJlKTsvLyBJZiB0aGUgcGFnZSBpcyBsb2FkaW5nIHZpYSBTU1IsIHdlIG5lZWQgdG8gd2FpdCBmb3IgaXRcbi8vIHJhdGhlciBkb3dubG9hZGluZyBpdCBhZ2Fpbi5cbmlmKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJzY3JpcHRbZGF0YS1uZXh0LXBhZ2U9XFxcIlwiK3JvdXRlK1wiXFxcIl1cIikpe3JldHVybjt9aWYoIXRoaXMubG9hZGluZ1JvdXRlc1tyb3V0ZV0pe3RoaXMubG9hZGluZ1JvdXRlc1tyb3V0ZV09dHJ1ZTtpZihwcm9jZXNzLmVudi5fX05FWFRfR1JBTlVMQVJfQ0hVTktTKXt0aGlzLmdldERlcGVuZGVuY2llcyhyb3V0ZSkudGhlbihkZXBzPT57ZGVwcy5mb3JFYWNoKGQ9PntpZigvXFwuanMkLy50ZXN0KGQpJiYhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInNjcmlwdFtzcmNePVxcXCJcIitkK1wiXFxcIl1cIikpe3RoaXMubG9hZFNjcmlwdChkLHJvdXRlLGZhbHNlKTt9aWYoL1xcLmNzcyQvLnRlc3QoZCkmJiFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibGlua1tyZWw9c3R5bGVzaGVldF1baHJlZl49XFxcIlwiK2QrXCJcXFwiXVwiKSl7YXBwZW5kTGluayhkLCdzdHlsZXNoZWV0JykuY2F0Y2goKCk9PnsvLyBGSVhNRTogaGFuZGxlIGZhaWx1cmVcbi8vIFJpZ2h0IG5vdywgdGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudCBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uLlxufSk7fX0pO3RoaXMubG9hZFJvdXRlKHJvdXRlKTt9KTt9ZWxzZXt0aGlzLmxvYWRSb3V0ZShyb3V0ZSk7fX19KTt9bG9hZFJvdXRlKHJvdXRlKXtyb3V0ZT1ub3JtYWxpemVSb3V0ZShyb3V0ZSk7dmFyIHNjcmlwdFJvdXRlPXJvdXRlPT09Jy8nPycvaW5kZXguanMnOnJvdXRlK1wiLmpzXCI7dmFyIHVybD10aGlzLmFzc2V0UHJlZml4K1wiL19uZXh0L3N0YXRpYy9cIitlbmNvZGVVUklDb21wb25lbnQodGhpcy5idWlsZElkKStcIi9wYWdlc1wiK2VuY29kZVVSSShzY3JpcHRSb3V0ZSk7dGhpcy5sb2FkU2NyaXB0KHVybCxyb3V0ZSx0cnVlKTt9bG9hZFNjcmlwdCh1cmwscm91dGUsaXNQYWdlKXt2YXIgc2NyaXB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO2lmKHByb2Nlc3MuZW52Ll9fTkVYVF9NT0RFUk5fQlVJTEQmJmhhc05vTW9kdWxlKXtzY3JpcHQudHlwZT0nbW9kdWxlJzsvLyBPbmx5IHBhZ2UgYnVuZGxlIHNjcmlwdHMgbmVlZCB0byBoYXZlIC5tb2R1bGUgYWRkZWQgdG8gdXJsLFxuLy8gZGVwZW5kZW5jaWVzIGFscmVhZHkgaGF2ZSBpdCBhZGRlZCBkdXJpbmcgYnVpbGQgbWFuaWZlc3QgY3JlYXRpb25cbmlmKGlzUGFnZSl1cmw9dXJsLnJlcGxhY2UoL1xcLmpzJC8sJy5tb2R1bGUuanMnKTt9c2NyaXB0LmNyb3NzT3JpZ2luPXByb2Nlc3MuY3Jvc3NPcmlnaW47c2NyaXB0LnNyYz11cmw7c2NyaXB0Lm9uZXJyb3I9KCk9Pnt2YXIgZXJyb3I9bmV3IEVycm9yKFwiRXJyb3IgbG9hZGluZyBzY3JpcHQgXCIrdXJsKTtlcnJvci5jb2RlPSdQQUdFX0xPQURfRVJST1InO3RoaXMucGFnZVJlZ2lzdGVyRXZlbnRzLmVtaXQocm91dGUse2Vycm9yfSk7fTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7fS8vIFRoaXMgbWV0aG9kIGlmIGNhbGxlZCBieSB0aGUgcm91dGUgY29kZS5cbnJlZ2lzdGVyUGFnZShyb3V0ZSxyZWdGbil7dmFyIHJlZ2lzdGVyPSgpPT57dHJ5e3ZhciBtb2Q9cmVnRm4oKTt2YXIgcGFnZURhdGE9e3BhZ2U6bW9kLmRlZmF1bHR8fG1vZCxtb2R9O3RoaXMucGFnZUNhY2hlW3JvdXRlXT1wYWdlRGF0YTt0aGlzLnBhZ2VSZWdpc3RlckV2ZW50cy5lbWl0KHJvdXRlLHBhZ2VEYXRhKTt9Y2F0Y2goZXJyb3Ipe3RoaXMucGFnZUNhY2hlW3JvdXRlXT17ZXJyb3J9O3RoaXMucGFnZVJlZ2lzdGVyRXZlbnRzLmVtaXQocm91dGUse2Vycm9yfSk7fX07aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlYhPT0ncHJvZHVjdGlvbicpey8vIFdhaXQgZm9yIHdlYnBhY2sgdG8gYmVjb21lIGlkbGUgaWYgaXQncyBub3QuXG4vLyBNb3JlIGluZm86IGh0dHBzOi8vZ2l0aHViLmNvbS96ZWl0L25leHQuanMvcHVsbC8xNTExXG5pZihtb2R1bGUuaG90JiZtb2R1bGUuaG90LnN0YXR1cygpIT09J2lkbGUnKXtjb25zb2xlLmxvZyhcIldhaXRpbmcgZm9yIHdlYnBhY2sgdG8gYmVjb21lIFxcXCJpZGxlXFxcIiB0byBpbml0aWFsaXplIHRoZSBwYWdlOiBcXFwiXCIrcm91dGUrXCJcXFwiXCIpO3ZhciBjaGVjaz1zdGF0dXM9PntpZihzdGF0dXM9PT0naWRsZScpe21vZHVsZS5ob3QucmVtb3ZlU3RhdHVzSGFuZGxlcihjaGVjayk7cmVnaXN0ZXIoKTt9fTttb2R1bGUuaG90LnN0YXR1cyhjaGVjayk7cmV0dXJuO319cmVnaXN0ZXIoKTt9LyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlcGVuZGVuY3ldXG4gICAqL3ByZWZldGNoKHJvdXRlLGlzRGVwZW5kZW5jeSl7Ly8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvcXVpY2tsaW5rL2Jsb2IvNDUzYTY2MWZhMWZhOTQwZTJkMmUwNDQ0NTIzOThlMzhjNjdhOThmYi9zcmMvaW5kZXgubWpzI0wxMTUtTDExOFxuLy8gTGljZW5zZTogQXBhY2hlIDIuMFxudmFyIGNuO2lmKGNuPW5hdmlnYXRvci5jb25uZWN0aW9uKXsvLyBEb24ndCBwcmVmZXRjaCBpZiB1c2luZyAyRyBvciBpZiBTYXZlLURhdGEgaXMgZW5hYmxlZC5cbmlmKGNuLnNhdmVEYXRhfHwvMmcvLnRlc3QoY24uZWZmZWN0aXZlVHlwZSkpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO30vKiogQHR5cGUge3N0cmluZ30gKi92YXIgdXJsO2lmKGlzRGVwZW5kZW5jeSl7dXJsPXJvdXRlO31lbHNle3JvdXRlPW5vcm1hbGl6ZVJvdXRlKHJvdXRlKTt2YXIgc2NyaXB0Um91dGU9KHJvdXRlPT09Jy8nPycvaW5kZXgnOnJvdXRlKStcIi5qc1wiO2lmKHByb2Nlc3MuZW52Ll9fTkVYVF9NT0RFUk5fQlVJTEQmJmhhc05vTW9kdWxlKXtzY3JpcHRSb3V0ZT1zY3JpcHRSb3V0ZS5yZXBsYWNlKC9cXC5qcyQvLCcubW9kdWxlLmpzJyk7fXVybD10aGlzLmFzc2V0UHJlZml4K1wiL19uZXh0L3N0YXRpYy9cIitlbmNvZGVVUklDb21wb25lbnQodGhpcy5idWlsZElkKStcIi9wYWdlc1wiK2VuY29kZVVSSShzY3JpcHRSb3V0ZSk7fXJldHVybiBQcm9taXNlLmFsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibGlua1tyZWw9XFxcIlwiK3JlbFByZWZldGNoK1wiXFxcIl1baHJlZl49XFxcIlwiK3VybCtcIlxcXCJdLCBzY3JpcHRbZGF0YS1uZXh0LXBhZ2U9XFxcIlwiK3JvdXRlK1wiXFxcIl1cIik/W106W2FwcGVuZExpbmsodXJsLHJlbFByZWZldGNoLHVybC5tYXRjaCgvXFwuY3NzJC8pPydzdHlsZSc6J3NjcmlwdCcpLHByb2Nlc3MuZW52Ll9fTkVYVF9HUkFOVUxBUl9DSFVOS1MmJiFpc0RlcGVuZGVuY3kmJnRoaXMuZ2V0RGVwZW5kZW5jaWVzKHJvdXRlKS50aGVuKHVybHM9PlByb21pc2UuYWxsKHVybHMubWFwKHVybD0+dGhpcy5wcmVmZXRjaCh1cmwsdHJ1ZSkpKSldKS50aGVuKC8vIGRvIG5vdCByZXR1cm4gYW55IGRhdGFcbigpPT57fSwvLyBzd2FsbG93IHByZWZldGNoIGVycm9yc1xuKCk9Pnt9KTt9fWV4cG9ydHMuZGVmYXVsdD1QYWdlTG9hZGVyOyIsIlwidXNlIHN0cmljdFwiO2V4cG9ydHMuX19lc01vZHVsZT10cnVlO2V4cG9ydHMuZGVmYXVsdD12b2lkIDA7dmFyIF93ZWJWaXRhbHM9cmVxdWlyZShcIndlYi12aXRhbHNcIik7dmFyIF9kZWZhdWx0PW9uUGVyZkVudHJ5PT57KDAsX3dlYlZpdGFscy5nZXRDTFMpKG9uUGVyZkVudHJ5KTsoMCxfd2ViVml0YWxzLmdldEZJRCkob25QZXJmRW50cnkpOygwLF93ZWJWaXRhbHMuZ2V0RkNQKShvblBlcmZFbnRyeSk7KDAsX3dlYlZpdGFscy5nZXRMQ1ApKG9uUGVyZkVudHJ5KTsoMCxfd2ViVml0YWxzLmdldFRURkIpKG9uUGVyZkVudHJ5KTt9O2V4cG9ydHMuZGVmYXVsdD1fZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjt2YXIgX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ9cmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVXaWxkY2FyZFwiKTt2YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdD1yZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7ZXhwb3J0cy5fX2VzTW9kdWxlPXRydWU7ZXhwb3J0cy51c2VSb3V0ZXI9dXNlUm91dGVyO2V4cG9ydHMubWFrZVB1YmxpY1JvdXRlckluc3RhbmNlPW1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZTtleHBvcnRzLmNyZWF0ZVJvdXRlcj1leHBvcnRzLndpdGhSb3V0ZXI9ZXhwb3J0cy5kZWZhdWx0PXZvaWQgMDt2YXIgX3JlYWN0PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTt2YXIgX3JvdXRlcjI9X2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcm91dGVyXCIpKTtleHBvcnRzLlJvdXRlcj1fcm91dGVyMi5kZWZhdWx0O2V4cG9ydHMuTmV4dFJvdXRlcj1fcm91dGVyMi5OZXh0Um91dGVyO3ZhciBfcm91dGVyQ29udGV4dD1yZXF1aXJlKFwiLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0XCIpO3ZhciBfd2l0aFJvdXRlcj1faW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3dpdGgtcm91dGVyXCIpKTtleHBvcnRzLndpdGhSb3V0ZXI9X3dpdGhSb3V0ZXIuZGVmYXVsdDsvKiBnbG9iYWwgd2luZG93ICovdmFyIHNpbmdsZXRvblJvdXRlcj17cm91dGVyOm51bGwsLy8gaG9sZHMgdGhlIGFjdHVhbCByb3V0ZXIgaW5zdGFuY2VcbnJlYWR5Q2FsbGJhY2tzOltdLHJlYWR5KGNiKXtpZih0aGlzLnJvdXRlcilyZXR1cm4gY2IoKTtpZih0eXBlb2Ygd2luZG93IT09J3VuZGVmaW5lZCcpe3RoaXMucmVhZHlDYWxsYmFja3MucHVzaChjYik7fX19Oy8vIENyZWF0ZSBwdWJsaWMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBvZiB0aGUgcm91dGVyIGluIHRoZSBzaW5nbGV0b25Sb3V0ZXJcbnZhciB1cmxQcm9wZXJ0eUZpZWxkcz1bJ3BhdGhuYW1lJywncm91dGUnLCdxdWVyeScsJ2FzUGF0aCcsJ2NvbXBvbmVudHMnLCdpc0ZhbGxiYWNrJywnYmFzZVBhdGgnXTt2YXIgcm91dGVyRXZlbnRzPVsncm91dGVDaGFuZ2VTdGFydCcsJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywncm91dGVDaGFuZ2VFcnJvcicsJ2hhc2hDaGFuZ2VTdGFydCcsJ2hhc2hDaGFuZ2VDb21wbGV0ZSddO3ZhciBjb3JlTWV0aG9kRmllbGRzPVsncHVzaCcsJ3JlcGxhY2UnLCdyZWxvYWQnLCdiYWNrJywncHJlZmV0Y2gnLCdiZWZvcmVQb3BTdGF0ZSddOy8vIEV2ZW50cyBpcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiB0aGUgcm91dGVyLCB0aGUgcm91dGVyIGRvZXNuJ3QgaGF2ZSB0byBiZSBpbml0aWFsaXplZCB0byB1c2UgaXRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsJ2V2ZW50cycse2dldCgpe3JldHVybiBfcm91dGVyMi5kZWZhdWx0LmV2ZW50czt9fSk7dXJsUHJvcGVydHlGaWVsZHMuZm9yRWFjaChmaWVsZD0+ey8vIEhlcmUgd2UgbmVlZCB0byB1c2UgT2JqZWN0LmRlZmluZVByb3BlcnR5IGJlY2F1c2UsIHdlIG5lZWQgdG8gcmV0dXJuXG4vLyB0aGUgcHJvcGVydHkgYXNzaWduZWQgdG8gdGhlIGFjdHVhbCByb3V0ZXJcbi8vIFRoZSB2YWx1ZSBtaWdodCBnZXQgY2hhbmdlZCBhcyB3ZSBjaGFuZ2Ugcm91dGVzIGFuZCB0aGlzIGlzIHRoZVxuLy8gcHJvcGVyIHdheSB0byBhY2Nlc3MgaXRcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsZmllbGQse2dldCgpe3ZhciByb3V0ZXI9Z2V0Um91dGVyKCk7cmV0dXJuIHJvdXRlcltmaWVsZF07fX0pO30pO2NvcmVNZXRob2RGaWVsZHMuZm9yRWFjaChmaWVsZD0+ey8vIFdlIGRvbid0IHJlYWxseSBrbm93IHRoZSB0eXBlcyBoZXJlLCBzbyB3ZSBhZGQgdGhlbSBsYXRlciBpbnN0ZWFkXG47c2luZ2xldG9uUm91dGVyW2ZpZWxkXT1mdW5jdGlvbigpe3ZhciByb3V0ZXI9Z2V0Um91dGVyKCk7cmV0dXJuIHJvdXRlcltmaWVsZF0oLi4uYXJndW1lbnRzKTt9O30pO3JvdXRlckV2ZW50cy5mb3JFYWNoKGV2ZW50PT57c2luZ2xldG9uUm91dGVyLnJlYWR5KCgpPT57X3JvdXRlcjIuZGVmYXVsdC5ldmVudHMub24oZXZlbnQsZnVuY3Rpb24oKXt2YXIgZXZlbnRGaWVsZD1cIm9uXCIrZXZlbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZXZlbnQuc3Vic3RyaW5nKDEpO3ZhciBfc2luZ2xldG9uUm91dGVyPXNpbmdsZXRvblJvdXRlcjtpZihfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKXt0cnl7X3NpbmdsZXRvblJvdXRlcltldmVudEZpZWxkXSguLi5hcmd1bWVudHMpO31jYXRjaChlcnIpey8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG5jb25zb2xlLmVycm9yKFwiRXJyb3Igd2hlbiBydW5uaW5nIHRoZSBSb3V0ZXIgZXZlbnQ6IFwiK2V2ZW50RmllbGQpOy8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG5jb25zb2xlLmVycm9yKGVyci5tZXNzYWdlK1wiXFxuXCIrZXJyLnN0YWNrKTt9fX0pO30pO30pO2Z1bmN0aW9uIGdldFJvdXRlcigpe2lmKCFzaW5nbGV0b25Sb3V0ZXIucm91dGVyKXt2YXIgbWVzc2FnZT0nTm8gcm91dGVyIGluc3RhbmNlIGZvdW5kLlxcbicrJ1lvdSBzaG91bGQgb25seSB1c2UgXCJuZXh0L3JvdXRlclwiIGluc2lkZSB0aGUgY2xpZW50IHNpZGUgb2YgeW91ciBhcHAuXFxuJzt0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7fXJldHVybiBzaW5nbGV0b25Sb3V0ZXIucm91dGVyO30vLyBFeHBvcnQgdGhlIHNpbmdsZXRvblJvdXRlciBhbmQgdGhpcyBpcyB0aGUgcHVibGljIEFQSS5cbnZhciBfZGVmYXVsdD1zaW5nbGV0b25Sb3V0ZXI7Ly8gUmVleHBvcnQgdGhlIHdpdGhSb3V0ZSBIT0NcbmV4cG9ydHMuZGVmYXVsdD1fZGVmYXVsdDtmdW5jdGlvbiB1c2VSb3V0ZXIoKXtyZXR1cm4gX3JlYWN0LmRlZmF1bHQudXNlQ29udGV4dChfcm91dGVyQ29udGV4dC5Sb3V0ZXJDb250ZXh0KTt9Ly8gSU5URVJOQUwgQVBJU1xuLy8gLS0tLS0tLS0tLS0tLVxuLy8gKGRvIG5vdCB1c2UgZm9sbG93aW5nIGV4cG9ydHMgaW5zaWRlIHRoZSBhcHApXG4vLyBDcmVhdGUgYSByb3V0ZXIgYW5kIGFzc2lnbiBpdCBhcyB0aGUgc2luZ2xldG9uIGluc3RhbmNlLlxuLy8gVGhpcyBpcyB1c2VkIGluIGNsaWVudCBzaWRlIHdoZW4gd2UgYXJlIGluaXRpbGl6aW5nIHRoZSBhcHAuXG4vLyBUaGlzIHNob3VsZCAqKm5vdCoqIHVzZSBpbnNpZGUgdGhlIHNlcnZlci5cbnZhciBjcmVhdGVSb3V0ZXI9ZnVuY3Rpb24gY3JlYXRlUm91dGVyKCl7Zm9yKHZhciBfbGVuPWFyZ3VtZW50cy5sZW5ndGgsYXJncz1uZXcgQXJyYXkoX2xlbiksX2tleT0wO19rZXk8X2xlbjtfa2V5Kyspe2FyZ3NbX2tleV09YXJndW1lbnRzW19rZXldO31zaW5nbGV0b25Sb3V0ZXIucm91dGVyPW5ldyBfcm91dGVyMi5kZWZhdWx0KC4uLmFyZ3MpO3NpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcy5mb3JFYWNoKGNiPT5jYigpKTtzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3M9W107cmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXI7fTsvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBgd2l0aFJvdXRlcmAgcm91dGVyIGluc3RhbmNlXG5leHBvcnRzLmNyZWF0ZVJvdXRlcj1jcmVhdGVSb3V0ZXI7ZnVuY3Rpb24gbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlKHJvdXRlcil7dmFyIF9yb3V0ZXI9cm91dGVyO3ZhciBpbnN0YW5jZT17fTtmb3IodmFyIHByb3BlcnR5IG9mIHVybFByb3BlcnR5RmllbGRzKXtpZih0eXBlb2YgX3JvdXRlcltwcm9wZXJ0eV09PT0nb2JqZWN0Jyl7aW5zdGFuY2VbcHJvcGVydHldPU9iamVjdC5hc3NpZ24oe30sX3JvdXRlcltwcm9wZXJ0eV0pOy8vIG1ha2VzIHN1cmUgcXVlcnkgaXMgbm90IHN0YXRlZnVsXG5jb250aW51ZTt9aW5zdGFuY2VbcHJvcGVydHldPV9yb3V0ZXJbcHJvcGVydHldO30vLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG5pbnN0YW5jZS5ldmVudHM9X3JvdXRlcjIuZGVmYXVsdC5ldmVudHM7Y29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKGZpZWxkPT57aW5zdGFuY2VbZmllbGRdPWZ1bmN0aW9uKCl7cmV0dXJuIF9yb3V0ZXJbZmllbGRdKC4uLmFyZ3VtZW50cyk7fTt9KTtyZXR1cm4gaW5zdGFuY2U7fSIsIlwidXNlIHN0cmljdFwiO3ZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0PXJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtleHBvcnRzLl9fZXNNb2R1bGU9dHJ1ZTtleHBvcnRzLmRlZmF1bHQ9d2l0aFJvdXRlcjt2YXIgX3JlYWN0PV9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTt2YXIgX3JvdXRlcj1yZXF1aXJlKFwiLi9yb3V0ZXJcIik7ZnVuY3Rpb24gd2l0aFJvdXRlcihDb21wb3NlZENvbXBvbmVudCl7ZnVuY3Rpb24gV2l0aFJvdXRlcldyYXBwZXIocHJvcHMpe3JldHVybi8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KENvbXBvc2VkQ29tcG9uZW50LE9iamVjdC5hc3NpZ24oe3JvdXRlcjooMCxfcm91dGVyLnVzZVJvdXRlcikoKX0scHJvcHMpKTt9V2l0aFJvdXRlcldyYXBwZXIuZ2V0SW5pdGlhbFByb3BzPUNvbXBvc2VkQ29tcG9uZW50LmdldEluaXRpYWxQcm9wcy8vIFRoaXMgaXMgbmVlZGVkIHRvIGFsbG93IGNoZWNraW5nIGZvciBjdXN0b20gZ2V0SW5pdGlhbFByb3BzIGluIF9hcHBcbjtXaXRoUm91dGVyV3JhcHBlci5vcmlnR2V0SW5pdGlhbFByb3BzPUNvbXBvc2VkQ29tcG9uZW50Lm9yaWdHZXRJbml0aWFsUHJvcHM7aWYocHJvY2Vzcy5lbnYuTk9ERV9FTlYhPT0ncHJvZHVjdGlvbicpe3ZhciBuYW1lPUNvbXBvc2VkQ29tcG9uZW50LmRpc3BsYXlOYW1lfHxDb21wb3NlZENvbXBvbmVudC5uYW1lfHwnVW5rbm93bic7V2l0aFJvdXRlcldyYXBwZXIuZGlzcGxheU5hbWU9XCJ3aXRoUm91dGVyKFwiK25hbWUrXCIpXCI7fXJldHVybiBXaXRoUm91dGVyV3JhcHBlcjt9IiwibW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgdD17fTtmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKHIpe2lmKHRbcl0pe3JldHVybiB0W3JdLmV4cG9ydHN9dmFyIG49dFtyXT17aTpyLGw6ZmFsc2UsZXhwb3J0czp7fX07ZVtyXS5jYWxsKG4uZXhwb3J0cyxuLG4uZXhwb3J0cyxfX3dlYnBhY2tfcmVxdWlyZV9fKTtuLmw9dHJ1ZTtyZXR1cm4gbi5leHBvcnRzfV9fd2VicGFja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO2Z1bmN0aW9uIHN0YXJ0dXAoKXtyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTUpfXJldHVybiBzdGFydHVwKCl9KHs4NDk6ZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPSgoe29ubHlGaXJzdDplPWZhbHNlfT17fSk9Pntjb25zdCByPVtcIltcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzpbYS16QS1aXFxcXGRdKig/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSopKik/XFxcXHUwMDA3KVwiLFwiKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1udHFyeT0+PH5dKSlcIl0uam9pbihcInxcIik7cmV0dXJuIG5ldyBSZWdFeHAocixlP3VuZGVmaW5lZDpcImdcIil9KX0sODU1OmZ1bmN0aW9uKGUscix0KXtcInVzZSBzdHJpY3RcIjtjb25zdCBuPXQoODQ5KTtlLmV4cG9ydHM9KGU9PnR5cGVvZiBlPT09XCJzdHJpbmdcIj9lLnJlcGxhY2UobigpLFwiXCIpOmUpfX0pOyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcbiAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbmV4cG9ydHMuSGVhZE1hbmFnZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZXhwb3J0cy5IZWFkTWFuYWdlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnSGVhZE1hbmFnZXJDb250ZXh0Jztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgSmFzb24gTWlsbGVyIChodHRwczovL2phc29uZm9ybWF0LmNvbS8pXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBtaXR0KCkge1xuICAgIGNvbnN0IGFsbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb24odHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgKGFsbFt0eXBlXSB8fCAoYWxsW3R5cGVdID0gW10pKS5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9LFxuICAgICAgICBvZmYodHlwZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKGFsbFt0eXBlXSkge1xuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgICAgICAgICAgICAgYWxsW3R5cGVdLnNwbGljZShhbGxbdHlwZV0uaW5kZXhPZihoYW5kbGVyKSA+Pj4gMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVtaXQodHlwZSwgLi4uZXZ0cykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgKGFsbFt0eXBlXSB8fCBbXSkuc2xpY2UoKS5tYXAoKGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKC4uLmV2dHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG1pdHQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFJlYWN0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5leHBvcnRzLlJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBleHBvcnRzLlJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnUm91dGVyQ29udGV4dCc7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IG1pdHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vbWl0dFwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgaXNfZHluYW1pY18xID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtZHluYW1pY1wiKTtcbmNvbnN0IHJvdXRlX21hdGNoZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCByb3V0ZV9yZWdleF8xID0gcmVxdWlyZShcIi4vdXRpbHMvcm91dGUtcmVnZXhcIik7XG5jb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJyc7XG5mdW5jdGlvbiBhZGRCYXNlUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGguaW5kZXhPZihiYXNlUGF0aCkgIT09IDAgPyBiYXNlUGF0aCArIHBhdGggOiBwYXRoO1xufVxuZXhwb3J0cy5hZGRCYXNlUGF0aCA9IGFkZEJhc2VQYXRoO1xuZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aCkge1xuICAgIHJldHVybiBwYXRoLmluZGV4T2YoYmFzZVBhdGgpID09PSAwXG4gICAgICAgID8gcGF0aC5zdWJzdHIoYmFzZVBhdGgubGVuZ3RoKSB8fCAnLydcbiAgICAgICAgOiBwYXRoO1xufVxuZXhwb3J0cy5kZWxCYXNlUGF0aCA9IGRlbEJhc2VQYXRoO1xuZnVuY3Rpb24gdG9Sb3V0ZShwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLyc7XG59XG5jb25zdCBwcmVwYXJlUm91dGUgPSAocGF0aCkgPT4gdG9Sb3V0ZSghcGF0aCB8fCBwYXRoID09PSAnLycgPyAnL2luZGV4JyA6IHBhdGgpO1xuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShwYXRobmFtZSwgcXVlcnksIGlzU2VydmVyUmVuZGVyLCBjYikge1xuICAgIGxldCBhdHRlbXB0cyA9IGlzU2VydmVyUmVuZGVyID8gMyA6IDE7XG4gICAgZnVuY3Rpb24gZ2V0UmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiBmZXRjaCh1dGlsc18xLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBhZGRCYXNlUGF0aChcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgX19ORVhUX0RBVEFfX1xuICAgICAgICAgICAgYC9fbmV4dC9kYXRhLyR7X19ORVhUX0RBVEFfXy5idWlsZElkfSR7ZGVsQmFzZVBhdGgocGF0aG5hbWUpfS5qc29uYCksXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgICAgICAgICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgICAgICAgICAgLy8gPiBvcHRpb24uXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJL1VzaW5nX0ZldGNoXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAgICAgICAgIC8vID4gcmVjZWl2aW5nIGNvb2tpZXMsIGFsd2F5cyBzdXBwbHkgdGhlIGBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ2BcbiAgICAgICAgICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgICAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgICAgIH0pLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgaWYgKC0tYXR0ZW1wdHMgPiAwICYmIHJlcy5zdGF0dXMgPj0gNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBwcm9wc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0UmVzcG9uc2UoKVxuICAgICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgcmV0dXJuIGNiID8gY2IoZGF0YSkgOiBkYXRhO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIC8vIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzIGNhdXNlZFxuICAgICAgICAvLyBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50byBhbiBpbmZpbml0ZVxuICAgICAgICAvLyBsb29wLlxuICAgICAgICBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBlcnIuY29kZSA9ICdQQUdFX0xPQURfRVJST1InO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbn1cbmNsYXNzIFJvdXRlciB7XG4gICAgY29uc3RydWN0b3IocGF0aG5hbWUsIHF1ZXJ5LCBhcywgeyBpbml0aWFsUHJvcHMsIHBhZ2VMb2FkZXIsIEFwcCwgd3JhcEFwcCwgQ29tcG9uZW50LCBlcnIsIHN1YnNjcmlwdGlvbiwgaXNGYWxsYmFjaywgfSkge1xuICAgICAgICAvLyBTdGF0aWMgRGF0YSBDYWNoZVxuICAgICAgICB0aGlzLnNkYyA9IHt9O1xuICAgICAgICB0aGlzLm9uUG9wU3RhdGUgPSAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAgICAgICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsIHV0aWxzXzEuZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZSwgcXVlcnkgfSksIHV0aWxzXzEuZ2V0VVJMKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgICAgICAgICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgICAgICAgICBpZiAoZS5zdGF0ZSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaXNTc3IgJiZcbiAgICAgICAgICAgICAgICBlLnN0YXRlLmFzID09PSB0aGlzLmFzUGF0aCAmJlxuICAgICAgICAgICAgICAgIHVybF8xLnBhcnNlKGUuc3RhdGUudXJsKS5wYXRobmFtZSA9PT0gdGhpcy5wYXRobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAgICAgICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoZS5zdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHVybCwgYXMsIG9wdGlvbnMgfSA9IGUuc3RhdGU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgYXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYHBvcHN0YXRlYCBldmVudCB0cmlnZ2VyZWQgYnV0IGBldmVudC5zdGF0ZWAgZGlkIG5vdCBoYXZlIGB1cmxgIG9yIGBhc2AgaHR0cHM6Ly9lcnIuc2gvemVpdC9uZXh0LmpzL3BvcHN0YXRlLXN0YXRlLWVtcHR5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXBsYWNlKHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9nZXRTdGF0aWNEYXRhID0gKGFzUGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF0aG5hbWUgPSBwcmVwYXJlUm91dGUodXJsXzEucGFyc2UoYXNQYXRoKS5wYXRobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLnNkY1twYXRobmFtZV1cbiAgICAgICAgICAgICAgICA/IFByb21pc2UucmVzb2x2ZSh0aGlzLnNkY1twYXRobmFtZV0pXG4gICAgICAgICAgICAgICAgOiBmZXRjaE5leHREYXRhKHBhdGhuYW1lLCBudWxsLCB0aGlzLmlzU3NyLCBkYXRhID0+ICh0aGlzLnNkY1twYXRobmFtZV0gPSBkYXRhKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2dldFNlcnZlckRhdGEgPSAoYXNQYXRoKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHVybF8xLnBhcnNlKGFzUGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICBwYXRobmFtZSA9IHByZXBhcmVSb3V0ZShwYXRobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YShwYXRobmFtZSwgcXVlcnksIHRoaXMuaXNTc3IpO1xuICAgICAgICB9O1xuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSBjdXJyZW50IGNvbXBvbmVudCBrZXlcbiAgICAgICAgdGhpcy5yb3V0ZSA9IHRvUm91dGUocGF0aG5hbWUpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0ge307XG4gICAgICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAgICAgLy8gY29tZSBhZ2FpbiB0byB0aGUgZXJyb3JlZCBwYWdlLlxuICAgICAgICBpZiAocGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdID0ge1xuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgICAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7IENvbXBvbmVudDogQXBwIH07XG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50cztcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlcjtcbiAgICAgICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnk7XG4gICAgICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgICAgIHRoaXMuYXNQYXRoID1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBpcyB0ZW1wb3JhcmlseSBnbG9iYWwgKGF0dGFjaGVkIHRvIHdpbmRvdylcbiAgICAgICAgICAgIGlzX2R5bmFtaWNfMS5pc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkgJiYgX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0ID8gcGF0aG5hbWUgOiBhcztcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoO1xuICAgICAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcDtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgICAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICB0aGlzLmlzU3NyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0ZhbGxiYWNrID0gaXNGYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgICAgICAgIGlmIChhcy5zdWJzdHIoMCwgMikgIT09ICcvLycpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoJ3JlcGxhY2VTdGF0ZScsIHV0aWxzXzEuZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZSwgcXVlcnkgfSksIGFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQGRlcHJlY2F0ZWQgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZXZlbiB0aG91Z2ggaXQncyBhIHByaXZhdGUgbWV0aG9kLlxuICAgIHN0YXRpYyBfcmV3cml0ZVVybEZvck5leHRFeHBvcnQodXJsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRVhQT1JUX1RSQUlMSU5HX1NMQVNIKSB7XG4gICAgICAgICAgICBjb25zdCByZXdyaXRlVXJsRm9yTmV4dEV4cG9ydCA9IHJlcXVpcmUoJy4vcmV3cml0ZS11cmwtZm9yLWV4cG9ydCcpXG4gICAgICAgICAgICAgICAgLnJld3JpdGVVcmxGb3JOZXh0RXhwb3J0O1xuICAgICAgICAgICAgcmV0dXJuIHJld3JpdGVVcmxGb3JOZXh0RXhwb3J0KHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZShyb3V0ZSwgbW9kKSB7XG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9IG1vZC5kZWZhdWx0IHx8IG1vZDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdXBkYXRlIHVuYXZhaWxhYmxlIHJvdXRlOiAke3JvdXRlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IENvbXBvbmVudCwgX19OX1NTRzogbW9kLl9fTl9TU0csIF9fTl9TU1A6IG1vZC5fX05fU1NQIH0pO1xuICAgICAgICB0aGlzLmNvbXBvbmVudHNbcm91dGVdID0gbmV3RGF0YTtcbiAgICAgICAgLy8gcGFnZXMvX2FwcC5qcyB1cGRhdGVkXG4gICAgICAgIGlmIChyb3V0ZSA9PT0gJy9fYXBwJykge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkodGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm91dGUgPT09IHRoaXMucm91dGUpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5KG5ld0RhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICAgKi9cbiAgICBiYWNrKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAgICovXG4gICAgcHVzaCh1cmwsIGFzID0gdXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICAgKi9cbiAgICByZXBsYWNlKHVybCwgYXMgPSB1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoJ3JlcGxhY2VTdGF0ZScsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjaGFuZ2UobWV0aG9kLCBfdXJsLCBfYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5faCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICAgICAgICAgIGlmICh1dGlsc18xLlNUKSB7XG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAgICAgICAgICAgLy8gd2UnbGwgZm9ybWF0IHRoZW0gaW50byB0aGUgc3RyaW5nIHZlcnNpb24gaGVyZS5cbiAgICAgICAgICAgIGxldCB1cmwgPSB0eXBlb2YgX3VybCA9PT0gJ29iamVjdCcgPyB1dGlsc18xLmZvcm1hdFdpdGhWYWxpZGF0aW9uKF91cmwpIDogX3VybDtcbiAgICAgICAgICAgIGxldCBhcyA9IHR5cGVvZiBfYXMgPT09ICdvYmplY3QnID8gdXRpbHNfMS5mb3JtYXRXaXRoVmFsaWRhdGlvbihfYXMpIDogX2FzO1xuICAgICAgICAgICAgdXJsID0gYWRkQmFzZVBhdGgodXJsKTtcbiAgICAgICAgICAgIGFzID0gYWRkQmFzZVBhdGgoYXMpO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBlbmRpbmcgc2xhc2ggdG8gdGhlIHBhdGhzLiBTbywgd2UgY2FuIHNlcnZlIHRoZVxuICAgICAgICAgICAgLy8gXCI8cGFnZT4vaW5kZXguaHRtbFwiIGRpcmVjdGx5IGZvciB0aGUgU1NSIHBhZ2UuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0VYUE9SVF9UUkFJTElOR19TTEFTSCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJld3JpdGVVcmxGb3JOZXh0RXhwb3J0ID0gcmVxdWlyZSgnLi9yZXdyaXRlLXVybC1mb3ItZXhwb3J0JylcbiAgICAgICAgICAgICAgICAgICAgLnJld3JpdGVVcmxGb3JOZXh0RXhwb3J0O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBpcyB0ZW1wb3JhcmlseSBnbG9iYWwgKGF0dGFjaGVkIHRvIHdpbmRvdylcbiAgICAgICAgICAgICAgICBpZiAoX19ORVhUX0RBVEFfXy5uZXh0RXhwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFzID0gcmV3cml0ZVVybEZvck5leHRFeHBvcnQoYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWJvcnRDb21wb25lbnRMb2FkKGFzKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXG4gICAgICAgICAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgICAgICAgICAvLyBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5faCAmJiB0aGlzLm9ubHlBSGFzaENoYW5nZShhcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFzUGF0aCA9IGFzO1xuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChhcyk7XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlQ29tcGxldGUnLCBhcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lLCBxdWVyeSwgcHJvdG9jb2wgfSA9IHVybF8xLnBhcnNlKHVybCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIXBhdGhuYW1lIHx8IHByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGhyZWYgcGFzc2VkIHRvIHJvdXRlcjogJHt1cmx9IGh0dHBzOi8vZXJyLnNoL3plaXQvbmV4dC5qcy9pbnZhbGlkLWhyZWYtcGFzc2VkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGFza2VkIHRvIGNoYW5nZSB0aGUgY3VycmVudCBVUkwgd2Ugc2hvdWxkIHJlbG9hZCB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgICAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAgICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAgICAgICAgIC8vIGFzIHRoaXMgc2hvdWxkIG5vdCBnbyBpbnRvIHRoZSBoaXN0b3J5IChUaGF0J3MgaG93IGJyb3dzZXJzIHdvcmspXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgICAgICAgICBpZiAoIXRoaXMudXJsSXNOZXcoYXMpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gJ3JlcGxhY2VTdGF0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZSA9IHRvUm91dGUocGF0aG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgeyBzaGFsbG93ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoaXNfZHluYW1pY18xLmlzRHluYW1pY1JvdXRlKHJvdXRlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWU6IGFzUGF0aG5hbWUgfSA9IHVybF8xLnBhcnNlKGFzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gcm91dGVfcmVnZXhfMS5nZXRSb3V0ZVJlZ2V4KHJvdXRlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByb3V0ZU1hdGNoID0gcm91dGVfbWF0Y2hlcl8xLmdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIocGFyYW0gPT4gIXF1ZXJ5W3BhcmFtXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBNaXNtYXRjaGluZyBcXGBhc1xcYCBhbmQgXFxgaHJlZlxcYCBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfSBpbiB0aGUgXFxgaHJlZlxcYCdzIFxcYHF1ZXJ5XFxgYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihgVGhlIHByb3ZpZGVkIFxcYGFzXFxgIHZhbHVlICgke2FzUGF0aG5hbWV9KSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgXFxgaHJlZlxcYCB2YWx1ZSAoJHtyb3V0ZX0pLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgUmVhZCBtb3JlOiBodHRwczovL2Vyci5zaC96ZWl0L25leHQuanMvaW5jb21wYXRpYmxlLWhyZWYtYXNgKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VTdGFydCcsIGFzKTtcbiAgICAgICAgICAgIC8vIElmIHNoYWxsb3cgaXMgdHJ1ZSBhbmQgdGhlIHJvdXRlIGV4aXN0cyBpbiB0aGUgcm91dGVyIGNhY2hlIHdlIHJldXNlIHRoZSBwcmV2aW91cyByZXN1bHRcbiAgICAgICAgICAgIHRoaXMuZ2V0Um91dGVJbmZvKHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCBzaGFsbG93KS50aGVuKHJvdXRlSW5mbyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gcm91dGVJbmZvO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2JlZm9yZUhpc3RvcnlDaGFuZ2UnLCBhcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFwcENvbXAgPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubmV4dC5pc1ByZXJlbmRlcmVkID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcENvbXAuZ2V0SW5pdGlhbFByb3BzID09PSBhcHBDb21wLm9yaWdHZXRJbml0aWFsUHJvcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhcm91dGVJbmZvLkNvbXBvbmVudC5nZXRJbml0aWFsUHJvcHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZUluZm8pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnJvciwgYXMpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgYXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgIT09ICdwdXNoU3RhdGUnIHx8IHV0aWxzXzEuZ2V0VVJMKCkgIT09IGFzKSB7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgICAgICcnLCBhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Um91dGVJbmZvKHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCBzaGFsbG93ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkUm91dGVJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBzaGFsbG93IHJvdXRlIHRyYW5zaXRpb24gcG9zc2libGVcbiAgICAgICAgLy8gSWYgdGhlIHJvdXRlIGlzIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIHNjcmVlbi5cbiAgICAgICAgaWYgKHNoYWxsb3cgJiYgY2FjaGVkUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZFJvdXRlSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZXJyLCBsb2FkRXJyb3JGYWlsKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSAnUEFHRV9MT0FEX0VSUk9SJyB8fCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgICAgICAgICAgIC8vICAxLiBQYWdlIGRvZXNuJ3QgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgICAgICAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuICAgICAgICAgICAgICAgICAgICAvLyBTbywgZG9pbmcgYSBoYXJkIHJlbG9hZCBpcyB0aGUgcHJvcGVyIHdheSB0byBkZWFsIHdpdGggdGhpcy5cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhcztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAgICAgICAgICAgICAgIC8vIFNvLCB3ZSBuZWVkIHRvIG1hcmsgaXQgYXMgYSBjYW5jZWxsZWQgZXJyb3IgYW5kIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICAgICAgICAgICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRPRE86IGZpeCB0aGUgY29udHJvbCBmbG93IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBlcnJvcjogZXJyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIFRPRE86IGZpeCB0aGUgY29udHJvbCBmbG93IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBlcnJvcjogZXJyIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuZmV0Y2hDb21wb25lbnQoJy9fZXJyb3InKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBhZ2U6IENvbXBvbmVudCB9ID0gcmVzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSB7IENvbXBvbmVudCwgZXJyIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4ocHJvcHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJvdXRlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBnaXBFcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsIGdpcEVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocm91dGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGhhbmRsZUVycm9yKGVyciwgdHJ1ZSkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhY2hlZFJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGNhY2hlZFJvdXRlSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuKHJlcyA9PiByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1AsXG4gICAgICAgICAgICB9KSwgcmVqZWN0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyb3V0ZUluZm8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgQ29tcG9uZW50LCBfX05fU1NHLCBfX05fU1NQIH0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJHtwYXRobmFtZX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXREYXRhKCgpID0+IF9fTl9TU0dcbiAgICAgICAgICAgICAgICA/IHRoaXMuX2dldFN0YXRpY0RhdGEoYXMpXG4gICAgICAgICAgICAgICAgOiBfX05fU1NQXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5fZ2V0U2VydmVyRGF0YShhcylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4ocHJvcHMgPT4ge1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdXRlSW5mbztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGhhbmRsZUVycm9yKTtcbiAgICB9XG4gICAgc2V0KHJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCBkYXRhKSB7XG4gICAgICAgIHRoaXMuaXNGYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJvdXRlID0gcm91dGU7XG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLmFzUGF0aCA9IGFzO1xuICAgICAgICB0aGlzLm5vdGlmeShkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgICAqIEBwYXJhbSBjYiBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICAgICAqL1xuICAgIGJlZm9yZVBvcFN0YXRlKGNiKSB7XG4gICAgICAgIHRoaXMuX2JwcyA9IGNiO1xuICAgIH1cbiAgICBvbmx5QUhhc2hDaGFuZ2UoYXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFzUGF0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycpO1xuICAgICAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJyk7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgICAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgICAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKGFzKSB7XG4gICAgICAgIGNvbnN0IFssIGhhc2hdID0gYXMuc3BsaXQoJyMnKTtcbiAgICAgICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlXG4gICAgICAgIGlmIChoYXNoID09PSAnJykge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoKTtcbiAgICAgICAgaWYgKGlkRWwpIHtcbiAgICAgICAgICAgIGlkRWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2gpWzBdO1xuICAgICAgICBpZiAobmFtZUVsKSB7XG4gICAgICAgICAgICBuYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmxJc05ldyhhc1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgICAqL1xuICAgIHByZWZldGNoKHVybCwgYXNQYXRoID0gdXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHByb3RvY29sIH0gPSB1cmxfMS5wYXJzZSh1cmwpO1xuICAgICAgICAgICAgaWYgKCFwYXRobmFtZSB8fCBwcm90b2NvbCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBocmVmIHBhc3NlZCB0byByb3V0ZXI6ICR7dXJsfSBodHRwczovL2Vyci5zaC96ZWl0L25leHQuanMvaW52YWxpZC1ocmVmLXBhc3NlZGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gZGVsQmFzZVBhdGgodG9Sb3V0ZShwYXRobmFtZSkpO1xuICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5wcmVmZXRjaERhdGEodXJsLCBkZWxCYXNlUGF0aChhc1BhdGgpKSxcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/ICdsb2FkUGFnZScgOiAncHJlZmV0Y2gnXShyb3V0ZSksXG4gICAgICAgICAgICBdKS50aGVuKCgpID0+IHJlc29sdmUoKSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoQ29tcG9uZW50KHJvdXRlKSB7XG4gICAgICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gKHRoaXMuY2xjID0gKCkgPT4ge1xuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJvdXRlID0gZGVsQmFzZVBhdGgocm91dGUpO1xuICAgICAgICBjb25zdCBjb21wb25lbnRSZXN1bHQgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIubG9hZFBhZ2Uocm91dGUpO1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYCk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0O1xuICAgIH1cbiAgICBfZ2V0RGF0YShmbikge1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2xjID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gZm4oKS50aGVuKGRhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbCA9PT0gdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCB9ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddO1xuICAgICAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApO1xuICAgICAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWU7XG4gICAgICAgIHJldHVybiB1dGlsc18xLmxvYWRHZXRJbml0aWFsUHJvcHMoQXBwLCB7XG4gICAgICAgICAgICBBcHBUcmVlLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWJvcnRDb21wb25lbnRMb2FkKGFzKSB7XG4gICAgICAgIGlmICh0aGlzLmNsYykge1xuICAgICAgICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyk7XG4gICAgICAgICAgICBlLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlLCBhcyk7XG4gICAgICAgICAgICB0aGlzLmNsYygpO1xuICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vdGlmeShkYXRhKSB7XG4gICAgICAgIHRoaXMuc3ViKGRhdGEsIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlcjtcblJvdXRlci5ldmVudHMgPSBtaXR0XzEuZGVmYXVsdCgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBJZGVudGlmeSAvW3BhcmFtXS8gaW4gcm91dGUgc3RyaW5nXG5jb25zdCBURVNUX1JPVVRFID0gL1xcL1xcW1teL10rP1xcXSg/PVxcL3wkKS87XG5mdW5jdGlvbiBpc0R5bmFtaWNSb3V0ZShyb3V0ZSkge1xuICAgIHJldHVybiBURVNUX1JPVVRFLnRlc3Qocm91dGUpO1xufVxuZXhwb3J0cy5pc0R5bmFtaWNSb3V0ZSA9IGlzRHluYW1pY1JvdXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkge1xuICAgIGNvbnN0IHsgcmUsIGdyb3VwcyB9ID0gcm91dGVSZWdleDtcbiAgICByZXR1cm4gKHBhdGhuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSByZS5leGVjKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjb2RlID0gKHBhcmFtKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBkZWNvZGUgcGFyYW0nKTtcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9ICdERUNPREVfRkFJTEVEJztcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goKHNsdWdOYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSByb3V0ZU1hdGNoW2cucG9zXTtcbiAgICAgICAgICAgIGlmIChtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbc2x1Z05hbWVdID0gfm0uaW5kZXhPZignLycpXG4gICAgICAgICAgICAgICAgICAgID8gbS5zcGxpdCgnLycpLm1hcChlbnRyeSA9PiBkZWNvZGUoZW50cnkpKVxuICAgICAgICAgICAgICAgICAgICA6IGcucmVwZWF0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtkZWNvZGUobSldXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGRlY29kZShtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0Um91dGVNYXRjaGVyID0gZ2V0Um91dGVNYXRjaGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyB0aGlzIGlzbid0IGltcG9ydGluZyB0aGUgZXNjYXBlLXN0cmluZy1yZWdleCBtb2R1bGVcbi8vIHRvIHJlZHVjZSBieXRlc1xuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Li1dL2csICdcXFxcJCYnKTtcbn1cbmZ1bmN0aW9uIGdldFJvdXRlUmVnZXgobm9ybWFsaXplZFJvdXRlKSB7XG4gICAgLy8gRXNjYXBlIGFsbCBjaGFyYWN0ZXJzIHRoYXQgY291bGQgYmUgY29uc2lkZXJlZCBSZWdFeFxuICAgIGNvbnN0IGVzY2FwZWRSb3V0ZSA9IGVzY2FwZVJlZ2V4KG5vcm1hbGl6ZWRSb3V0ZS5yZXBsYWNlKC9cXC8kLywgJycpIHx8ICcvJyk7XG4gICAgY29uc3QgZ3JvdXBzID0ge307XG4gICAgbGV0IGdyb3VwSW5kZXggPSAxO1xuICAgIGNvbnN0IHBhcmFtZXRlcml6ZWRSb3V0ZSA9IGVzY2FwZWRSb3V0ZS5yZXBsYWNlKC9cXC9cXFxcXFxbKFteL10rPylcXFxcXFxdKD89XFwvfCQpL2csIChfLCAkMSkgPT4ge1xuICAgICAgICBjb25zdCBpc0NhdGNoQWxsID0gL14oXFxcXFxcLil7M30vLnRlc3QoJDEpO1xuICAgICAgICBncm91cHNbJDFcbiAgICAgICAgICAgIC8vIFVuLWVzY2FwZSBrZXlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcKFt8XFxcXHt9KClbXFxdXiQrKj8uLV0pL2csICckMScpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcLnszfS8sICcnKVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICAgIF0gPSB7IHBvczogZ3JvdXBJbmRleCsrLCByZXBlYXQ6IGlzQ2F0Y2hBbGwgfTtcbiAgICAgICAgcmV0dXJuIGlzQ2F0Y2hBbGwgPyAnLyguKz8pJyA6ICcvKFteL10rPyknO1xuICAgIH0pO1xuICAgIGxldCBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZTtcbiAgICAvLyBkZWFkIGNvZGUgZWxpbWluYXRlIGZvciBicm93c2VyIHNpbmNlIGl0J3Mgb25seSBuZWVkZWRcbiAgICAvLyB3aGlsZSBnZW5lcmF0aW5nIHJvdXRlcy1tYW5pZmVzdFxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZSA9IGVzY2FwZWRSb3V0ZS5yZXBsYWNlKC9cXC9cXFxcXFxbKFteL10rPylcXFxcXFxdKD89XFwvfCQpL2csIChfLCAkMSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNDYXRjaEFsbCA9IC9eKFxcXFxcXC4pezN9Ly50ZXN0KCQxKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9ICQxXG4gICAgICAgICAgICAgICAgLy8gVW4tZXNjYXBlIGtleVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcKFt8XFxcXHt9KClbXFxdXiQrKj8uLV0pL2csICckMScpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL15cXC57M30vLCAnJyk7XG4gICAgICAgICAgICByZXR1cm4gaXNDYXRjaEFsbFxuICAgICAgICAgICAgICAgID8gYC8oPzwke2VzY2FwZVJlZ2V4KGtleSl9Pi4rPylgXG4gICAgICAgICAgICAgICAgOiBgLyg/PCR7ZXNjYXBlUmVnZXgoa2V5KX0+W14vXSs/KWA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHJlOiBuZXcgUmVnRXhwKCdeJyArIHBhcmFtZXRlcml6ZWRSb3V0ZSArICcoPzovKT8kJywgJ2knKSwgZ3JvdXBzIH0sIChuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIG5hbWVkUmVnZXg6IGBeJHtuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYCxcbiAgICAgICAgfVxuICAgICAgICA6IHt9KSk7XG59XG5leHBvcnRzLmdldFJvdXRlUmVnZXggPSBnZXRSb3V0ZVJlZ2V4O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5sZXQgcnVudGltZUNvbmZpZztcbmV4cG9ydHMuZGVmYXVsdCA9ICgpID0+IHtcbiAgICByZXR1cm4gcnVudGltZUNvbmZpZztcbn07XG5mdW5jdGlvbiBzZXRDb25maWcoY29uZmlnVmFsdWUpIHtcbiAgICBydW50aW1lQ29uZmlnID0gY29uZmlnVmFsdWU7XG59XG5leHBvcnRzLnNldENvbmZpZyA9IHNldENvbmZpZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuLyoqXG4gKiBVdGlsc1xuICovXG5mdW5jdGlvbiBleGVjT25jZShmbikge1xuICAgIGxldCB1c2VkID0gZmFsc2U7XG4gICAgbGV0IHJlc3VsdDtcbiAgICByZXR1cm4gKCguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmICghdXNlZCkge1xuICAgICAgICAgICAgdXNlZCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxuZXhwb3J0cy5leGVjT25jZSA9IGV4ZWNPbmNlO1xuZnVuY3Rpb24gZ2V0TG9jYXRpb25PcmlnaW4oKSB7XG4gICAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RuYW1lfSR7cG9ydCA/ICc6JyArIHBvcnQgOiAnJ31gO1xufVxuZXhwb3J0cy5nZXRMb2NhdGlvbk9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luO1xuZnVuY3Rpb24gZ2V0VVJMKCkge1xuICAgIGNvbnN0IHsgaHJlZiB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKCk7XG4gICAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpO1xufVxuZXhwb3J0cy5nZXRVUkwgPSBnZXRVUkw7XG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIENvbXBvbmVudCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBDb21wb25lbnRcbiAgICAgICAgOiBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ1Vua25vd24nO1xufVxuZXhwb3J0cy5nZXREaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lO1xuZnVuY3Rpb24gaXNSZXNTZW50KHJlcykge1xuICAgIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50O1xufVxuZXhwb3J0cy5pc1Jlc1NlbnQgPSBpc1Jlc1NlbnQ7XG5hc3luYyBmdW5jdGlvbiBsb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwgY3R4KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICgoX2EgPSBBcHAucHJvdG90eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0SW5pdGlhbFByb3BzKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShBcHApfS5nZXRJbml0aWFsUHJvcHMoKVwiIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kIC0gdmlzaXQgaHR0cHM6Ly9lcnIuc2gvemVpdC9uZXh0LmpzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdoZW4gY2FsbGVkIGZyb20gX2FwcCBgY3R4YCBpcyBuZXN0ZWQgaW4gYGN0eGBcbiAgICBjb25zdCByZXMgPSBjdHgucmVzIHx8IChjdHguY3R4ICYmIGN0eC5jdHgucmVzKTtcbiAgICBpZiAoIUFwcC5nZXRJbml0aWFsUHJvcHMpIHtcbiAgICAgICAgaWYgKGN0eC5jdHggJiYgY3R4LkNvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBwYWdlUHJvcHMgZGVmYXVsdFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYWdlUHJvcHM6IGF3YWl0IGxvYWRHZXRJbml0aWFsUHJvcHMoY3R4LkNvbXBvbmVudCwgY3R4LmN0eCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSBhd2FpdCBBcHAuZ2V0SW5pdGlhbFByb3BzKGN0eCk7XG4gICAgaWYgKHJlcyAmJiBpc1Jlc1NlbnQocmVzKSkge1xuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoQXBwKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBzaG91bGQgcmVzb2x2ZSB0byBhbiBvYmplY3QuIEJ1dCBmb3VuZCBcIiR7cHJvcHN9XCIgaW5zdGVhZC5gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhwcm9wcykubGVuZ3RoID09PSAwICYmICFjdHguY3R4KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7Z2V0RGlzcGxheU5hbWUoQXBwKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vZXJyLnNoL3plaXQvbmV4dC5qcy9lbXB0eS1vYmplY3QtZ2V0SW5pdGlhbFByb3BzYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xufVxuZXhwb3J0cy5sb2FkR2V0SW5pdGlhbFByb3BzID0gbG9hZEdldEluaXRpYWxQcm9wcztcbmV4cG9ydHMudXJsT2JqZWN0S2V5cyA9IFtcbiAgICAnYXV0aCcsXG4gICAgJ2hhc2gnLFxuICAgICdob3N0JyxcbiAgICAnaG9zdG5hbWUnLFxuICAgICdocmVmJyxcbiAgICAncGF0aCcsXG4gICAgJ3BhdGhuYW1lJyxcbiAgICAncG9ydCcsXG4gICAgJ3Byb3RvY29sJyxcbiAgICAncXVlcnknLFxuICAgICdzZWFyY2gnLFxuICAgICdzbGFzaGVzJyxcbl07XG5mdW5jdGlvbiBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmwsIG9wdGlvbnMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9ydHMudXJsT2JqZWN0S2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJsXzEuZm9ybWF0KHVybCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmZvcm1hdFdpdGhWYWxpZGF0aW9uID0gZm9ybWF0V2l0aFZhbGlkYXRpb247XG5leHBvcnRzLlNQID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJztcbmV4cG9ydHMuU1QgPSBleHBvcnRzLlNQICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJztcbiIsIi8qIVxyXG4gKiBQbGF0Zm9ybS5qcyA8aHR0cHM6Ly9tdGhzLmJlL3BsYXRmb3JtPlxyXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE2IEJlbmphbWluIFRhbiA8aHR0cHM6Ly9kZW1vbmVhdXguZ2l0aHViLmlvLz5cclxuICogQ29weXJpZ2h0IDIwMTEtMjAxMyBKb2huLURhdmlkIERhbHRvbiA8aHR0cDovL2FsbHlvdWNhbmxlZXQuY29tLz5cclxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL210aHMuYmUvbWl0PlxyXG4gKi9cclxuOyhmdW5jdGlvbigpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4gIC8qKiBVc2VkIHRvIGRldGVybWluZSBpZiB2YWx1ZXMgYXJlIG9mIHRoZSBsYW5ndWFnZSB0eXBlIGBPYmplY3RgLiAqL1xyXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcclxuICAgICdmdW5jdGlvbic6IHRydWUsXHJcbiAgICAnb2JqZWN0JzogdHJ1ZVxyXG4gIH07XHJcblxyXG4gIC8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG4gIHZhciByb290ID0gKG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdykgfHwgdGhpcztcclxuXHJcbiAgLyoqIEJhY2t1cCBwb3NzaWJsZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG4gIHZhciBvbGRSb290ID0gcm9vdDtcclxuXHJcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cclxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cztcclxuXHJcbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xyXG4gIHZhciBmcmVlTW9kdWxlID0gb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xyXG5cclxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlIGFuZCB1c2UgaXQgYXMgYHJvb3RgLiAqL1xyXG4gIHZhciBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSAmJiB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcclxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsKSkge1xyXG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVc2VkIGFzIHRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhbiBhcnJheS1saWtlIG9iamVjdC5cclxuICAgKiBTZWUgdGhlIFtFUzYgc3BlY10oaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGgpXHJcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cclxuICAgKi9cclxuICB2YXIgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xyXG5cclxuICAvKiogUmVndWxhciBleHByZXNzaW9uIHRvIGRldGVjdCBPcGVyYS4gKi9cclxuICB2YXIgcmVPcGVyYSA9IC9cXGJPcGVyYS87XHJcblxyXG4gIC8qKiBQb3NzaWJsZSBnbG9iYWwgb2JqZWN0LiAqL1xyXG4gIHZhciB0aGlzQmluZGluZyA9IHRoaXM7XHJcblxyXG4gIC8qKiBVc2VkIGZvciBuYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXHJcbiAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcclxuXHJcbiAgLyoqIFVzZWQgdG8gY2hlY2sgZm9yIG93biBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC4gKi9cclxuICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbiAgLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgaW50ZXJuYWwgYFtbQ2xhc3NdXWAgb2YgdmFsdWVzLiAqL1xyXG4gIHZhciB0b1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xyXG5cclxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FwaXRhbGl6ZXMgYSBzdHJpbmcgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjYXBpdGFsaXplLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjYXBpdGFsaXplZCBzdHJpbmcuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHJpbmcpIHtcclxuICAgIHN0cmluZyA9IFN0cmluZyhzdHJpbmcpO1xyXG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0byBjbGVhbiB1cCB0aGUgT1MgbmFtZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9zIFRoZSBPUyBuYW1lIHRvIGNsZWFuIHVwLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0dGVybl0gQSBgUmVnRXhwYCBwYXR0ZXJuIG1hdGNoaW5nIHRoZSBPUyBuYW1lLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFiZWxdIEEgbGFiZWwgZm9yIHRoZSBPUy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbGVhbnVwT1Mob3MsIHBhdHRlcm4sIGxhYmVsKSB7XHJcbiAgICAvLyBQbGF0Zm9ybSB0b2tlbnMgYXJlIGRlZmluZWQgYXQ6XHJcbiAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1Mzc1MDMoVlMuODUpLmFzcHhcclxuICAgIC8vIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMDgxMTIyMDUzOTUwL2h0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNzUwMyhWUy44NSkuYXNweFxyXG4gICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICcxMC4wJzogJzEwJyxcclxuICAgICAgJzYuNCc6ICAnMTAgVGVjaG5pY2FsIFByZXZpZXcnLFxyXG4gICAgICAnNi4zJzogICc4LjEnLFxyXG4gICAgICAnNi4yJzogICc4JyxcclxuICAgICAgJzYuMSc6ICAnU2VydmVyIDIwMDggUjIgLyA3JyxcclxuICAgICAgJzYuMCc6ICAnU2VydmVyIDIwMDggLyBWaXN0YScsXHJcbiAgICAgICc1LjInOiAgJ1NlcnZlciAyMDAzIC8gWFAgNjQtYml0JyxcclxuICAgICAgJzUuMSc6ICAnWFAnLFxyXG4gICAgICAnNS4wMSc6ICcyMDAwIFNQMScsXHJcbiAgICAgICc1LjAnOiAgJzIwMDAnLFxyXG4gICAgICAnNC4wJzogICdOVCcsXHJcbiAgICAgICc0LjkwJzogJ01FJ1xyXG4gICAgfTtcclxuICAgIC8vIERldGVjdCBXaW5kb3dzIHZlcnNpb24gZnJvbSBwbGF0Zm9ybSB0b2tlbnMuXHJcbiAgICBpZiAocGF0dGVybiAmJiBsYWJlbCAmJiAvXldpbi9pLnRlc3Qob3MpICYmICEvXldpbmRvd3MgUGhvbmUgL2kudGVzdChvcykgJiZcclxuICAgICAgICAoZGF0YSA9IGRhdGFbL1tcXGQuXSskLy5leGVjKG9zKV0pKSB7XHJcbiAgICAgIG9zID0gJ1dpbmRvd3MgJyArIGRhdGE7XHJcbiAgICB9XHJcbiAgICAvLyBDb3JyZWN0IGNoYXJhY3RlciBjYXNlIGFuZCBjbGVhbnVwIHN0cmluZy5cclxuICAgIG9zID0gU3RyaW5nKG9zKTtcclxuXHJcbiAgICBpZiAocGF0dGVybiAmJiBsYWJlbCkge1xyXG4gICAgICBvcyA9IG9zLnJlcGxhY2UoUmVnRXhwKHBhdHRlcm4sICdpJyksIGxhYmVsKTtcclxuICAgIH1cclxuXHJcbiAgICBvcyA9IGZvcm1hdChcclxuICAgICAgb3MucmVwbGFjZSgvIGNlJC9pLCAnIENFJylcclxuICAgICAgICAucmVwbGFjZSgvXFxiaHB3L2ksICd3ZWInKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXGJNYWNpbnRvc2hcXGIvLCAnTWFjIE9TJylcclxuICAgICAgICAucmVwbGFjZSgvX1Bvd2VyUENcXGIvaSwgJyBPUycpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcYihPUyBYKSBbXiBcXGRdKy9pLCAnJDEnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXGJNYWMgKE9TIFgpXFxiLywgJyQxJylcclxuICAgICAgICAucmVwbGFjZSgvXFwvKFxcZCkvLCAnICQxJylcclxuICAgICAgICAucmVwbGFjZSgvXy9nLCAnLicpXHJcbiAgICAgICAgLnJlcGxhY2UoLyg/OiBCZVBDfFsgLl0qZmNbIFxcZC5dKykkL2ksICcnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXGJ4ODZcXC42NFxcYi9naSwgJ3g4Nl82NCcpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcYihXaW5kb3dzIFBob25lKSBPU1xcYi8sICckMScpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcYihDaHJvbWUgT1MgXFx3KykgW1xcZC5dK1xcYi8sICckMScpXHJcbiAgICAgICAgLnNwbGl0KCcgb24gJylbMF1cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIG9zO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW4gaXRlcmF0aW9uIHV0aWxpdHkgZm9yIGFycmF5cyBhbmQgb2JqZWN0cy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZWFjaChvYmplY3QsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgaW5kZXggPSAtMSxcclxuICAgICAgICBsZW5ndGggPSBvYmplY3QgPyBvYmplY3QubGVuZ3RoIDogMDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPiAtMSAmJiBsZW5ndGggPD0gbWF4U2FmZUludGVnZXIpIHtcclxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBjYWxsYmFjayhvYmplY3RbaW5kZXhdLCBpbmRleCwgb2JqZWN0KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yT3duKG9iamVjdCwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpbSBhbmQgY29uZGl0aW9uYWxseSBjYXBpdGFsaXplIHN0cmluZyB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBmb3JtYXQuXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCBzdHJpbmcuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZm9ybWF0KHN0cmluZykge1xyXG4gICAgc3RyaW5nID0gdHJpbShzdHJpbmcpO1xyXG4gICAgcmV0dXJuIC9eKD86d2ViT1N8aSg/Ok9TfFApKS8udGVzdChzdHJpbmcpXHJcbiAgICAgID8gc3RyaW5nXHJcbiAgICAgIDogY2FwaXRhbGl6ZShzdHJpbmcpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSXRlcmF0ZXMgb3ZlciBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcywgZXhlY3V0aW5nIHRoZSBgY2FsbGJhY2tgIGZvciBlYWNoLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBleGVjdXRlZCBwZXIgb3duIHByb3BlcnR5LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGNhbGxiYWNrKSB7XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XHJcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xyXG4gICAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGludGVybmFsIGBbW0NsYXNzXV1gIG9mIGEgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlLlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBgW1tDbGFzc11dYC5cclxuICAgKi9cclxuICBmdW5jdGlvbiBnZXRDbGFzc09mKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbFxyXG4gICAgICA/IGNhcGl0YWxpemUodmFsdWUpXHJcbiAgICAgIDogdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSG9zdCBvYmplY3RzIGNhbiByZXR1cm4gdHlwZSB2YWx1ZXMgdGhhdCBhcmUgZGlmZmVyZW50IGZyb20gdGhlaXIgYWN0dWFsXHJcbiAgICogZGF0YSB0eXBlLiBUaGUgb2JqZWN0cyB3ZSBhcmUgY29uY2VybmVkIHdpdGggdXN1YWxseSByZXR1cm4gbm9uLXByaW1pdGl2ZVxyXG4gICAqIHR5cGVzIG9mIFwib2JqZWN0XCIsIFwiZnVuY3Rpb25cIiwgb3IgXCJ1bmtub3duXCIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvd25lciBvZiB0aGUgcHJvcGVydHkuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBjaGVjay5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IHZhbHVlIGlzIGEgbm9uLXByaW1pdGl2ZSwgZWxzZSBgZmFsc2VgLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGlzSG9zdFR5cGUob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG4gICAgdmFyIHR5cGUgPSBvYmplY3QgIT0gbnVsbCA/IHR5cGVvZiBvYmplY3RbcHJvcGVydHldIDogJ251bWJlcic7XHJcbiAgICByZXR1cm4gIS9eKD86Ym9vbGVhbnxudW1iZXJ8c3RyaW5nfHVuZGVmaW5lZCkkLy50ZXN0KHR5cGUpICYmXHJcbiAgICAgICh0eXBlID09ICdvYmplY3QnID8gISFvYmplY3RbcHJvcGVydHldIDogdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcmVwYXJlcyBhIHN0cmluZyBmb3IgdXNlIGluIGEgYFJlZ0V4cGAgYnkgbWFraW5nIGh5cGhlbnMgYW5kIHNwYWNlcyBvcHRpb25hbC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHF1YWxpZnkuXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHF1YWxpZmllZCBzdHJpbmcuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcXVhbGlmeShzdHJpbmcpIHtcclxuICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC8oWyAtXSkoPyEkKS9nLCAnJDE/Jyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBIGJhcmUtYm9uZXMgYEFycmF5I3JlZHVjZWAgbGlrZSB1dGlsaXR5IGZ1bmN0aW9uLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cclxuICAgKiBAcmV0dXJucyB7Kn0gVGhlIGFjY3VtdWxhdGVkIHJlc3VsdC5cclxuICAgKi9cclxuICBmdW5jdGlvbiByZWR1Y2UoYXJyYXksIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgYWNjdW11bGF0b3IgPSBudWxsO1xyXG4gICAgZWFjaChhcnJheSwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XHJcbiAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgYXJyYXkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgZnJvbSBhIHN0cmluZy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyaW1tZWQgc3RyaW5nLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHRyaW0oc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZSgvXiArfCArJC9nLCAnJyk7XHJcbiAgfVxyXG5cclxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG5ldyBwbGF0Zm9ybSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFt1YT1uYXZpZ2F0b3IudXNlckFnZW50XSBUaGUgdXNlciBhZ2VudCBzdHJpbmcgb3JcclxuICAgKiAgY29udGV4dCBvYmplY3QuXHJcbiAgICogQHJldHVybnMge09iamVjdH0gQSBwbGF0Zm9ybSBvYmplY3QuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcGFyc2UodWEpIHtcclxuXHJcbiAgICAvKiogVGhlIGVudmlyb25tZW50IGNvbnRleHQgb2JqZWN0LiAqL1xyXG4gICAgdmFyIGNvbnRleHQgPSByb290O1xyXG5cclxuICAgIC8qKiBVc2VkIHRvIGZsYWcgd2hlbiBhIGN1c3RvbSBjb250ZXh0IGlzIHByb3ZpZGVkLiAqL1xyXG4gICAgdmFyIGlzQ3VzdG9tQ29udGV4dCA9IHVhICYmIHR5cGVvZiB1YSA9PSAnb2JqZWN0JyAmJiBnZXRDbGFzc09mKHVhKSAhPSAnU3RyaW5nJztcclxuXHJcbiAgICAvLyBKdWdnbGUgYXJndW1lbnRzLlxyXG4gICAgaWYgKGlzQ3VzdG9tQ29udGV4dCkge1xyXG4gICAgICBjb250ZXh0ID0gdWE7XHJcbiAgICAgIHVhID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKiogQnJvd3NlciBuYXZpZ2F0b3Igb2JqZWN0LiAqL1xyXG4gICAgdmFyIG5hdiA9IGNvbnRleHQubmF2aWdhdG9yIHx8IHt9O1xyXG5cclxuICAgIC8qKiBCcm93c2VyIHVzZXIgYWdlbnQgc3RyaW5nLiAqL1xyXG4gICAgdmFyIHVzZXJBZ2VudCA9IG5hdi51c2VyQWdlbnQgfHwgJyc7XHJcblxyXG4gICAgdWEgfHwgKHVhID0gdXNlckFnZW50KTtcclxuXHJcbiAgICAvKiogVXNlZCB0byBmbGFnIHdoZW4gYHRoaXNCaW5kaW5nYCBpcyB0aGUgW01vZHVsZVNjb3BlXS4gKi9cclxuICAgIHZhciBpc01vZHVsZVNjb3BlID0gaXNDdXN0b21Db250ZXh0IHx8IHRoaXNCaW5kaW5nID09IG9sZFJvb3Q7XHJcblxyXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGJyb3dzZXIgaXMgbGlrZSBDaHJvbWUuICovXHJcbiAgICB2YXIgbGlrZUNocm9tZSA9IGlzQ3VzdG9tQ29udGV4dFxyXG4gICAgICA/ICEhbmF2Lmxpa2VDaHJvbWVcclxuICAgICAgOiAvXFxiQ2hyb21lXFxiLy50ZXN0KHVhKSAmJiAhL2ludGVybmFsfFxcbi9pLnRlc3QodG9TdHJpbmcudG9TdHJpbmcoKSk7XHJcblxyXG4gICAgLyoqIEludGVybmFsIGBbW0NsYXNzXV1gIHZhbHVlIHNob3J0Y3V0cy4gKi9cclxuICAgIHZhciBvYmplY3RDbGFzcyA9ICdPYmplY3QnLFxyXG4gICAgICAgIGFpclJ1bnRpbWVDbGFzcyA9IGlzQ3VzdG9tQ29udGV4dCA/IG9iamVjdENsYXNzIDogJ1NjcmlwdEJyaWRnaW5nUHJveHlPYmplY3QnLFxyXG4gICAgICAgIGVudmlyb0NsYXNzID0gaXNDdXN0b21Db250ZXh0ID8gb2JqZWN0Q2xhc3MgOiAnRW52aXJvbm1lbnQnLFxyXG4gICAgICAgIGphdmFDbGFzcyA9IChpc0N1c3RvbUNvbnRleHQgJiYgY29udGV4dC5qYXZhKSA/ICdKYXZhUGFja2FnZScgOiBnZXRDbGFzc09mKGNvbnRleHQuamF2YSksXHJcbiAgICAgICAgcGhhbnRvbUNsYXNzID0gaXNDdXN0b21Db250ZXh0ID8gb2JqZWN0Q2xhc3MgOiAnUnVudGltZU9iamVjdCc7XHJcblxyXG4gICAgLyoqIERldGVjdCBKYXZhIGVudmlyb25tZW50cy4gKi9cclxuICAgIHZhciBqYXZhID0gL1xcYkphdmEvLnRlc3QoamF2YUNsYXNzKSAmJiBjb250ZXh0LmphdmE7XHJcblxyXG4gICAgLyoqIERldGVjdCBSaGluby4gKi9cclxuICAgIHZhciByaGlubyA9IGphdmEgJiYgZ2V0Q2xhc3NPZihjb250ZXh0LmVudmlyb25tZW50KSA9PSBlbnZpcm9DbGFzcztcclxuXHJcbiAgICAvKiogQSBjaGFyYWN0ZXIgdG8gcmVwcmVzZW50IGFscGhhLiAqL1xyXG4gICAgdmFyIGFscGhhID0gamF2YSA/ICdhJyA6ICdcXHUwM2IxJztcclxuXHJcbiAgICAvKiogQSBjaGFyYWN0ZXIgdG8gcmVwcmVzZW50IGJldGEuICovXHJcbiAgICB2YXIgYmV0YSA9IGphdmEgPyAnYicgOiAnXFx1MDNiMic7XHJcblxyXG4gICAgLyoqIEJyb3dzZXIgZG9jdW1lbnQgb2JqZWN0LiAqL1xyXG4gICAgdmFyIGRvYyA9IGNvbnRleHQuZG9jdW1lbnQgfHwge307XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlY3QgT3BlcmEgYnJvd3NlciAoUHJlc3RvLWJhc2VkKS5cclxuICAgICAqIGh0dHA6Ly93d3cuaG93dG9jcmVhdGUuY28udWsvb3BlcmFTdHVmZi9vcGVyYU9iamVjdC5odG1sXHJcbiAgICAgKiBodHRwOi8vZGV2Lm9wZXJhLmNvbS9hcnRpY2xlcy92aWV3L29wZXJhLW1pbmktd2ViLWNvbnRlbnQtYXV0aG9yaW5nLWd1aWRlbGluZXMvI29wZXJhbWluaVxyXG4gICAgICovXHJcbiAgICB2YXIgb3BlcmEgPSBjb250ZXh0Lm9wZXJhbWluaSB8fCBjb250ZXh0Lm9wZXJhO1xyXG5cclxuICAgIC8qKiBPcGVyYSBgW1tDbGFzc11dYC4gKi9cclxuICAgIHZhciBvcGVyYUNsYXNzID0gcmVPcGVyYS50ZXN0KG9wZXJhQ2xhc3MgPSAoaXNDdXN0b21Db250ZXh0ICYmIG9wZXJhKSA/IG9wZXJhWydbW0NsYXNzXV0nXSA6IGdldENsYXNzT2Yob3BlcmEpKVxyXG4gICAgICA/IG9wZXJhQ2xhc3NcclxuICAgICAgOiAob3BlcmEgPSBudWxsKTtcclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLyoqIFRlbXBvcmFyeSB2YXJpYWJsZSB1c2VkIG92ZXIgdGhlIHNjcmlwdCdzIGxpZmV0aW1lLiAqL1xyXG4gICAgdmFyIGRhdGE7XHJcblxyXG4gICAgLyoqIFRoZSBDUFUgYXJjaGl0ZWN0dXJlLiAqL1xyXG4gICAgdmFyIGFyY2ggPSB1YTtcclxuXHJcbiAgICAvKiogUGxhdGZvcm0gZGVzY3JpcHRpb24gYXJyYXkuICovXHJcbiAgICB2YXIgZGVzY3JpcHRpb24gPSBbXTtcclxuXHJcbiAgICAvKiogUGxhdGZvcm0gYWxwaGEvYmV0YSBpbmRpY2F0b3IuICovXHJcbiAgICB2YXIgcHJlcmVsZWFzZSA9IG51bGw7XHJcblxyXG4gICAgLyoqIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IGVudmlyb25tZW50IGZlYXR1cmVzIHNob3VsZCBiZSB1c2VkIHRvIHJlc29sdmUgdGhlIHBsYXRmb3JtLiAqL1xyXG4gICAgdmFyIHVzZUZlYXR1cmVzID0gdWEgPT0gdXNlckFnZW50O1xyXG5cclxuICAgIC8qKiBUaGUgYnJvd3Nlci9lbnZpcm9ubWVudCB2ZXJzaW9uLiAqL1xyXG4gICAgdmFyIHZlcnNpb24gPSB1c2VGZWF0dXJlcyAmJiBvcGVyYSAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PSAnZnVuY3Rpb24nICYmIG9wZXJhLnZlcnNpb24oKTtcclxuXHJcbiAgICAvKiogQSBmbGFnIHRvIGluZGljYXRlIGlmIHRoZSBPUyBlbmRzIHdpdGggXCIvIFZlcnNpb25cIiAqL1xyXG4gICAgdmFyIGlzU3BlY2lhbENhc2VkT1M7XHJcblxyXG4gICAgLyogRGV0ZWN0YWJsZSBsYXlvdXQgZW5naW5lcyAob3JkZXIgaXMgaW1wb3J0YW50KS4gKi9cclxuICAgIHZhciBsYXlvdXQgPSBnZXRMYXlvdXQoW1xyXG4gICAgICB7ICdsYWJlbCc6ICdFZGdlSFRNTCcsICdwYXR0ZXJuJzogJ0VkZ2UnIH0sXHJcbiAgICAgICdUcmlkZW50JyxcclxuICAgICAgeyAnbGFiZWwnOiAnV2ViS2l0JywgJ3BhdHRlcm4nOiAnQXBwbGVXZWJLaXQnIH0sXHJcbiAgICAgICdpQ2FiJyxcclxuICAgICAgJ1ByZXN0bycsXHJcbiAgICAgICdOZXRGcm9udCcsXHJcbiAgICAgICdUYXNtYW4nLFxyXG4gICAgICAnS0hUTUwnLFxyXG4gICAgICAnR2Vja28nXHJcbiAgICBdKTtcclxuXHJcbiAgICAvKiBEZXRlY3RhYmxlIGJyb3dzZXIgbmFtZXMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXHJcbiAgICB2YXIgbmFtZSA9IGdldE5hbWUoW1xyXG4gICAgICAnQWRvYmUgQUlSJyxcclxuICAgICAgJ0Fyb3JhJyxcclxuICAgICAgJ0F2YW50IEJyb3dzZXInLFxyXG4gICAgICAnQnJlYWNoJyxcclxuICAgICAgJ0NhbWlubycsXHJcbiAgICAgICdFcGlwaGFueScsXHJcbiAgICAgICdGZW5uZWMnLFxyXG4gICAgICAnRmxvY2snLFxyXG4gICAgICAnR2FsZW9uJyxcclxuICAgICAgJ0dyZWVuQnJvd3NlcicsXHJcbiAgICAgICdpQ2FiJyxcclxuICAgICAgJ0ljZXdlYXNlbCcsXHJcbiAgICAgICdLLU1lbGVvbicsXHJcbiAgICAgICdLb25xdWVyb3InLFxyXG4gICAgICAnTHVuYXNjYXBlJyxcclxuICAgICAgJ01heHRob24nLFxyXG4gICAgICB7ICdsYWJlbCc6ICdNaWNyb3NvZnQgRWRnZScsICdwYXR0ZXJuJzogJ0VkZ2UnIH0sXHJcbiAgICAgICdNaWRvcmknLFxyXG4gICAgICAnTm9vayBCcm93c2VyJyxcclxuICAgICAgJ1BhbGVNb29uJyxcclxuICAgICAgJ1BoYW50b21KUycsXHJcbiAgICAgICdSYXZlbicsXHJcbiAgICAgICdSZWtvbnEnLFxyXG4gICAgICAnUm9ja01lbHQnLFxyXG4gICAgICAnU2VhTW9ua2V5JyxcclxuICAgICAgeyAnbGFiZWwnOiAnU2lsaycsICdwYXR0ZXJuJzogJyg/OkNsb3VkOXxTaWxrLUFjY2VsZXJhdGVkKScgfSxcclxuICAgICAgJ1NsZWlwbmlyJyxcclxuICAgICAgJ1NsaW1Ccm93c2VyJyxcclxuICAgICAgeyAnbGFiZWwnOiAnU1JXYXJlIElyb24nLCAncGF0dGVybic6ICdJcm9uJyB9LFxyXG4gICAgICAnU3VucmlzZScsXHJcbiAgICAgICdTd2lmdGZveCcsXHJcbiAgICAgICdXZWJQb3NpdGl2ZScsXHJcbiAgICAgICdPcGVyYSBNaW5pJyxcclxuICAgICAgeyAnbGFiZWwnOiAnT3BlcmEgTWluaScsICdwYXR0ZXJuJzogJ09QaU9TJyB9LFxyXG4gICAgICAnT3BlcmEnLFxyXG4gICAgICB7ICdsYWJlbCc6ICdPcGVyYScsICdwYXR0ZXJuJzogJ09QUicgfSxcclxuICAgICAgJ0Nocm9tZScsXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0Nocm9tZSBNb2JpbGUnLCAncGF0dGVybic6ICcoPzpDcmlPU3xDck1vKScgfSxcclxuICAgICAgeyAnbGFiZWwnOiAnRmlyZWZveCcsICdwYXR0ZXJuJzogJyg/OkZpcmVmb3h8TWluZWZpZWxkKScgfSxcclxuICAgICAgeyAnbGFiZWwnOiAnRmlyZWZveCBmb3IgaU9TJywgJ3BhdHRlcm4nOiAnRnhpT1MnIH0sXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0lFJywgJ3BhdHRlcm4nOiAnSUVNb2JpbGUnIH0sXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0lFJywgJ3BhdHRlcm4nOiAnTVNJRScgfSxcclxuICAgICAgJ1NhZmFyaSdcclxuICAgIF0pO1xyXG5cclxuICAgIC8qIERldGVjdGFibGUgcHJvZHVjdHMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXHJcbiAgICB2YXIgcHJvZHVjdCA9IGdldFByb2R1Y3QoW1xyXG4gICAgICB7ICdsYWJlbCc6ICdCbGFja0JlcnJ5JywgJ3BhdHRlcm4nOiAnQkIxMCcgfSxcclxuICAgICAgJ0JsYWNrQmVycnknLFxyXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUycsICdwYXR0ZXJuJzogJ0dULUk5MDAwJyB9LFxyXG4gICAgICB7ICdsYWJlbCc6ICdHYWxheHkgUzInLCAncGF0dGVybic6ICdHVC1JOTEwMCcgfSxcclxuICAgICAgeyAnbGFiZWwnOiAnR2FsYXh5IFMzJywgJ3BhdHRlcm4nOiAnR1QtSTkzMDAnIH0sXHJcbiAgICAgIHsgJ2xhYmVsJzogJ0dhbGF4eSBTNCcsICdwYXR0ZXJuJzogJ0dULUk5NTAwJyB9LFxyXG4gICAgICAnR29vZ2xlIFRWJyxcclxuICAgICAgJ0x1bWlhJyxcclxuICAgICAgJ2lQYWQnLFxyXG4gICAgICAnaVBvZCcsXHJcbiAgICAgICdpUGhvbmUnLFxyXG4gICAgICAnS2luZGxlJyxcclxuICAgICAgeyAnbGFiZWwnOiAnS2luZGxlIEZpcmUnLCAncGF0dGVybic6ICcoPzpDbG91ZDl8U2lsay1BY2NlbGVyYXRlZCknIH0sXHJcbiAgICAgICdOZXh1cycsXHJcbiAgICAgICdOb29rJyxcclxuICAgICAgJ1BsYXlCb29rJyxcclxuICAgICAgJ1BsYXlTdGF0aW9uIDMnLFxyXG4gICAgICAnUGxheVN0YXRpb24gNCcsXHJcbiAgICAgICdQbGF5U3RhdGlvbiBWaXRhJyxcclxuICAgICAgJ1RvdWNoUGFkJyxcclxuICAgICAgJ1RyYW5zZm9ybWVyJyxcclxuICAgICAgeyAnbGFiZWwnOiAnV2lpIFUnLCAncGF0dGVybic6ICdXaWlVJyB9LFxyXG4gICAgICAnV2lpJyxcclxuICAgICAgJ1hib3ggT25lJyxcclxuICAgICAgeyAnbGFiZWwnOiAnWGJveCAzNjAnLCAncGF0dGVybic6ICdYYm94JyB9LFxyXG4gICAgICAnWG9vbSdcclxuICAgIF0pO1xyXG5cclxuICAgIC8qIERldGVjdGFibGUgbWFudWZhY3R1cmVycy4gKi9cclxuICAgIHZhciBtYW51ZmFjdHVyZXIgPSBnZXRNYW51ZmFjdHVyZXIoe1xyXG4gICAgICAnQXBwbGUnOiB7ICdpUGFkJzogMSwgJ2lQaG9uZSc6IDEsICdpUG9kJzogMSB9LFxyXG4gICAgICAnQXJjaG9zJzoge30sXHJcbiAgICAgICdBbWF6b24nOiB7ICdLaW5kbGUnOiAxLCAnS2luZGxlIEZpcmUnOiAxIH0sXHJcbiAgICAgICdBc3VzJzogeyAnVHJhbnNmb3JtZXInOiAxIH0sXHJcbiAgICAgICdCYXJuZXMgJiBOb2JsZSc6IHsgJ05vb2snOiAxIH0sXHJcbiAgICAgICdCbGFja0JlcnJ5JzogeyAnUGxheUJvb2snOiAxIH0sXHJcbiAgICAgICdHb29nbGUnOiB7ICdHb29nbGUgVFYnOiAxLCAnTmV4dXMnOiAxIH0sXHJcbiAgICAgICdIUCc6IHsgJ1RvdWNoUGFkJzogMSB9LFxyXG4gICAgICAnSFRDJzoge30sXHJcbiAgICAgICdMRyc6IHt9LFxyXG4gICAgICAnTWljcm9zb2Z0JzogeyAnWGJveCc6IDEsICdYYm94IE9uZSc6IDEgfSxcclxuICAgICAgJ01vdG9yb2xhJzogeyAnWG9vbSc6IDEgfSxcclxuICAgICAgJ05pbnRlbmRvJzogeyAnV2lpIFUnOiAxLCAgJ1dpaSc6IDEgfSxcclxuICAgICAgJ05va2lhJzogeyAnTHVtaWEnOiAxIH0sXHJcbiAgICAgICdTYW1zdW5nJzogeyAnR2FsYXh5IFMnOiAxLCAnR2FsYXh5IFMyJzogMSwgJ0dhbGF4eSBTMyc6IDEsICdHYWxheHkgUzQnOiAxIH0sXHJcbiAgICAgICdTb255JzogeyAnUGxheVN0YXRpb24gNCc6IDEsICdQbGF5U3RhdGlvbiAzJzogMSwgJ1BsYXlTdGF0aW9uIFZpdGEnOiAxIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qIERldGVjdGFibGUgb3BlcmF0aW5nIHN5c3RlbXMgKG9yZGVyIGlzIGltcG9ydGFudCkuICovXHJcbiAgICB2YXIgb3MgPSBnZXRPUyhbXHJcbiAgICAgICdXaW5kb3dzIFBob25lJyxcclxuICAgICAgJ0FuZHJvaWQnLFxyXG4gICAgICAnQ2VudE9TJyxcclxuICAgICAgeyAnbGFiZWwnOiAnQ2hyb21lIE9TJywgJ3BhdHRlcm4nOiAnQ3JPUycgfSxcclxuICAgICAgJ0RlYmlhbicsXHJcbiAgICAgICdGZWRvcmEnLFxyXG4gICAgICAnRnJlZUJTRCcsXHJcbiAgICAgICdHZW50b28nLFxyXG4gICAgICAnSGFpa3UnLFxyXG4gICAgICAnS3VidW50dScsXHJcbiAgICAgICdMaW51eCBNaW50JyxcclxuICAgICAgJ09wZW5CU0QnLFxyXG4gICAgICAnUmVkIEhhdCcsXHJcbiAgICAgICdTdVNFJyxcclxuICAgICAgJ1VidW50dScsXHJcbiAgICAgICdYdWJ1bnR1JyxcclxuICAgICAgJ0N5Z3dpbicsXHJcbiAgICAgICdTeW1iaWFuIE9TJyxcclxuICAgICAgJ2hwd09TJyxcclxuICAgICAgJ3dlYk9TICcsXHJcbiAgICAgICd3ZWJPUycsXHJcbiAgICAgICdUYWJsZXQgT1MnLFxyXG4gICAgICAnTGludXgnLFxyXG4gICAgICAnTWFjIE9TIFgnLFxyXG4gICAgICAnTWFjaW50b3NoJyxcclxuICAgICAgJ01hYycsXHJcbiAgICAgICdXaW5kb3dzIDk4OycsXHJcbiAgICAgICdXaW5kb3dzICdcclxuICAgIF0pO1xyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpY2tzIHRoZSBsYXlvdXQgZW5naW5lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgbGF5b3V0IGVuZ2luZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0TGF5b3V0KGd1ZXNzZXMpIHtcclxuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBSZWdFeHAoJ1xcXFxiJyArIChcclxuICAgICAgICAgIGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcylcclxuICAgICAgICApICsgJ1xcXFxiJywgJ2knKS5leGVjKHVhKSAmJiAoZ3Vlc3MubGFiZWwgfHwgZ3Vlc3MpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpY2tzIHRoZSBtYW51ZmFjdHVyZXIgZnJvbSBhbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBndWVzc2VzIEFuIG9iamVjdCBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgbWFudWZhY3R1cmVyLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRNYW51ZmFjdHVyZXIoZ3Vlc3Nlcykge1xyXG4gICAgICByZXR1cm4gcmVkdWNlKGd1ZXNzZXMsIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xyXG4gICAgICAgIC8vIExvb2t1cCB0aGUgbWFudWZhY3R1cmVyIGJ5IHByb2R1Y3Qgb3Igc2NhbiB0aGUgVUEgZm9yIHRoZSBtYW51ZmFjdHVyZXIuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCAoXHJcbiAgICAgICAgICB2YWx1ZVtwcm9kdWN0XSB8fFxyXG4gICAgICAgICAgdmFsdWVbL15bYS16XSsoPzogK1thLXpdK1xcYikqL2kuZXhlYyhwcm9kdWN0KV0gfHxcclxuICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcXVhbGlmeShrZXkpICsgJyg/OlxcXFxifFxcXFx3KlxcXFxkKScsICdpJykuZXhlYyh1YSlcclxuICAgICAgICApICYmIGtleTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaWNrcyB0aGUgYnJvd3NlciBuYW1lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgYnJvd3NlciBuYW1lLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXROYW1lKGd1ZXNzZXMpIHtcclxuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCB8fCBSZWdFeHAoJ1xcXFxiJyArIChcclxuICAgICAgICAgIGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcylcclxuICAgICAgICApICsgJ1xcXFxiJywgJ2knKS5leGVjKHVhKSAmJiAoZ3Vlc3MubGFiZWwgfHwgZ3Vlc3MpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFBpY2tzIHRoZSBPUyBuYW1lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgT1MgbmFtZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0T1MoZ3Vlc3Nlcykge1xyXG4gICAgICByZXR1cm4gcmVkdWNlKGd1ZXNzZXMsIGZ1bmN0aW9uKHJlc3VsdCwgZ3Vlc3MpIHtcclxuICAgICAgICB2YXIgcGF0dGVybiA9IGd1ZXNzLnBhdHRlcm4gfHwgcXVhbGlmeShndWVzcyk7XHJcbiAgICAgICAgaWYgKCFyZXN1bHQgJiYgKHJlc3VsdCA9XHJcbiAgICAgICAgICAgICAgUmVnRXhwKCdcXFxcYicgKyBwYXR0ZXJuICsgJyg/Oi9bXFxcXGQuXSt8WyBcXFxcdy5dKiknLCAnaScpLmV4ZWModWEpXHJcbiAgICAgICAgICAgICkpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IGNsZWFudXBPUyhyZXN1bHQsIHBhdHRlcm4sIGd1ZXNzLmxhYmVsIHx8IGd1ZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQaWNrcyB0aGUgcHJvZHVjdCBuYW1lIGZyb20gYW4gYXJyYXkgb2YgZ3Vlc3Nlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gZ3Vlc3NlcyBBbiBhcnJheSBvZiBndWVzc2VzLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgcHJvZHVjdCBuYW1lLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRQcm9kdWN0KGd1ZXNzZXMpIHtcclxuICAgICAgcmV0dXJuIHJlZHVjZShndWVzc2VzLCBmdW5jdGlvbihyZXN1bHQsIGd1ZXNzKSB7XHJcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBndWVzcy5wYXR0ZXJuIHx8IHF1YWxpZnkoZ3Vlc3MpO1xyXG4gICAgICAgIGlmICghcmVzdWx0ICYmIChyZXN1bHQgPVxyXG4gICAgICAgICAgICAgIFJlZ0V4cCgnXFxcXGInICsgcGF0dGVybiArICcgKlxcXFxkK1suXFxcXHdfXSonLCAnaScpLmV4ZWModWEpIHx8XHJcbiAgICAgICAgICAgICAgUmVnRXhwKCdcXFxcYicgKyBwYXR0ZXJuICsgJyg/OjsgKig/OlthLXpdK1tfLV0pP1thLXpdK1xcXFxkK3xbXiAoKTstXSopJywgJ2knKS5leGVjKHVhKVxyXG4gICAgICAgICAgICApKSB7XHJcbiAgICAgICAgICAvLyBTcGxpdCBieSBmb3J3YXJkIHNsYXNoIGFuZCBhcHBlbmQgcHJvZHVjdCB2ZXJzaW9uIGlmIG5lZWRlZC5cclxuICAgICAgICAgIGlmICgocmVzdWx0ID0gU3RyaW5nKChndWVzcy5sYWJlbCAmJiAhUmVnRXhwKHBhdHRlcm4sICdpJykudGVzdChndWVzcy5sYWJlbCkpID8gZ3Vlc3MubGFiZWwgOiByZXN1bHQpLnNwbGl0KCcvJykpWzFdICYmICEvW1xcZC5dKy8udGVzdChyZXN1bHRbMF0pKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFswXSArPSAnICcgKyByZXN1bHRbMV07XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBDb3JyZWN0IGNoYXJhY3RlciBjYXNlIGFuZCBjbGVhbnVwIHN0cmluZy5cclxuICAgICAgICAgIGd1ZXNzID0gZ3Vlc3MubGFiZWwgfHwgZ3Vlc3M7XHJcbiAgICAgICAgICByZXN1bHQgPSBmb3JtYXQocmVzdWx0WzBdXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKFJlZ0V4cChwYXR0ZXJuLCAnaScpLCBndWVzcylcclxuICAgICAgICAgICAgLnJlcGxhY2UoUmVnRXhwKCc7ICooPzonICsgZ3Vlc3MgKyAnW18tXSk/JywgJ2knKSwgJyAnKVxyXG4gICAgICAgICAgICAucmVwbGFjZShSZWdFeHAoJygnICsgZ3Vlc3MgKyAnKVstXy5dPyhcXFxcdyknLCAnaScpLCAnJDEgJDInKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVzb2x2ZXMgdGhlIHZlcnNpb24gdXNpbmcgYW4gYXJyYXkgb2YgVUEgcGF0dGVybnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdHRlcm5zIEFuIGFycmF5IG9mIFVBIHBhdHRlcm5zLlxyXG4gICAgICogQHJldHVybnMge251bGx8c3RyaW5nfSBUaGUgZGV0ZWN0ZWQgdmVyc2lvbi5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0VmVyc2lvbihwYXR0ZXJucykge1xyXG4gICAgICByZXR1cm4gcmVkdWNlKHBhdHRlcm5zLCBmdW5jdGlvbihyZXN1bHQsIHBhdHRlcm4pIHtcclxuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IChSZWdFeHAocGF0dGVybiArXHJcbiAgICAgICAgICAnKD86LVtcXFxcZC5dKy98KD86IGZvciBbXFxcXHctXSspP1sgLy1dKShbXFxcXGQuXStbXiAoKTsvXy1dKiknLCAnaScpLmV4ZWModWEpIHx8IDApWzFdIHx8IG51bGw7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgcGxhdGZvcm0uZGVzY3JpcHRpb25gIHdoZW4gdGhlIHBsYXRmb3JtIG9iamVjdCBpcyBjb2VyY2VkIHRvIGEgc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBuYW1lIHRvU3RyaW5nXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgYHBsYXRmb3JtLmRlc2NyaXB0aW9uYCBpZiBhdmFpbGFibGUsIGVsc2UgYW4gZW1wdHkgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b1N0cmluZ1BsYXRmb3JtKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5kZXNjcmlwdGlvbiB8fCAnJztcclxuICAgIH1cclxuXHJcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcblxyXG4gICAgLy8gQ29udmVydCBsYXlvdXQgdG8gYW4gYXJyYXkgc28gd2UgY2FuIGFkZCBleHRyYSBkZXRhaWxzLlxyXG4gICAgbGF5b3V0ICYmIChsYXlvdXQgPSBbbGF5b3V0XSk7XHJcblxyXG4gICAgLy8gRGV0ZWN0IHByb2R1Y3QgbmFtZXMgdGhhdCBjb250YWluIHRoZWlyIG1hbnVmYWN0dXJlcidzIG5hbWUuXHJcbiAgICBpZiAobWFudWZhY3R1cmVyICYmICFwcm9kdWN0KSB7XHJcbiAgICAgIHByb2R1Y3QgPSBnZXRQcm9kdWN0KFttYW51ZmFjdHVyZXJdKTtcclxuICAgIH1cclxuICAgIC8vIENsZWFuIHVwIEdvb2dsZSBUVi5cclxuICAgIGlmICgoZGF0YSA9IC9cXGJHb29nbGUgVFZcXGIvLmV4ZWMocHJvZHVjdCkpKSB7XHJcbiAgICAgIHByb2R1Y3QgPSBkYXRhWzBdO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IHNpbXVsYXRvcnMuXHJcbiAgICBpZiAoL1xcYlNpbXVsYXRvclxcYi9pLnRlc3QodWEpKSB7XHJcbiAgICAgIHByb2R1Y3QgPSAocHJvZHVjdCA/IHByb2R1Y3QgKyAnICcgOiAnJykgKyAnU2ltdWxhdG9yJztcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBPcGVyYSBNaW5pIDgrIHJ1bm5pbmcgaW4gVHVyYm8vVW5jb21wcmVzc2VkIG1vZGUgb24gaU9TLlxyXG4gICAgaWYgKG5hbWUgPT0gJ09wZXJhIE1pbmknICYmIC9cXGJPUGlPU1xcYi8udGVzdCh1YSkpIHtcclxuICAgICAgZGVzY3JpcHRpb24ucHVzaCgncnVubmluZyBpbiBUdXJiby9VbmNvbXByZXNzZWQgbW9kZScpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IElFIE1vYmlsZSAxMS5cclxuICAgIGlmIChuYW1lID09ICdJRScgJiYgL1xcYmxpa2UgaVBob25lIE9TXFxiLy50ZXN0KHVhKSkge1xyXG4gICAgICBkYXRhID0gcGFyc2UodWEucmVwbGFjZSgvbGlrZSBpUGhvbmUgT1MvLCAnJykpO1xyXG4gICAgICBtYW51ZmFjdHVyZXIgPSBkYXRhLm1hbnVmYWN0dXJlcjtcclxuICAgICAgcHJvZHVjdCA9IGRhdGEucHJvZHVjdDtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBpT1MuXHJcbiAgICBlbHNlIGlmICgvXmlQLy50ZXN0KHByb2R1Y3QpKSB7XHJcbiAgICAgIG5hbWUgfHwgKG5hbWUgPSAnU2FmYXJpJyk7XHJcbiAgICAgIG9zID0gJ2lPUycgKyAoKGRhdGEgPSAvIE9TIChbXFxkX10rKS9pLmV4ZWModWEpKVxyXG4gICAgICAgID8gJyAnICsgZGF0YVsxXS5yZXBsYWNlKC9fL2csICcuJylcclxuICAgICAgICA6ICcnKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBLdWJ1bnR1LlxyXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnS29ucXVlcm9yJyAmJiAhL2J1bnR1L2kudGVzdChvcykpIHtcclxuICAgICAgb3MgPSAnS3VidW50dSc7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgQW5kcm9pZCBicm93c2Vycy5cclxuICAgIGVsc2UgaWYgKChtYW51ZmFjdHVyZXIgJiYgbWFudWZhY3R1cmVyICE9ICdHb29nbGUnICYmXHJcbiAgICAgICAgKCgvQ2hyb21lLy50ZXN0KG5hbWUpICYmICEvXFxiTW9iaWxlIFNhZmFyaVxcYi9pLnRlc3QodWEpKSB8fCAvXFxiVml0YVxcYi8udGVzdChwcm9kdWN0KSkpIHx8XHJcbiAgICAgICAgKC9cXGJBbmRyb2lkXFxiLy50ZXN0KG9zKSAmJiAvXkNocm9tZS8udGVzdChuYW1lKSAmJiAvXFxiVmVyc2lvblxcLy9pLnRlc3QodWEpKSkge1xyXG4gICAgICBuYW1lID0gJ0FuZHJvaWQgQnJvd3Nlcic7XHJcbiAgICAgIG9zID0gL1xcYkFuZHJvaWRcXGIvLnRlc3Qob3MpID8gb3MgOiAnQW5kcm9pZCc7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgU2lsayBkZXNrdG9wL2FjY2VsZXJhdGVkIG1vZGVzLlxyXG4gICAgZWxzZSBpZiAobmFtZSA9PSAnU2lsaycpIHtcclxuICAgICAgaWYgKCEvXFxiTW9iaS9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgb3MgPSAnQW5kcm9pZCc7XHJcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKC9BY2NlbGVyYXRlZCAqPSAqdHJ1ZS9pLnRlc3QodWEpKSB7XHJcbiAgICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnYWNjZWxlcmF0ZWQnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IFBhbGVNb29uIGlkZW50aWZ5aW5nIGFzIEZpcmVmb3guXHJcbiAgICBlbHNlIGlmIChuYW1lID09ICdQYWxlTW9vbicgJiYgKGRhdGEgPSAvXFxiRmlyZWZveFxcLyhbXFxkLl0rKVxcYi8uZXhlYyh1YSkpKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goJ2lkZW50aWZ5aW5nIGFzIEZpcmVmb3ggJyArIGRhdGFbMV0pO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IEZpcmVmb3ggT1MgYW5kIHByb2R1Y3RzIHJ1bm5pbmcgRmlyZWZveC5cclxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ0ZpcmVmb3gnICYmIChkYXRhID0gL1xcYihNb2JpbGV8VGFibGV0fFRWKVxcYi9pLmV4ZWModWEpKSkge1xyXG4gICAgICBvcyB8fCAob3MgPSAnRmlyZWZveCBPUycpO1xyXG4gICAgICBwcm9kdWN0IHx8IChwcm9kdWN0ID0gZGF0YVsxXSk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgZmFsc2UgcG9zaXRpdmVzIGZvciBGaXJlZm94L1NhZmFyaS5cclxuICAgIGVsc2UgaWYgKCFuYW1lIHx8IChkYXRhID0gIS9cXGJNaW5lZmllbGRcXGIvaS50ZXN0KHVhKSAmJiAvXFxiKD86RmlyZWZveHxTYWZhcmkpXFxiLy5leGVjKG5hbWUpKSkge1xyXG4gICAgICAvLyBFc2NhcGUgdGhlIGAvYCBmb3IgRmlyZWZveCAxLlxyXG4gICAgICBpZiAobmFtZSAmJiAhcHJvZHVjdCAmJiAvW1xcLyxdfF5bXihdKz9cXCkvLnRlc3QodWEuc2xpY2UodWEuaW5kZXhPZihkYXRhICsgJy8nKSArIDgpKSkge1xyXG4gICAgICAgIC8vIENsZWFyIG5hbWUgb2YgZmFsc2UgcG9zaXRpdmVzLlxyXG4gICAgICAgIG5hbWUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFJlYXNzaWduIGEgZ2VuZXJpYyBuYW1lLlxyXG4gICAgICBpZiAoKGRhdGEgPSBwcm9kdWN0IHx8IG1hbnVmYWN0dXJlciB8fCBvcykgJiZcclxuICAgICAgICAgIChwcm9kdWN0IHx8IG1hbnVmYWN0dXJlciB8fCAvXFxiKD86QW5kcm9pZHxTeW1iaWFuIE9TfFRhYmxldCBPU3x3ZWJPUylcXGIvLnRlc3Qob3MpKSkge1xyXG4gICAgICAgIG5hbWUgPSAvW2Etel0rKD86IEhhdCk/L2kuZXhlYygvXFxiQW5kcm9pZFxcYi8udGVzdChvcykgPyBvcyA6IGRhdGEpICsgJyBCcm93c2VyJztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IG5vbi1PcGVyYSAoUHJlc3RvLWJhc2VkKSB2ZXJzaW9ucyAob3JkZXIgaXMgaW1wb3J0YW50KS5cclxuICAgIGlmICghdmVyc2lvbikge1xyXG4gICAgICB2ZXJzaW9uID0gZ2V0VmVyc2lvbihbXHJcbiAgICAgICAgJyg/OkNsb3VkOXxDcmlPU3xDck1vfEVkZ2V8RnhpT1N8SUVNb2JpbGV8SXJvbnxPcGVyYSA/TWluaXxPUGlPU3xPUFJ8UmF2ZW58U2lsayg/IS9bXFxcXGQuXSskKSknLFxyXG4gICAgICAgICdWZXJzaW9uJyxcclxuICAgICAgICBxdWFsaWZ5KG5hbWUpLFxyXG4gICAgICAgICcoPzpGaXJlZm94fE1pbmVmaWVsZHxOZXRGcm9udCknXHJcbiAgICAgIF0pO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IHN0dWJib3JuIGxheW91dCBlbmdpbmVzLlxyXG4gICAgaWYgKChkYXRhID1cclxuICAgICAgICAgIGxheW91dCA9PSAnaUNhYicgJiYgcGFyc2VGbG9hdCh2ZXJzaW9uKSA+IDMgJiYgJ1dlYktpdCcgfHxcclxuICAgICAgICAgIC9cXGJPcGVyYVxcYi8udGVzdChuYW1lKSAmJiAoL1xcYk9QUlxcYi8udGVzdCh1YSkgPyAnQmxpbmsnIDogJ1ByZXN0bycpIHx8XHJcbiAgICAgICAgICAvXFxiKD86TWlkb3JpfE5vb2t8U2FmYXJpKVxcYi9pLnRlc3QodWEpICYmICEvXig/OlRyaWRlbnR8RWRnZUhUTUwpJC8udGVzdChsYXlvdXQpICYmICdXZWJLaXQnIHx8XHJcbiAgICAgICAgICAhbGF5b3V0ICYmIC9cXGJNU0lFXFxiL2kudGVzdCh1YSkgJiYgKG9zID09ICdNYWMgT1MnID8gJ1Rhc21hbicgOiAnVHJpZGVudCcpIHx8XHJcbiAgICAgICAgICBsYXlvdXQgPT0gJ1dlYktpdCcgJiYgL1xcYlBsYXlTdGF0aW9uXFxiKD8hIFZpdGFcXGIpL2kudGVzdChuYW1lKSAmJiAnTmV0RnJvbnQnXHJcbiAgICAgICAgKSkge1xyXG4gICAgICBsYXlvdXQgPSBbZGF0YV07XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgV2luZG93cyBQaG9uZSA3IGRlc2t0b3AgbW9kZS5cclxuICAgIGlmIChuYW1lID09ICdJRScgJiYgKGRhdGEgPSAoLzsgKig/OlhCTFdQfFp1bmVXUCkoXFxkKykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcclxuICAgICAgbmFtZSArPSAnIE1vYmlsZSc7XHJcbiAgICAgIG9zID0gJ1dpbmRvd3MgUGhvbmUgJyArICgvXFwrJC8udGVzdChkYXRhKSA/IGRhdGEgOiBkYXRhICsgJy54Jyk7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ2Rlc2t0b3AgbW9kZScpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IFdpbmRvd3MgUGhvbmUgOC54IGRlc2t0b3AgbW9kZS5cclxuICAgIGVsc2UgaWYgKC9cXGJXUERlc2t0b3BcXGIvaS50ZXN0KHVhKSkge1xyXG4gICAgICBuYW1lID0gJ0lFIE1vYmlsZSc7XHJcbiAgICAgIG9zID0gJ1dpbmRvd3MgUGhvbmUgOC54JztcclxuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XHJcbiAgICAgIHZlcnNpb24gfHwgKHZlcnNpb24gPSAoL1xcYnJ2OihbXFxkLl0rKS8uZXhlYyh1YSkgfHwgMClbMV0pO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IElFIDExLlxyXG4gICAgZWxzZSBpZiAobmFtZSAhPSAnSUUnICYmIGxheW91dCA9PSAnVHJpZGVudCcgJiYgKGRhdGEgPSAvXFxicnY6KFtcXGQuXSspLy5leGVjKHVhKSkpIHtcclxuICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICBkZXNjcmlwdGlvbi5wdXNoKCdpZGVudGlmeWluZyBhcyAnICsgbmFtZSArICh2ZXJzaW9uID8gJyAnICsgdmVyc2lvbiA6ICcnKSk7XHJcbiAgICAgIH1cclxuICAgICAgbmFtZSA9ICdJRSc7XHJcbiAgICAgIHZlcnNpb24gPSBkYXRhWzFdO1xyXG4gICAgfVxyXG4gICAgLy8gTGV2ZXJhZ2UgZW52aXJvbm1lbnQgZmVhdHVyZXMuXHJcbiAgICBpZiAodXNlRmVhdHVyZXMpIHtcclxuICAgICAgLy8gRGV0ZWN0IHNlcnZlci1zaWRlIGVudmlyb25tZW50cy5cclxuICAgICAgLy8gUmhpbm8gaGFzIGEgZ2xvYmFsIGZ1bmN0aW9uIHdoaWxlIG90aGVycyBoYXZlIGEgZ2xvYmFsIG9iamVjdC5cclxuICAgICAgaWYgKGlzSG9zdFR5cGUoY29udGV4dCwgJ2dsb2JhbCcpKSB7XHJcbiAgICAgICAgaWYgKGphdmEpIHtcclxuICAgICAgICAgIGRhdGEgPSBqYXZhLmxhbmcuU3lzdGVtO1xyXG4gICAgICAgICAgYXJjaCA9IGRhdGEuZ2V0UHJvcGVydHkoJ29zLmFyY2gnKTtcclxuICAgICAgICAgIG9zID0gb3MgfHwgZGF0YS5nZXRQcm9wZXJ0eSgnb3MubmFtZScpICsgJyAnICsgZGF0YS5nZXRQcm9wZXJ0eSgnb3MudmVyc2lvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNNb2R1bGVTY29wZSAmJiBpc0hvc3RUeXBlKGNvbnRleHQsICdzeXN0ZW0nKSAmJiAoZGF0YSA9IFtjb250ZXh0LnN5c3RlbV0pWzBdKSB7XHJcbiAgICAgICAgICBvcyB8fCAob3MgPSBkYXRhWzBdLm9zIHx8IG51bGwpO1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZGF0YVsxXSA9IGNvbnRleHQucmVxdWlyZSgncmluZ28vZW5naW5lJykudmVyc2lvbjtcclxuICAgICAgICAgICAgdmVyc2lvbiA9IGRhdGFbMV0uam9pbignLicpO1xyXG4gICAgICAgICAgICBuYW1lID0gJ1JpbmdvSlMnO1xyXG4gICAgICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgICAgIGlmIChkYXRhWzBdLmdsb2JhbC5zeXN0ZW0gPT0gY29udGV4dC5zeXN0ZW0pIHtcclxuICAgICAgICAgICAgICBuYW1lID0gJ05hcndoYWwnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFxyXG4gICAgICAgICAgdHlwZW9mIGNvbnRleHQucHJvY2VzcyA9PSAnb2JqZWN0JyAmJiAhY29udGV4dC5wcm9jZXNzLmJyb3dzZXIgJiZcclxuICAgICAgICAgIChkYXRhID0gY29udGV4dC5wcm9jZXNzKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgbmFtZSA9ICdOb2RlLmpzJztcclxuICAgICAgICAgIGFyY2ggPSBkYXRhLmFyY2g7XHJcbiAgICAgICAgICBvcyA9IGRhdGEucGxhdGZvcm07XHJcbiAgICAgICAgICB2ZXJzaW9uID0gL1tcXGQuXSsvLmV4ZWMoZGF0YS52ZXJzaW9uKVswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmhpbm8pIHtcclxuICAgICAgICAgIG5hbWUgPSAnUmhpbm8nO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBEZXRlY3QgQWRvYmUgQUlSLlxyXG4gICAgICBlbHNlIGlmIChnZXRDbGFzc09mKChkYXRhID0gY29udGV4dC5ydW50aW1lKSkgPT0gYWlyUnVudGltZUNsYXNzKSB7XHJcbiAgICAgICAgbmFtZSA9ICdBZG9iZSBBSVInO1xyXG4gICAgICAgIG9zID0gZGF0YS5mbGFzaC5zeXN0ZW0uQ2FwYWJpbGl0aWVzLm9zO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIERldGVjdCBQaGFudG9tSlMuXHJcbiAgICAgIGVsc2UgaWYgKGdldENsYXNzT2YoKGRhdGEgPSBjb250ZXh0LnBoYW50b20pKSA9PSBwaGFudG9tQ2xhc3MpIHtcclxuICAgICAgICBuYW1lID0gJ1BoYW50b21KUyc7XHJcbiAgICAgICAgdmVyc2lvbiA9IChkYXRhID0gZGF0YS52ZXJzaW9uIHx8IG51bGwpICYmIChkYXRhLm1ham9yICsgJy4nICsgZGF0YS5taW5vciArICcuJyArIGRhdGEucGF0Y2gpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIERldGVjdCBJRSBjb21wYXRpYmlsaXR5IG1vZGVzLlxyXG4gICAgICBlbHNlIGlmICh0eXBlb2YgZG9jLmRvY3VtZW50TW9kZSA9PSAnbnVtYmVyJyAmJiAoZGF0YSA9IC9cXGJUcmlkZW50XFwvKFxcZCspL2kuZXhlYyh1YSkpKSB7XHJcbiAgICAgICAgLy8gV2UncmUgaW4gY29tcGF0aWJpbGl0eSBtb2RlIHdoZW4gdGhlIFRyaWRlbnQgdmVyc2lvbiArIDQgZG9lc24ndFxyXG4gICAgICAgIC8vIGVxdWFsIHRoZSBkb2N1bWVudCBtb2RlLlxyXG4gICAgICAgIHZlcnNpb24gPSBbdmVyc2lvbiwgZG9jLmRvY3VtZW50TW9kZV07XHJcbiAgICAgICAgaWYgKChkYXRhID0gK2RhdGFbMV0gKyA0KSAhPSB2ZXJzaW9uWzFdKSB7XHJcbiAgICAgICAgICBkZXNjcmlwdGlvbi5wdXNoKCdJRSAnICsgdmVyc2lvblsxXSArICcgbW9kZScpO1xyXG4gICAgICAgICAgbGF5b3V0ICYmIChsYXlvdXRbMV0gPSAnJyk7XHJcbiAgICAgICAgICB2ZXJzaW9uWzFdID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVyc2lvbiA9IG5hbWUgPT0gJ0lFJyA/IFN0cmluZyh2ZXJzaW9uWzFdLnRvRml4ZWQoMSkpIDogdmVyc2lvblswXTtcclxuICAgICAgfVxyXG4gICAgICBvcyA9IG9zICYmIGZvcm1hdChvcyk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgcHJlcmVsZWFzZSBwaGFzZXMuXHJcbiAgICBpZiAodmVyc2lvbiAmJiAoZGF0YSA9XHJcbiAgICAgICAgICAvKD86W2FiXXxkcHxwcmV8W2FiXVxcZCtwcmUpKD86XFxkK1xcKz8pPyQvaS5leGVjKHZlcnNpb24pIHx8XHJcbiAgICAgICAgICAvKD86YWxwaGF8YmV0YSkoPzogP1xcZCk/L2kuZXhlYyh1YSArICc7JyArICh1c2VGZWF0dXJlcyAmJiBuYXYuYXBwTWlub3JWZXJzaW9uKSkgfHxcclxuICAgICAgICAgIC9cXGJNaW5lZmllbGRcXGIvaS50ZXN0KHVhKSAmJiAnYSdcclxuICAgICAgICApKSB7XHJcbiAgICAgIHByZXJlbGVhc2UgPSAvYi9pLnRlc3QoZGF0YSkgPyAnYmV0YScgOiAnYWxwaGEnO1xyXG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi5yZXBsYWNlKFJlZ0V4cChkYXRhICsgJ1xcXFwrPyQnKSwgJycpICtcclxuICAgICAgICAocHJlcmVsZWFzZSA9PSAnYmV0YScgPyBiZXRhIDogYWxwaGEpICsgKC9cXGQrXFwrPy8uZXhlYyhkYXRhKSB8fCAnJyk7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgRmlyZWZveCBNb2JpbGUuXHJcbiAgICBpZiAobmFtZSA9PSAnRmVubmVjJyB8fCBuYW1lID09ICdGaXJlZm94JyAmJiAvXFxiKD86QW5kcm9pZHxGaXJlZm94IE9TKVxcYi8udGVzdChvcykpIHtcclxuICAgICAgbmFtZSA9ICdGaXJlZm94IE1vYmlsZSc7XHJcbiAgICB9XHJcbiAgICAvLyBPYnNjdXJlIE1heHRob24ncyB1bnJlbGlhYmxlIHZlcnNpb24uXHJcbiAgICBlbHNlIGlmIChuYW1lID09ICdNYXh0aG9uJyAmJiB2ZXJzaW9uKSB7XHJcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnJlcGxhY2UoL1xcLltcXGQuXSsvLCAnLngnKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBYYm94IDM2MCBhbmQgWGJveCBPbmUuXHJcbiAgICBlbHNlIGlmICgvXFxiWGJveFxcYi9pLnRlc3QocHJvZHVjdCkpIHtcclxuICAgICAgb3MgPSBudWxsO1xyXG4gICAgICBpZiAocHJvZHVjdCA9PSAnWGJveCAzNjAnICYmIC9cXGJJRU1vYmlsZVxcYi8udGVzdCh1YSkpIHtcclxuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdtb2JpbGUgbW9kZScpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBBZGQgbW9iaWxlIHBvc3RmaXguXHJcbiAgICBlbHNlIGlmICgoL14oPzpDaHJvbWV8SUV8T3BlcmEpJC8udGVzdChuYW1lKSB8fCBuYW1lICYmICFwcm9kdWN0ICYmICEvQnJvd3NlcnxNb2JpLy50ZXN0KG5hbWUpKSAmJlxyXG4gICAgICAgIChvcyA9PSAnV2luZG93cyBDRScgfHwgL01vYmkvaS50ZXN0KHVhKSkpIHtcclxuICAgICAgbmFtZSArPSAnIE1vYmlsZSc7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgSUUgcGxhdGZvcm0gcHJldmlldy5cclxuICAgIGVsc2UgaWYgKG5hbWUgPT0gJ0lFJyAmJiB1c2VGZWF0dXJlcyAmJiBjb250ZXh0LmV4dGVybmFsID09PSBudWxsKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQoJ3BsYXRmb3JtIHByZXZpZXcnKTtcclxuICAgIH1cclxuICAgIC8vIERldGVjdCBCbGFja0JlcnJ5IE9TIHZlcnNpb24uXHJcbiAgICAvLyBodHRwOi8vZG9jcy5ibGFja2JlcnJ5LmNvbS9lbi9kZXZlbG9wZXJzL2RlbGl2ZXJhYmxlcy8xODE2OS9IVFRQX2hlYWRlcnNfc2VudF9ieV9CQl9Ccm93c2VyXzEyMzQ5MTFfMTEuanNwXHJcbiAgICBlbHNlIGlmICgoL1xcYkJsYWNrQmVycnlcXGIvLnRlc3QocHJvZHVjdCkgfHwgL1xcYkJCMTBcXGIvLnRlc3QodWEpKSAmJiAoZGF0YSA9XHJcbiAgICAgICAgICAoUmVnRXhwKHByb2R1Y3QucmVwbGFjZSgvICsvZywgJyAqJykgKyAnLyhbLlxcXFxkXSspJywgJ2knKS5leGVjKHVhKSB8fCAwKVsxXSB8fFxyXG4gICAgICAgICAgdmVyc2lvblxyXG4gICAgICAgICkpIHtcclxuICAgICAgZGF0YSA9IFtkYXRhLCAvQkIxMC8udGVzdCh1YSldO1xyXG4gICAgICBvcyA9IChkYXRhWzFdID8gKHByb2R1Y3QgPSBudWxsLCBtYW51ZmFjdHVyZXIgPSAnQmxhY2tCZXJyeScpIDogJ0RldmljZSBTb2Z0d2FyZScpICsgJyAnICsgZGF0YVswXTtcclxuICAgICAgdmVyc2lvbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvLyBEZXRlY3QgT3BlcmEgaWRlbnRpZnlpbmcvbWFza2luZyBpdHNlbGYgYXMgYW5vdGhlciBicm93c2VyLlxyXG4gICAgLy8gaHR0cDovL3d3dy5vcGVyYS5jb20vc3VwcG9ydC9rYi92aWV3Lzg0My9cclxuICAgIGVsc2UgaWYgKHRoaXMgIT0gZm9yT3duICYmIHByb2R1Y3QgIT0gJ1dpaScgJiYgKFxyXG4gICAgICAgICAgKHVzZUZlYXR1cmVzICYmIG9wZXJhKSB8fFxyXG4gICAgICAgICAgKC9PcGVyYS8udGVzdChuYW1lKSAmJiAvXFxiKD86TVNJRXxGaXJlZm94KVxcYi9pLnRlc3QodWEpKSB8fFxyXG4gICAgICAgICAgKG5hbWUgPT0gJ0ZpcmVmb3gnICYmIC9cXGJPUyBYICg/OlxcZCtcXC4pezIsfS8udGVzdChvcykpIHx8XHJcbiAgICAgICAgICAobmFtZSA9PSAnSUUnICYmIChcclxuICAgICAgICAgICAgKG9zICYmICEvXldpbi8udGVzdChvcykgJiYgdmVyc2lvbiA+IDUuNSkgfHxcclxuICAgICAgICAgICAgL1xcYldpbmRvd3MgWFBcXGIvLnRlc3Qob3MpICYmIHZlcnNpb24gPiA4IHx8XHJcbiAgICAgICAgICAgIHZlcnNpb24gPT0gOCAmJiAhL1xcYlRyaWRlbnRcXGIvLnRlc3QodWEpXHJcbiAgICAgICAgICApKVxyXG4gICAgICAgICkgJiYgIXJlT3BlcmEudGVzdCgoZGF0YSA9IHBhcnNlLmNhbGwoZm9yT3duLCB1YS5yZXBsYWNlKHJlT3BlcmEsICcnKSArICc7JykpKSAmJiBkYXRhLm5hbWUpIHtcclxuICAgICAgLy8gV2hlbiBcImlkZW50aWZ5aW5nXCIsIHRoZSBVQSBjb250YWlucyBib3RoIE9wZXJhIGFuZCB0aGUgb3RoZXIgYnJvd3NlcidzIG5hbWUuXHJcbiAgICAgIGRhdGEgPSAnaW5nIGFzICcgKyBkYXRhLm5hbWUgKyAoKGRhdGEgPSBkYXRhLnZlcnNpb24pID8gJyAnICsgZGF0YSA6ICcnKTtcclxuICAgICAgaWYgKHJlT3BlcmEudGVzdChuYW1lKSkge1xyXG4gICAgICAgIGlmICgvXFxiSUVcXGIvLnRlc3QoZGF0YSkgJiYgb3MgPT0gJ01hYyBPUycpIHtcclxuICAgICAgICAgIG9zID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YSA9ICdpZGVudGlmeScgKyBkYXRhO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIFdoZW4gXCJtYXNraW5nXCIsIHRoZSBVQSBjb250YWlucyBvbmx5IHRoZSBvdGhlciBicm93c2VyJ3MgbmFtZS5cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgZGF0YSA9ICdtYXNrJyArIGRhdGE7XHJcbiAgICAgICAgaWYgKG9wZXJhQ2xhc3MpIHtcclxuICAgICAgICAgIG5hbWUgPSBmb3JtYXQob3BlcmFDbGFzcy5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEgJDInKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5hbWUgPSAnT3BlcmEnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoL1xcYklFXFxiLy50ZXN0KGRhdGEpKSB7XHJcbiAgICAgICAgICBvcyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdXNlRmVhdHVyZXMpIHtcclxuICAgICAgICAgIHZlcnNpb24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBsYXlvdXQgPSBbJ1ByZXN0byddO1xyXG4gICAgICBkZXNjcmlwdGlvbi5wdXNoKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IFdlYktpdCBOaWdodGx5IGFuZCBhcHByb3hpbWF0ZSBDaHJvbWUvU2FmYXJpIHZlcnNpb25zLlxyXG4gICAgaWYgKChkYXRhID0gKC9cXGJBcHBsZVdlYktpdFxcLyhbXFxkLl0rXFwrPykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcclxuICAgICAgLy8gQ29ycmVjdCBidWlsZCBudW1iZXIgZm9yIG51bWVyaWMgY29tcGFyaXNvbi5cclxuICAgICAgLy8gKGUuZy4gXCI1MzIuNVwiIGJlY29tZXMgXCI1MzIuMDVcIilcclxuICAgICAgZGF0YSA9IFtwYXJzZUZsb2F0KGRhdGEucmVwbGFjZSgvXFwuKFxcZCkkLywgJy4wJDEnKSksIGRhdGFdO1xyXG4gICAgICAvLyBOaWdodGx5IGJ1aWxkcyBhcmUgcG9zdGZpeGVkIHdpdGggYSBcIitcIi5cclxuICAgICAgaWYgKG5hbWUgPT0gJ1NhZmFyaScgJiYgZGF0YVsxXS5zbGljZSgtMSkgPT0gJysnKSB7XHJcbiAgICAgICAgbmFtZSA9ICdXZWJLaXQgTmlnaHRseSc7XHJcbiAgICAgICAgcHJlcmVsZWFzZSA9ICdhbHBoYSc7XHJcbiAgICAgICAgdmVyc2lvbiA9IGRhdGFbMV0uc2xpY2UoMCwgLTEpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIENsZWFyIGluY29ycmVjdCBicm93c2VyIHZlcnNpb25zLlxyXG4gICAgICBlbHNlIGlmICh2ZXJzaW9uID09IGRhdGFbMV0gfHxcclxuICAgICAgICAgIHZlcnNpb24gPT0gKGRhdGFbMl0gPSAoL1xcYlNhZmFyaVxcLyhbXFxkLl0rXFwrPykvaS5leGVjKHVhKSB8fCAwKVsxXSkpIHtcclxuICAgICAgICB2ZXJzaW9uID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICAvLyBVc2UgdGhlIGZ1bGwgQ2hyb21lIHZlcnNpb24gd2hlbiBhdmFpbGFibGUuXHJcbiAgICAgIGRhdGFbMV0gPSAoL1xcYkNocm9tZVxcLyhbXFxkLl0rKS9pLmV4ZWModWEpIHx8IDApWzFdO1xyXG4gICAgICAvLyBEZXRlY3QgQmxpbmsgbGF5b3V0IGVuZ2luZS5cclxuICAgICAgaWYgKGRhdGFbMF0gPT0gNTM3LjM2ICYmIGRhdGFbMl0gPT0gNTM3LjM2ICYmIHBhcnNlRmxvYXQoZGF0YVsxXSkgPj0gMjggJiYgbGF5b3V0ID09ICdXZWJLaXQnKSB7XHJcbiAgICAgICAgbGF5b3V0ID0gWydCbGluayddO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIERldGVjdCBKYXZhU2NyaXB0Q29yZS5cclxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NzY4NDc0L2hvdy1jYW4taS1kZXRlY3Qtd2hpY2gtamF2YXNjcmlwdC1lbmdpbmUtdjgtb3ItanNjLWlzLXVzZWQtYXQtcnVudGltZS1pbi1hbmRyb2lcclxuICAgICAgaWYgKCF1c2VGZWF0dXJlcyB8fCAoIWxpa2VDaHJvbWUgJiYgIWRhdGFbMV0pKSB7XHJcbiAgICAgICAgbGF5b3V0ICYmIChsYXlvdXRbMV0gPSAnbGlrZSBTYWZhcmknKTtcclxuICAgICAgICBkYXRhID0gKGRhdGEgPSBkYXRhWzBdLCBkYXRhIDwgNDAwID8gMSA6IGRhdGEgPCA1MDAgPyAyIDogZGF0YSA8IDUyNiA/IDMgOiBkYXRhIDwgNTMzID8gNCA6IGRhdGEgPCA1MzQgPyAnNCsnIDogZGF0YSA8IDUzNSA/IDUgOiBkYXRhIDwgNTM3ID8gNiA6IGRhdGEgPCA1MzggPyA3IDogZGF0YSA8IDYwMSA/IDggOiAnOCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxheW91dCAmJiAobGF5b3V0WzFdID0gJ2xpa2UgQ2hyb21lJyk7XHJcbiAgICAgICAgZGF0YSA9IGRhdGFbMV0gfHwgKGRhdGEgPSBkYXRhWzBdLCBkYXRhIDwgNTMwID8gMSA6IGRhdGEgPCA1MzIgPyAyIDogZGF0YSA8IDUzMi4wNSA/IDMgOiBkYXRhIDwgNTMzID8gNCA6IGRhdGEgPCA1MzQuMDMgPyA1IDogZGF0YSA8IDUzNC4wNyA/IDYgOiBkYXRhIDwgNTM0LjEwID8gNyA6IGRhdGEgPCA1MzQuMTMgPyA4IDogZGF0YSA8IDUzNC4xNiA/IDkgOiBkYXRhIDwgNTM0LjI0ID8gMTAgOiBkYXRhIDwgNTM0LjMwID8gMTEgOiBkYXRhIDwgNTM1LjAxID8gMTIgOiBkYXRhIDwgNTM1LjAyID8gJzEzKycgOiBkYXRhIDwgNTM1LjA3ID8gMTUgOiBkYXRhIDwgNTM1LjExID8gMTYgOiBkYXRhIDwgNTM1LjE5ID8gMTcgOiBkYXRhIDwgNTM2LjA1ID8gMTggOiBkYXRhIDwgNTM2LjEwID8gMTkgOiBkYXRhIDwgNTM3LjAxID8gMjAgOiBkYXRhIDwgNTM3LjExID8gJzIxKycgOiBkYXRhIDwgNTM3LjEzID8gMjMgOiBkYXRhIDwgNTM3LjE4ID8gMjQgOiBkYXRhIDwgNTM3LjI0ID8gMjUgOiBkYXRhIDwgNTM3LjM2ID8gMjYgOiBsYXlvdXQgIT0gJ0JsaW5rJyA/ICcyNycgOiAnMjgnKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBBZGQgdGhlIHBvc3RmaXggb2YgXCIueFwiIG9yIFwiK1wiIGZvciBhcHByb3hpbWF0ZSB2ZXJzaW9ucy5cclxuICAgICAgbGF5b3V0ICYmIChsYXlvdXRbMV0gKz0gJyAnICsgKGRhdGEgKz0gdHlwZW9mIGRhdGEgPT0gJ251bWJlcicgPyAnLngnIDogL1suK10vLnRlc3QoZGF0YSkgPyAnJyA6ICcrJykpO1xyXG4gICAgICAvLyBPYnNjdXJlIHZlcnNpb24gZm9yIHNvbWUgU2FmYXJpIDEtMiByZWxlYXNlcy5cclxuICAgICAgaWYgKG5hbWUgPT0gJ1NhZmFyaScgJiYgKCF2ZXJzaW9uIHx8IHBhcnNlSW50KHZlcnNpb24pID4gNDUpKSB7XHJcbiAgICAgICAgdmVyc2lvbiA9IGRhdGE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIERldGVjdCBPcGVyYSBkZXNrdG9wIG1vZGVzLlxyXG4gICAgaWYgKG5hbWUgPT0gJ09wZXJhJyAmJiAgKGRhdGEgPSAvXFxiemJvdnx6dmF2JC8uZXhlYyhvcykpKSB7XHJcbiAgICAgIG5hbWUgKz0gJyAnO1xyXG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCdkZXNrdG9wIG1vZGUnKTtcclxuICAgICAgaWYgKGRhdGEgPT0gJ3p2YXYnKSB7XHJcbiAgICAgICAgbmFtZSArPSAnTWluaSc7XHJcbiAgICAgICAgdmVyc2lvbiA9IG51bGw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbmFtZSArPSAnTW9iaWxlJztcclxuICAgICAgfVxyXG4gICAgICBvcyA9IG9zLnJlcGxhY2UoUmVnRXhwKCcgKicgKyBkYXRhICsgJyQnKSwgJycpO1xyXG4gICAgfVxyXG4gICAgLy8gRGV0ZWN0IENocm9tZSBkZXNrdG9wIG1vZGUuXHJcbiAgICBlbHNlIGlmIChuYW1lID09ICdTYWZhcmknICYmIC9cXGJDaHJvbWVcXGIvLmV4ZWMobGF5b3V0ICYmIGxheW91dFsxXSkpIHtcclxuICAgICAgZGVzY3JpcHRpb24udW5zaGlmdCgnZGVza3RvcCBtb2RlJyk7XHJcbiAgICAgIG5hbWUgPSAnQ2hyb21lIE1vYmlsZSc7XHJcbiAgICAgIHZlcnNpb24gPSBudWxsO1xyXG5cclxuICAgICAgaWYgKC9cXGJPUyBYXFxiLy50ZXN0KG9zKSkge1xyXG4gICAgICAgIG1hbnVmYWN0dXJlciA9ICdBcHBsZSc7XHJcbiAgICAgICAgb3MgPSAnaU9TIDQuMysnO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG9zID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gU3RyaXAgaW5jb3JyZWN0IE9TIHZlcnNpb25zLlxyXG4gICAgaWYgKHZlcnNpb24gJiYgdmVyc2lvbi5pbmRleE9mKChkYXRhID0gL1tcXGQuXSskLy5leGVjKG9zKSkpID09IDAgJiZcclxuICAgICAgICB1YS5pbmRleE9mKCcvJyArIGRhdGEgKyAnLScpID4gLTEpIHtcclxuICAgICAgb3MgPSB0cmltKG9zLnJlcGxhY2UoZGF0YSwgJycpKTtcclxuICAgIH1cclxuICAgIC8vIEFkZCBsYXlvdXQgZW5naW5lLlxyXG4gICAgaWYgKGxheW91dCAmJiAhL1xcYig/OkF2YW50fE5vb2spXFxiLy50ZXN0KG5hbWUpICYmIChcclxuICAgICAgICAvQnJvd3NlcnxMdW5hc2NhcGV8TWF4dGhvbi8udGVzdChuYW1lKSB8fFxyXG4gICAgICAgIG5hbWUgIT0gJ1NhZmFyaScgJiYgL15pT1MvLnRlc3Qob3MpICYmIC9cXGJTYWZhcmlcXGIvLnRlc3QobGF5b3V0WzFdKSB8fFxyXG4gICAgICAgIC9eKD86QWRvYmV8QXJvcmF8QnJlYWNofE1pZG9yaXxPcGVyYXxQaGFudG9tfFJla29ucXxSb2NrfFNsZWlwbmlyfFdlYikvLnRlc3QobmFtZSkgJiYgbGF5b3V0WzFdKSkge1xyXG4gICAgICAvLyBEb24ndCBhZGQgbGF5b3V0IGRldGFpbHMgdG8gZGVzY3JpcHRpb24gaWYgdGhleSBhcmUgZmFsc2V5LlxyXG4gICAgICAoZGF0YSA9IGxheW91dFtsYXlvdXQubGVuZ3RoIC0gMV0pICYmIGRlc2NyaXB0aW9uLnB1c2goZGF0YSk7XHJcbiAgICB9XHJcbiAgICAvLyBDb21iaW5lIGNvbnRleHR1YWwgaW5mb3JtYXRpb24uXHJcbiAgICBpZiAoZGVzY3JpcHRpb24ubGVuZ3RoKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uID0gWycoJyArIGRlc2NyaXB0aW9uLmpvaW4oJzsgJykgKyAnKSddO1xyXG4gICAgfVxyXG4gICAgLy8gQXBwZW5kIG1hbnVmYWN0dXJlciB0byBkZXNjcmlwdGlvbi5cclxuICAgIGlmIChtYW51ZmFjdHVyZXIgJiYgcHJvZHVjdCAmJiBwcm9kdWN0LmluZGV4T2YobWFudWZhY3R1cmVyKSA8IDApIHtcclxuICAgICAgZGVzY3JpcHRpb24ucHVzaCgnb24gJyArIG1hbnVmYWN0dXJlcik7XHJcbiAgICB9XHJcbiAgICAvLyBBcHBlbmQgcHJvZHVjdCB0byBkZXNjcmlwdGlvbi5cclxuICAgIGlmIChwcm9kdWN0KSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnB1c2goKC9eb24gLy50ZXN0KGRlc2NyaXB0aW9uW2Rlc2NyaXB0aW9uLmxlbmd0aCAtIDFdKSA/ICcnIDogJ29uICcpICsgcHJvZHVjdCk7XHJcbiAgICB9XHJcbiAgICAvLyBQYXJzZSB0aGUgT1MgaW50byBhbiBvYmplY3QuXHJcbiAgICBpZiAob3MpIHtcclxuICAgICAgZGF0YSA9IC8gKFtcXGQuK10rKSQvLmV4ZWMob3MpO1xyXG4gICAgICBpc1NwZWNpYWxDYXNlZE9TID0gZGF0YSAmJiBvcy5jaGFyQXQob3MubGVuZ3RoIC0gZGF0YVswXS5sZW5ndGggLSAxKSA9PSAnLyc7XHJcbiAgICAgIG9zID0ge1xyXG4gICAgICAgICdhcmNoaXRlY3R1cmUnOiAzMixcclxuICAgICAgICAnZmFtaWx5JzogKGRhdGEgJiYgIWlzU3BlY2lhbENhc2VkT1MpID8gb3MucmVwbGFjZShkYXRhWzBdLCAnJykgOiBvcyxcclxuICAgICAgICAndmVyc2lvbic6IGRhdGEgPyBkYXRhWzFdIDogbnVsbCxcclxuICAgICAgICAndG9TdHJpbmcnOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHZhciB2ZXJzaW9uID0gdGhpcy52ZXJzaW9uO1xyXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmFtaWx5ICsgKCh2ZXJzaW9uICYmICFpc1NwZWNpYWxDYXNlZE9TKSA/ICcgJyArIHZlcnNpb24gOiAnJykgKyAodGhpcy5hcmNoaXRlY3R1cmUgPT0gNjQgPyAnIDY0LWJpdCcgOiAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgLy8gQWRkIGJyb3dzZXIvT1MgYXJjaGl0ZWN0dXJlLlxyXG4gICAgaWYgKChkYXRhID0gL1xcYig/OkFNRHxJQXxXaW58V09XfHg4Nl98eCk2NFxcYi9pLmV4ZWMoYXJjaCkpICYmICEvXFxiaTY4NlxcYi9pLnRlc3QoYXJjaCkpIHtcclxuICAgICAgaWYgKG9zKSB7XHJcbiAgICAgICAgb3MuYXJjaGl0ZWN0dXJlID0gNjQ7XHJcbiAgICAgICAgb3MuZmFtaWx5ID0gb3MuZmFtaWx5LnJlcGxhY2UoUmVnRXhwKCcgKicgKyBkYXRhKSwgJycpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChcclxuICAgICAgICAgIG5hbWUgJiYgKC9cXGJXT1c2NFxcYi9pLnRlc3QodWEpIHx8XHJcbiAgICAgICAgICAodXNlRmVhdHVyZXMgJiYgL1xcdyg/Ojg2fDMyKSQvLnRlc3QobmF2LmNwdUNsYXNzIHx8IG5hdi5wbGF0Zm9ybSkgJiYgIS9cXGJXaW42NDsgeDY0XFxiL2kudGVzdCh1YSkpKVxyXG4gICAgICApIHtcclxuICAgICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KCczMi1iaXQnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2hyb21lIDM5IGFuZCBhYm92ZSBvbiBPUyBYIGlzIGFsd2F5cyA2NC1iaXQuXHJcbiAgICBlbHNlIGlmIChcclxuICAgICAgICBvcyAmJiAvXk9TIFgvLnRlc3Qob3MuZmFtaWx5KSAmJlxyXG4gICAgICAgIG5hbWUgPT0gJ0Nocm9tZScgJiYgcGFyc2VGbG9hdCh2ZXJzaW9uKSA+PSAzOVxyXG4gICAgKSB7XHJcbiAgICAgIG9zLmFyY2hpdGVjdHVyZSA9IDY0O1xyXG4gICAgfVxyXG5cclxuICAgIHVhIHx8ICh1YSA9IG51bGwpO1xyXG5cclxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwbGF0Zm9ybSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIE9iamVjdFxyXG4gICAgICovXHJcbiAgICB2YXIgcGxhdGZvcm0gPSB7fTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwbGF0Zm9ybSBkZXNjcmlwdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXHJcbiAgICAgKi9cclxuICAgIHBsYXRmb3JtLmRlc2NyaXB0aW9uID0gdWE7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYnJvd3NlcidzIGxheW91dCBlbmdpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5sYXlvdXQgPSBsYXlvdXQgJiYgbGF5b3V0WzBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHByb2R1Y3QncyBtYW51ZmFjdHVyZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5tYW51ZmFjdHVyZXIgPSBtYW51ZmFjdHVyZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgYnJvd3Nlci9lbnZpcm9ubWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXHJcbiAgICAgKi9cclxuICAgIHBsYXRmb3JtLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFscGhhL2JldGEgcmVsZWFzZSBpbmRpY2F0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9kdWN0IGhvc3RpbmcgdGhlIGJyb3dzZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5wcm9kdWN0ID0gcHJvZHVjdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBicm93c2VyJ3MgdXNlciBhZ2VudCBzdHJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIHBsYXRmb3JtXHJcbiAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS51YSA9IHVhO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJyb3dzZXIvZW52aXJvbm1lbnQgdmVyc2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXHJcbiAgICAgKi9cclxuICAgIHBsYXRmb3JtLnZlcnNpb24gPSBuYW1lICYmIHZlcnNpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgb3BlcmF0aW5nIHN5c3RlbS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm1cclxuICAgICAqIEB0eXBlIE9iamVjdFxyXG4gICAgICovXHJcbiAgICBwbGF0Zm9ybS5vcyA9IG9zIHx8IHtcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgQ1BVIGFyY2hpdGVjdHVyZSB0aGUgT1MgaXMgYnVpbHQgZm9yLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBAbWVtYmVyT2YgcGxhdGZvcm0ub3NcclxuICAgICAgICogQHR5cGUgbnVtYmVyfG51bGxcclxuICAgICAgICovXHJcbiAgICAgICdhcmNoaXRlY3R1cmUnOiBudWxsLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFRoZSBmYW1pbHkgb2YgdGhlIE9TLlxyXG4gICAgICAgKlxyXG4gICAgICAgKiBDb21tb24gdmFsdWVzIGluY2x1ZGU6XHJcbiAgICAgICAqIFwiV2luZG93c1wiLCBcIldpbmRvd3MgU2VydmVyIDIwMDggUjIgLyA3XCIsIFwiV2luZG93cyBTZXJ2ZXIgMjAwOCAvIFZpc3RhXCIsXHJcbiAgICAgICAqIFwiV2luZG93cyBYUFwiLCBcIk9TIFhcIiwgXCJVYnVudHVcIiwgXCJEZWJpYW5cIiwgXCJGZWRvcmFcIiwgXCJSZWQgSGF0XCIsIFwiU3VTRVwiLFxyXG4gICAgICAgKiBcIkFuZHJvaWRcIiwgXCJpT1NcIiBhbmQgXCJXaW5kb3dzIFBob25lXCJcclxuICAgICAgICpcclxuICAgICAgICogQG1lbWJlck9mIHBsYXRmb3JtLm9zXHJcbiAgICAgICAqIEB0eXBlIHN0cmluZ3xudWxsXHJcbiAgICAgICAqL1xyXG4gICAgICAnZmFtaWx5JzogbnVsbCxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBUaGUgdmVyc2lvbiBvZiB0aGUgT1MuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBtZW1iZXJPZiBwbGF0Zm9ybS5vc1xyXG4gICAgICAgKiBAdHlwZSBzdHJpbmd8bnVsbFxyXG4gICAgICAgKi9cclxuICAgICAgJ3ZlcnNpb24nOiBudWxsLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIFJldHVybnMgdGhlIE9TIHN0cmluZy5cclxuICAgICAgICpcclxuICAgICAgICogQG1lbWJlck9mIHBsYXRmb3JtLm9zXHJcbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBPUyBzdHJpbmcuXHJcbiAgICAgICAqL1xyXG4gICAgICAndG9TdHJpbmcnOiBmdW5jdGlvbigpIHsgcmV0dXJuICdudWxsJzsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBwbGF0Zm9ybS5wYXJzZSA9IHBhcnNlO1xyXG4gICAgcGxhdGZvcm0udG9TdHJpbmcgPSB0b1N0cmluZ1BsYXRmb3JtO1xyXG5cclxuICAgIGlmIChwbGF0Zm9ybS52ZXJzaW9uKSB7XHJcbiAgICAgIGRlc2NyaXB0aW9uLnVuc2hpZnQodmVyc2lvbik7XHJcbiAgICB9XHJcbiAgICBpZiAocGxhdGZvcm0ubmFtZSkge1xyXG4gICAgICBkZXNjcmlwdGlvbi51bnNoaWZ0KG5hbWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9zICYmIG5hbWUgJiYgIShvcyA9PSBTdHJpbmcob3MpLnNwbGl0KCcgJylbMF0gJiYgKG9zID09IG5hbWUuc3BsaXQoJyAnKVswXSB8fCBwcm9kdWN0KSkpIHtcclxuICAgICAgZGVzY3JpcHRpb24ucHVzaChwcm9kdWN0ID8gJygnICsgb3MgKyAnKScgOiAnb24gJyArIG9zKTtcclxuICAgIH1cclxuICAgIGlmIChkZXNjcmlwdGlvbi5sZW5ndGgpIHtcclxuICAgICAgcGxhdGZvcm0uZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbi5qb2luKCcgJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGxhdGZvcm07XHJcbiAgfVxyXG5cclxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuXHJcbiAgLy8gRXhwb3J0IHBsYXRmb3JtLlxyXG4gIHZhciBwbGF0Zm9ybSA9IHBhcnNlKCk7XHJcblxyXG4gIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIGNvbmRpdGlvbiBwYXR0ZXJucyBsaWtlIHRoZSBmb2xsb3dpbmc6XHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAvLyBFeHBvc2UgcGxhdGZvcm0gb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBwbGF0Zm9ybSBpc1xyXG4gICAgLy8gbG9hZGVkIGJ5IGEgc2NyaXB0IHRhZyBpbiB0aGUgcHJlc2VuY2Ugb2YgYW4gQU1EIGxvYWRlci5cclxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICByb290LnBsYXRmb3JtID0gcGxhdGZvcm07XHJcblxyXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28gcGxhdGZvcm0gY2FuIGJlIGFsaWFzZWQgdGhyb3VnaCBwYXRoIG1hcHBpbmcuXHJcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBwbGF0Zm9ybTtcclxuICAgIH0pO1xyXG4gIH1cclxuICAvLyBDaGVjayBmb3IgYGV4cG9ydHNgIGFmdGVyIGBkZWZpbmVgIGluIGNhc2UgYSBidWlsZCBvcHRpbWl6ZXIgYWRkcyBhbiBgZXhwb3J0c2Agb2JqZWN0LlxyXG4gIGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcclxuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cclxuICAgIGZvck93bihwbGF0Zm9ybSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG4gICAgICBmcmVlRXhwb3J0c1trZXldID0gdmFsdWU7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXHJcbiAgICByb290LnBsYXRmb3JtID0gcGxhdGZvcm07XHJcbiAgfVxyXG59LmNhbGwodGhpcykpO1xyXG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkbGwtcmVmZXJlbmNlIGRsbF8yYWRjMjQwM2Q4OWFkYzE2ZWFkMCAqLyBcImRsbC1yZWZlcmVuY2UgZGxsXzJhZGMyNDAzZDg5YWRjMTZlYWQwXCIpKShcIi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qc1wiKTsiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSAoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZGxsLXJlZmVyZW5jZSBkbGxfMmFkYzI0MDNkODlhZGMxNmVhZDAgKi8gXCJkbGwtcmVmZXJlbmNlIGRsbF8yYWRjMjQwM2Q4OWFkYzE2ZWFkMFwiKSkoXCIuL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qc1wiKTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIGRlZmluZShHcCwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gIGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvbik7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIHRvU3RyaW5nVGFnU3ltYm9sLFxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICApO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIGluIG1vZGVybiBlbmdpbmVzXG4gIC8vIHdlIGNhbiBleHBsaWNpdGx5IGFjY2VzcyBnbG9iYWxUaGlzLiBJbiBvbGRlciBlbmdpbmVzIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIikge1xuICAgIGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbiAgfSBlbHNlIHtcbiAgICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xuICB9XG59XG4iLCJ2YXIgVU5LTk9XTl9GVU5DVElPTiA9ICc8dW5rbm93bj4nO1xuLyoqXG4gKiBUaGlzIHBhcnNlcyB0aGUgZGlmZmVyZW50IHN0YWNrIHRyYWNlcyBhbmQgcHV0cyB0aGVtIGludG8gb25lIGZvcm1hdFxuICogVGhpcyBib3Jyb3dzIGhlYXZpbHkgZnJvbSBUcmFjZUtpdCAoaHR0cHM6Ly9naXRodWIuY29tL2Nzbm92ZXIvVHJhY2VLaXQpXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RhY2tTdHJpbmcpIHtcbiAgdmFyIGxpbmVzID0gc3RhY2tTdHJpbmcuc3BsaXQoJ1xcbicpO1xuICByZXR1cm4gbGluZXMucmVkdWNlKGZ1bmN0aW9uIChzdGFjaywgbGluZSkge1xuICAgIHZhciBwYXJzZVJlc3VsdCA9IHBhcnNlQ2hyb21lKGxpbmUpIHx8IHBhcnNlV2luanMobGluZSkgfHwgcGFyc2VHZWNrbyhsaW5lKSB8fCBwYXJzZU5vZGUobGluZSkgfHwgcGFyc2VKU0MobGluZSk7XG5cbiAgICBpZiAocGFyc2VSZXN1bHQpIHtcbiAgICAgIHN0YWNrLnB1c2gocGFyc2VSZXN1bHQpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfSwgW10pO1xufVxudmFyIGNocm9tZVJlID0gL15cXHMqYXQgKC4qPykgP1xcKCgoPzpmaWxlfGh0dHBzP3xibG9ifGNocm9tZS1leHRlbnNpb258bmF0aXZlfGV2YWx8d2VicGFja3w8YW5vbnltb3VzPnxcXC98W2Etel06XFxcXHxcXFxcXFxcXCkuKj8pKD86OihcXGQrKSk/KD86OihcXGQrKSk/XFwpP1xccyokL2k7XG52YXIgY2hyb21lRXZhbFJlID0gL1xcKChcXFMqKSg/OjooXFxkKykpKD86OihcXGQrKSlcXCkvO1xuXG5mdW5jdGlvbiBwYXJzZUNocm9tZShsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGNocm9tZVJlLmV4ZWMobGluZSk7XG5cbiAgaWYgKCFwYXJ0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGlzTmF0aXZlID0gcGFydHNbMl0gJiYgcGFydHNbMl0uaW5kZXhPZignbmF0aXZlJykgPT09IDA7IC8vIHN0YXJ0IG9mIGxpbmVcblxuICB2YXIgaXNFdmFsID0gcGFydHNbMl0gJiYgcGFydHNbMl0uaW5kZXhPZignZXZhbCcpID09PSAwOyAvLyBzdGFydCBvZiBsaW5lXG5cbiAgdmFyIHN1Ym1hdGNoID0gY2hyb21lRXZhbFJlLmV4ZWMocGFydHNbMl0pO1xuXG4gIGlmIChpc0V2YWwgJiYgc3VibWF0Y2ggIT0gbnVsbCkge1xuICAgIC8vIHRocm93IG91dCBldmFsIGxpbmUvY29sdW1uIGFuZCB1c2UgdG9wLW1vc3QgbGluZS9jb2x1bW4gbnVtYmVyXG4gICAgcGFydHNbMl0gPSBzdWJtYXRjaFsxXTsgLy8gdXJsXG5cbiAgICBwYXJ0c1szXSA9IHN1Ym1hdGNoWzJdOyAvLyBsaW5lXG5cbiAgICBwYXJ0c1s0XSA9IHN1Ym1hdGNoWzNdOyAvLyBjb2x1bW5cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZmlsZTogIWlzTmF0aXZlID8gcGFydHNbMl0gOiBudWxsLFxuICAgIG1ldGhvZE5hbWU6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXG4gICAgYXJndW1lbnRzOiBpc05hdGl2ZSA/IFtwYXJ0c1syXV0gOiBbXSxcbiAgICBsaW5lTnVtYmVyOiBwYXJ0c1szXSA/ICtwYXJ0c1szXSA6IG51bGwsXG4gICAgY29sdW1uOiBwYXJ0c1s0XSA/ICtwYXJ0c1s0XSA6IG51bGxcbiAgfTtcbn1cblxudmFyIHdpbmpzUmUgPSAvXlxccyphdCAoPzooKD86XFxbb2JqZWN0IG9iamVjdFxcXSk/LispICk/XFwoPygoPzpmaWxlfG1zLWFwcHh8aHR0cHM/fHdlYnBhY2t8YmxvYik6Lio/KTooXFxkKykoPzo6KFxcZCspKT9cXCk/XFxzKiQvaTtcblxuZnVuY3Rpb24gcGFyc2VXaW5qcyhsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IHdpbmpzUmUuZXhlYyhsaW5lKTtcblxuICBpZiAoIXBhcnRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZpbGU6IHBhcnRzWzJdLFxuICAgIG1ldGhvZE5hbWU6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXG4gICAgYXJndW1lbnRzOiBbXSxcbiAgICBsaW5lTnVtYmVyOiArcGFydHNbM10sXG4gICAgY29sdW1uOiBwYXJ0c1s0XSA/ICtwYXJ0c1s0XSA6IG51bGxcbiAgfTtcbn1cblxudmFyIGdlY2tvUmUgPSAvXlxccyooLio/KSg/OlxcKCguKj8pXFwpKT8oPzpefEApKCg/OmZpbGV8aHR0cHM/fGJsb2J8Y2hyb21lfHdlYnBhY2t8cmVzb3VyY2V8XFxbbmF0aXZlKS4qP3xbXkBdKmJ1bmRsZSkoPzo6KFxcZCspKT8oPzo6KFxcZCspKT9cXHMqJC9pO1xudmFyIGdlY2tvRXZhbFJlID0gLyhcXFMrKSBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsL2k7XG5cbmZ1bmN0aW9uIHBhcnNlR2Vja28obGluZSkge1xuICB2YXIgcGFydHMgPSBnZWNrb1JlLmV4ZWMobGluZSk7XG5cbiAgaWYgKCFwYXJ0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGlzRXZhbCA9IHBhcnRzWzNdICYmIHBhcnRzWzNdLmluZGV4T2YoJyA+IGV2YWwnKSA+IC0xO1xuICB2YXIgc3VibWF0Y2ggPSBnZWNrb0V2YWxSZS5leGVjKHBhcnRzWzNdKTtcblxuICBpZiAoaXNFdmFsICYmIHN1Ym1hdGNoICE9IG51bGwpIHtcbiAgICAvLyB0aHJvdyBvdXQgZXZhbCBsaW5lL2NvbHVtbiBhbmQgdXNlIHRvcC1tb3N0IGxpbmUgbnVtYmVyXG4gICAgcGFydHNbM10gPSBzdWJtYXRjaFsxXTtcbiAgICBwYXJ0c1s0XSA9IHN1Ym1hdGNoWzJdO1xuICAgIHBhcnRzWzVdID0gbnVsbDsgLy8gbm8gY29sdW1uIHdoZW4gZXZhbFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmaWxlOiBwYXJ0c1szXSxcbiAgICBtZXRob2ROYW1lOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgIGFyZ3VtZW50czogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnLCcpIDogW10sXG4gICAgbGluZU51bWJlcjogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsLFxuICAgIGNvbHVtbjogcGFydHNbNV0gPyArcGFydHNbNV0gOiBudWxsXG4gIH07XG59XG5cbnZhciBqYXZhU2NyaXB0Q29yZVJlID0gL15cXHMqKD86KFteQF0qKSg/OlxcKCguKj8pXFwpKT9AKT8oXFxTLio/KTooXFxkKykoPzo6KFxcZCspKT9cXHMqJC9pO1xuXG5mdW5jdGlvbiBwYXJzZUpTQyhsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGphdmFTY3JpcHRDb3JlUmUuZXhlYyhsaW5lKTtcblxuICBpZiAoIXBhcnRzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZpbGU6IHBhcnRzWzNdLFxuICAgIG1ldGhvZE5hbWU6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXG4gICAgYXJndW1lbnRzOiBbXSxcbiAgICBsaW5lTnVtYmVyOiArcGFydHNbNF0sXG4gICAgY29sdW1uOiBwYXJ0c1s1XSA/ICtwYXJ0c1s1XSA6IG51bGxcbiAgfTtcbn1cblxudmFyIG5vZGVSZSA9IC9eXFxzKmF0ICg/OigoPzpcXFtvYmplY3Qgb2JqZWN0XFxdKT9bXlxcXFwvXSsoPzogXFxbYXMgXFxTK1xcXSk/KSApP1xcKD8oLio/KTooXFxkKykoPzo6KFxcZCspKT9cXCk/XFxzKiQvaTtcblxuZnVuY3Rpb24gcGFyc2VOb2RlKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbm9kZVJlLmV4ZWMobGluZSk7XG5cbiAgaWYgKCFwYXJ0cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBmaWxlOiBwYXJ0c1syXSxcbiAgICBtZXRob2ROYW1lOiBwYXJ0c1sxXSB8fCBVTktOT1dOX0ZVTkNUSU9OLFxuICAgIGFyZ3VtZW50czogW10sXG4gICAgbGluZU51bWJlcjogK3BhcnRzWzNdLFxuICAgIGNvbHVtbjogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsXG4gIH07XG59XG5cbmV4cG9ydCB7IHBhcnNlIH07XG4iLCJ2YXIgdCxuLGU9ZnVuY3Rpb24oKXtyZXR1cm5cIlwiLmNvbmNhdChEYXRlLm5vdygpLFwiLVwiKS5jb25jYXQoTWF0aC5mbG9vcig4OTk5OTk5OTk5OTk5Kk1hdGgucmFuZG9tKCkpKzFlMTIpfSxpPWZ1bmN0aW9uKHQpe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTotMTtyZXR1cm57bmFtZTp0LHZhbHVlOm4sZGVsdGE6MCxlbnRyaWVzOltdLGlkOmUoKSxpc0ZpbmFsOiExfX0sYT1mdW5jdGlvbih0LG4pe3RyeXtpZihQZXJmb3JtYW5jZU9ic2VydmVyLnN1cHBvcnRlZEVudHJ5VHlwZXMuaW5jbHVkZXModCkpe3ZhciBlPW5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKChmdW5jdGlvbih0KXtyZXR1cm4gdC5nZXRFbnRyaWVzKCkubWFwKG4pfSkpO3JldHVybiBlLm9ic2VydmUoe3R5cGU6dCxidWZmZXJlZDohMH0pLGV9fWNhdGNoKHQpe319LHI9ITEsbz0hMSxzPWZ1bmN0aW9uKHQpe3I9IXQucGVyc2lzdGVkfSx1PWZ1bmN0aW9uKCl7YWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIscyksYWRkRXZlbnRMaXN0ZW5lcihcInVubG9hZFwiLChmdW5jdGlvbigpe30pKX0sYz1mdW5jdGlvbih0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdO298fCh1KCksbz0hMCksYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwoZnVuY3Rpb24obil7dmFyIGU9bi50aW1lU3RhbXA7XCJoaWRkZW5cIj09PWRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSYmdCh7dGltZVN0YW1wOmUsaXNVbmxvYWRpbmc6cn0pfSkse2NhcHR1cmU6ITAsb25jZTpufSl9LGw9ZnVuY3Rpb24odCxuLGUsaSl7dmFyIGE7cmV0dXJuIGZ1bmN0aW9uKCl7ZSYmbi5pc0ZpbmFsJiZlLmRpc2Nvbm5lY3QoKSxuLnZhbHVlPj0wJiYoaXx8bi5pc0ZpbmFsfHxcImhpZGRlblwiPT09ZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlKSYmKG4uZGVsdGE9bi52YWx1ZS0oYXx8MCksKG4uZGVsdGF8fG4uaXNGaW5hbHx8dm9pZCAwPT09YSkmJih0KG4pLGE9bi52YWx1ZSkpfX0scD1mdW5jdGlvbih0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLGU9aShcIkNMU1wiLDApLHI9ZnVuY3Rpb24odCl7dC5oYWRSZWNlbnRJbnB1dHx8KGUudmFsdWUrPXQudmFsdWUsZS5lbnRyaWVzLnB1c2godCkscygpKX0sbz1hKFwibGF5b3V0LXNoaWZ0XCIscikscz1sKHQsZSxvLG4pO2MoKGZ1bmN0aW9uKHQpe3ZhciBuPXQuaXNVbmxvYWRpbmc7byYmby50YWtlUmVjb3JkcygpLm1hcChyKSxuJiYoZS5pc0ZpbmFsPSEwKSxzKCl9KSl9LGQ9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9XCJoaWRkZW5cIj09PWRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZT8wOjEvMCxjKChmdW5jdGlvbihuKXt2YXIgZT1uLnRpbWVTdGFtcDtyZXR1cm4gdD1lfSksITApKSx7Z2V0IHRpbWVTdGFtcCgpe3JldHVybiB0fX19LG09ZnVuY3Rpb24odCl7dmFyIG49aShcIkZDUFwiKSxlPWQoKSxyPWEoXCJwYWludFwiLChmdW5jdGlvbih0KXtcImZpcnN0LWNvbnRlbnRmdWwtcGFpbnRcIj09PXQubmFtZSYmdC5zdGFydFRpbWU8ZS50aW1lU3RhbXAmJihuLnZhbHVlPXQuc3RhcnRUaW1lLG4uaXNGaW5hbD0hMCxuLmVudHJpZXMucHVzaCh0KSxvKCkpfSkpLG89bCh0LG4scil9LHY9ZnVuY3Rpb24odCl7dmFyIG49aShcIkZJRFwiKSxlPWQoKSxyPWZ1bmN0aW9uKHQpe3Quc3RhcnRUaW1lPGUudGltZVN0YW1wJiYobi52YWx1ZT10LnByb2Nlc3NpbmdTdGFydC10LnN0YXJ0VGltZSxuLmVudHJpZXMucHVzaCh0KSxuLmlzRmluYWw9ITAscygpKX0sbz1hKFwiZmlyc3QtaW5wdXRcIixyKSxzPWwodCxuLG8pO2MoKGZ1bmN0aW9uKCl7byYmKG8udGFrZVJlY29yZHMoKS5tYXAociksby5kaXNjb25uZWN0KCkpfSksITApLG98fHdpbmRvdy5wZXJmTWV0cmljcyYmd2luZG93LnBlcmZNZXRyaWNzLm9uRmlyc3RJbnB1dERlbGF5JiZ3aW5kb3cucGVyZk1ldHJpY3Mub25GaXJzdElucHV0RGVsYXkoKGZ1bmN0aW9uKHQsaSl7aS50aW1lU3RhbXA8ZS50aW1lU3RhbXAmJihuLnZhbHVlPXQsbi5pc0ZpbmFsPSEwLG4uZW50cmllcz1be2VudHJ5VHlwZTpcImZpcnN0LWlucHV0XCIsbmFtZTppLnR5cGUsdGFyZ2V0OmkudGFyZ2V0LGNhbmNlbGFibGU6aS5jYW5jZWxhYmxlLHN0YXJ0VGltZTppLnRpbWVTdGFtcCxwcm9jZXNzaW5nU3RhcnQ6aS50aW1lU3RhbXArdH1dLHMoKSl9KSl9LGY9ZnVuY3Rpb24oKXtyZXR1cm4gbnx8KG49bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQpe3JldHVybltcInNjcm9sbFwiLFwia2V5ZG93blwiLFwicG9pbnRlcmRvd25cIl0ubWFwKChmdW5jdGlvbihuKXthZGRFdmVudExpc3RlbmVyKG4sdCx7b25jZTohMCxwYXNzaXZlOiEwLGNhcHR1cmU6ITB9KX0pKX0pKSksbn0sZz1mdW5jdGlvbih0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmYXJndW1lbnRzWzFdLGU9aShcIkxDUFwiKSxyPWQoKSxvPWZ1bmN0aW9uKHQpe3ZhciBuPXQuc3RhcnRUaW1lO248ci50aW1lU3RhbXA/KGUudmFsdWU9bixlLmVudHJpZXMucHVzaCh0KSk6ZS5pc0ZpbmFsPSEwLHUoKX0scz1hKFwibGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50XCIsbyksdT1sKHQsZSxzLG4pLHA9ZnVuY3Rpb24oKXtlLmlzRmluYWx8fChzJiZzLnRha2VSZWNvcmRzKCkubWFwKG8pLGUuaXNGaW5hbD0hMCx1KCkpfTtmKCkudGhlbihwKSxjKHAsITApfSxoPWZ1bmN0aW9uKHQpe3ZhciBuLGU9aShcIlRURkJcIik7bj1mdW5jdGlvbigpe3RyeXt2YXIgbj1wZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlUeXBlKFwibmF2aWdhdGlvblwiKVswXXx8ZnVuY3Rpb24oKXt2YXIgdD1wZXJmb3JtYW5jZS50aW1pbmcsbj17ZW50cnlUeXBlOlwibmF2aWdhdGlvblwiLHN0YXJ0VGltZTowfTtmb3IodmFyIGUgaW4gdClcIm5hdmlnYXRpb25TdGFydFwiIT09ZSYmXCJ0b0pTT05cIiE9PWUmJihuW2VdPU1hdGgubWF4KHRbZV0tdC5uYXZpZ2F0aW9uU3RhcnQsMCkpO3JldHVybiBufSgpO2UudmFsdWU9ZS5kZWx0YT1uLnJlc3BvbnNlU3RhcnQsZS5lbnRyaWVzPVtuXSxlLmlzRmluYWw9ITAsdChlKX1jYXRjaCh0KXt9fSxcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlP3NldFRpbWVvdXQobiwwKTphZGRFdmVudExpc3RlbmVyKFwicGFnZXNob3dcIixuKX07ZXhwb3J0e3AgYXMgZ2V0Q0xTLG0gYXMgZ2V0RkNQLHYgYXMgZ2V0RklELGcgYXMgZ2V0TENQLGggYXMgZ2V0VFRGQn07XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGRsbF8yYWRjMjQwM2Q4OWFkYzE2ZWFkMDsiXSwic291cmNlUm9vdCI6IiJ9